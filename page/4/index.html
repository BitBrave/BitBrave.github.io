<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:type" content="website">
<meta property="og:title" content="BitBrave">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="BitBrave">
<meta property="og:description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XJ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>BitBrave</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7e6d55cf2fa14e729703953237f65413";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BitBrave</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">IIE</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(1031.%20Maximum%20Sum%20of%20Two%20Non-Overlapping%20Subarrays)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(1031.%20Maximum%20Sum%20of%20Two%20Non-Overlapping%20Subarrays)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(1031. Maximum Sum of Two Non-Overlapping Subarrays)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays-题解"><a href="#LeetCode-1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays-题解" class="headerlink" title="LeetCode(\1031. Maximum Sum of Two Non-Overlapping Subarrays)题解"></a>LeetCode(\1031. Maximum Sum of Two Non-Overlapping Subarrays)题解</h1><p>Given an array <code>A</code> of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths <code>L</code> and <code>M</code>. (For clarification, the <code>L</code>-length subarray could occur before or after the <code>M</code>-length subarray.)</p>
<p>Formally, return the largest <code>V</code> for which <code>V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1])</code> and either:</p>
<ul>
<li><code>0 &lt;= i &lt; i + L - 1 &lt; j &lt; j + M - 1 &lt; A.length</code>, <strong>or</strong></li>
<li><code>0 &lt;= j &lt; j + M - 1 &lt; i &lt; i + L - 1 &lt; A.length</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [0,6,5,2,2,5,1,9,4], L &#x3D; 1, M &#x3D; 2</span><br><span class="line">Output: 20</span><br><span class="line">Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [3,8,1,3,2,1,8,9,0], L &#x3D; 3, M &#x3D; 2</span><br><span class="line">Output: 29</span><br><span class="line">Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [2,1,5,6,0,9,5,0,3,8], L &#x3D; 4, M &#x3D; 3</span><br><span class="line">Output: 31</span><br><span class="line">Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>L &gt;= 1</code></li>
<li><code>M &gt;= 1</code></li>
<li><code>L + M &lt;= A.length &lt;= 1000</code></li>
<li><code>0 &lt;= A[i] &lt;= 1000</code></li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给出一个非负数元素组成的数组，给定两个长度值，要求选出两个不相重的连续子数组，其和值为所有的符合条件的数组中最大的，要求返回这个和。</p>
<p>这个题可以依次从左到右选定一个长度的子树组，然后选择另外的数组，这个过程中保存最大值。等于就是暴力枚举。至于求解和值，可以使用一个登长的数组记录数组元素从左到右元素的依次加和。</p>
<p>这个居然花了我蛮多时间，我果然还是太菜了。</p>
<p><code>Runtime: 16 ms, faster than 18.19% of C++ online submissions for Maximum Sum of Two Non-Overlapping Subarrays.</code></p>
<p><code>Memory Usage: 8.8 MB, less than 54.54% of C++ online submissions for Maximum Sum of Two Non-Overlapping Subarrays.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> L, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.<span class="built_in">size</span>(), ret = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">S</span><span class="params">(len+<span class="number">1</span>)</span></span>;</span><br><span class="line">        S[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) S[i+<span class="number">1</span>] += S[i] + A[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=L<span class="number">-1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="comment">// before</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=M<span class="number">-1</span>; j&lt;i+<span class="number">1</span>-L; j++) ret = <span class="built_in">max</span>(ret, S[i+<span class="number">1</span>]-S[i+<span class="number">1</span>-L]+S[j+<span class="number">1</span>]-S[j+<span class="number">1</span>-M]);</span><br><span class="line">            <span class="comment">// after</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+M; j&lt;len; j++) ret = <span class="built_in">max</span>(ret, S[i+<span class="number">1</span>]-S[i+<span class="number">1</span>-L]+S[j+<span class="number">1</span>]-S[j+<span class="number">1</span>-M]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2019-11-29</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(1038.%20Binary%20Search%20Tree%20to%20Greater%20Sum%20Tree)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(1038.%20Binary%20Search%20Tree%20to%20Greater%20Sum%20Tree)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(1038. Binary Search Tree to Greater Sum Tree)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-1038-Binary-Search-Tree-to-Greater-Sum-Tree-题解"><a href="#LeetCode-1038-Binary-Search-Tree-to-Greater-Sum-Tree-题解" class="headerlink" title="LeetCode(\1038. Binary Search Tree to Greater Sum Tree)题解"></a>LeetCode(\1038. Binary Search Tree to Greater Sum Tree)题解</h1><p>Given the root of a binary <strong>search</strong> tree with distinct values, modify it so that every <code>node</code> has a new value equal to the sum of the values of the original tree that are greater than or equal to <code>node.val</code>.</p>
<p>As a reminder, a <em>binary search tree</em> is a tree that satisfies these constraints:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/05/02/tree.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The number of nodes in the tree is between <code>1</code> and <code>100</code>.</li>
<li>Each node will have value between <code>0</code> and <code>100</code>.</li>
<li>The given tree is a binary search tree.</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个BST（二叉搜索树），其中每个节点的值都不一样，现在对每个值进行改变，将每个节点的值改为原本二叉树中大于等于这个节点值的节点的值的和。（理解了好久才明白这个题意！）</p>
<p>这个题说白了就是，找到一个节点，然后统计BST中大于等于这个节点值的所有节点，把这些节点的值加起来更新为这个节点的值。而BST在中序遍历上就是一个递增的序列。因此我们可以使用一个倒着的中序遍历，然后把前面的值分别求和加到后面的值上即可。</p>
<p>代码如下，时间复杂度O(N)，空间复杂度O(1)。</p>
<p><code>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Search Tree to Greater Sum Tree.</code></p>
<p><code>Memory Usage: 9.1 MB, less than 100.00% of C++ online submissions for Binary Search Tree to Greater Sum Tree.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = root-&gt;val, r = inOrder(root-&gt;right, val);</span><br><span class="line">        root-&gt;val += r + val;</span><br><span class="line">        <span class="keyword">return</span> tmp + r + inOrder(root-&gt;left, root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstToGst</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inOrder(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2019-11-22</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(1043.%20Partition%20Array%20for%20Maximum%20Sum)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(1043.%20Partition%20Array%20for%20Maximum%20Sum)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(1043. Partition Array for Maximum Sum)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-1043-Partition-Array-for-Maximum-Sum-题解"><a href="#LeetCode-1043-Partition-Array-for-Maximum-Sum-题解" class="headerlink" title="LeetCode(\1043. Partition Array for Maximum Sum)题解"></a>LeetCode(\1043. Partition Array for Maximum Sum)题解</h1><p>Given an integer array <code>A</code>, you partition the array into (contiguous) subarrays of length at most <code>K</code>. After partitioning, each subarray has their values changed to become the maximum value of that subarray.</p>
<p>Return the largest sum of the given array after partitioning.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [1,15,7,9,2,5,10], K &#x3D; 3</span><br><span class="line">Output: 84</span><br><span class="line">Explanation: A becomes [15,15,15,9,10,10,10]</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= K &lt;= A.length &lt;= 500</code></li>
<li><code>0 &lt;= A[i] &lt;= 10^6</code></li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个数组A和整数K，将A分为长度不超过K的若干个子数组，将每个子数组内的元素变为其中最大的元素值，然后求所有的子数组元素之和，问最终能得到的最大和为多少。</p>
<p>这个题可以使用DP解决，设定一个与A等长的数组dp，其中dp[i]表示A中0~i位置能得到的最大和，最终题目的答案就是dp[A.size()-1]。</p>
<p>状态转移方程是什么呢，因为子数组长度最多为K长度，因此我们考虑最后一个子数组的长度即可。即：</p>
<p>dp[i] = max(dp[i-j] + max(A[i-j+1], A[i-j+2], …, A[i])),    j = 1,2, …, K.</p>
<p>代码如下，时间复杂度O(nk), 空间复杂度O(n).</p>
<p><code>Runtime: 16 ms, faster than 72.94% of C++ online submissions for Partition Array for Maximum Sum.</code></p>
<p><code>Memory Usage: 8.7 MB, less than 100.00% of C++ online submissions for Partition Array for Maximum Sum.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//dp[0] = A[0];</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = A[i];</span><br><span class="line">            dp[i+<span class="number">1</span>] = dp[i] + m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;=<span class="number">0</span> <span class="keyword">and</span> j&gt;i-K; j--) &#123;</span><br><span class="line">                m = <span class="built_in">max</span>(m, A[j]);</span><br><span class="line">                dp[i+<span class="number">1</span>] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>], dp[j] + m * (i-j+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2020-01-05</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(106.%20Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(106.%20Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(106. Construct Binary Tree from Inorder and Postorder Traversal)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-题解"><a href="#LeetCode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-题解" class="headerlink" title="LeetCode(106. Construct Binary Tree from Inorder and Postorder Traversal)题解"></a>LeetCode(106. Construct Binary Tree from Inorder and Postorder Traversal)题解</h1><hr>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<pre><code>inorder = [9,3,15,20,7]
postorder = [9,15,7,20,3]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给出一个树的中序和后序遍历，恢复这个树的结构，树中元素是不重复的。</p>
<p>对于二叉树来说，后序和中序遍历可以唯一地确定一个树的结构，如果元素没有重复的话。方法如下，首先看后序最后一个一定是根节点，然后在中序遍历里查看这个根节点的位置。位置左边的元素一定是中序遍历下的左子树，位置右边的元素一定是中序遍历下的右子树。那么确定根节点之后及左右子树后，在后序遍历中从开始节点之后取中序遍历左子树序列长度的序列，一定是后序遍历下的左子树。这样就又得到了一个左子树的前序和中序遍历。问题缩小了。同样，右子树一样可以得到。</p>
<p>因此问题规模可以一直缩小，直到为空。当判断为空时，直接返回NULL。</p>
<p>代码如下：</p>
<p>Runtime: 24 ms, faster than 55.53% of C++ online submissions for Construct Binary Tree from Inorder and Postorder Traversal.<br>Memory Usage: 16.7 MB, less than 74.96% of C++ online submissions for Construct Binary Tree from Inorder and Postorder Traversal.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> psta, <span class="keyword">int</span> pend, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> ista, <span class="keyword">int</span> iend)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(psta&gt;pend) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(postorder[pend]);</span><br><span class="line">        <span class="keyword">int</span> pmid, imid = ista;</span><br><span class="line">        <span class="keyword">while</span>(inorder[imid] != postorder[pend]) imid++;</span><br><span class="line">        pmid = imid - ista + psta - <span class="number">1</span>;</span><br><span class="line">        root-&gt;left = build(postorder, psta, pmid, inorder, ista, imid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = build(postorder, pmid+<span class="number">1</span>, pend<span class="number">-1</span>, inorder, imid+<span class="number">1</span>, iend);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> plen = postorder.<span class="built_in">size</span>(), ilen = inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> build(postorder, <span class="number">0</span>, plen<span class="number">-1</span>, inorder, <span class="number">0</span>, ilen<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-06-28</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(105.%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(105.%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(105. Construct Binary Tree from Preorder and Inorder Traversal)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-题解"><a href="#LeetCode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-题解" class="headerlink" title="LeetCode(105. Construct Binary Tree from Preorder and Inorder Traversal)题解"></a>LeetCode(105. Construct Binary Tree from Preorder and Inorder Traversal)题解</h1><hr>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<pre><code>preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给出一个树的前序和中序遍历，恢复这个树的结构，树中元素是不重复的。</p>
<p>对于二叉树来说，前序和中序遍历可以唯一地确定一个树的结构，如果元素没有重复的话。方法如下，首先看前序第一个一定根节点，然后在中序遍历里查看这个根节点的位置。位置左边的元素一定是中序遍历下的左子树，位置右边的元素一定是中序遍历下的右子树。那么确定根节点之后及左右子树后，在前序遍历中从根节点之后取中序遍历左子树序列长度的序列，一定是前序遍历下的左子树。这样就又得到了一个左子树的前序和中序遍历。问题缩小了。同样，右子树一样可以得到。</p>
<p>因此问题规模可以一直缩小，直到为空。当判断为空时，直接返回NULL。</p>
<p>代码如下：</p>
<p>Runtime: 16 ms, faster than 89.76% of C++ online submissions for Construct Binary Tree from Preorder and Inorder Traversal.<br>Memory Usage: 16.5 MB, less than 82.31% of C++ online submissions for Construct Binary Tree from Preorder and Inorder Traversal.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> psta, <span class="keyword">int</span> pend, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> ista, <span class="keyword">int</span> iend)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(psta&gt;pend) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(preorder[psta]);</span><br><span class="line">        <span class="keyword">int</span> pmid = psta, imid = ista;</span><br><span class="line">        <span class="keyword">while</span>(inorder[imid] != preorder[psta]) imid++;</span><br><span class="line">        pmid = imid - ista + psta;</span><br><span class="line">        root-&gt;left = build(preorder, psta+<span class="number">1</span>, pmid, inorder, ista, imid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = build(preorder, pmid+<span class="number">1</span>, pend, inorder, imid+<span class="number">1</span>, iend);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> plen = preorder.<span class="built_in">size</span>(), ilen = inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, plen<span class="number">-1</span>, inorder, <span class="number">0</span>, ilen<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-06-28</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(109.%20Convert%20Sorted%20List%20to%20Binary%20Search%20Tree)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(109.%20Convert%20Sorted%20List%20to%20Binary%20Search%20Tree)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(109. Convert Sorted List to Binary Search Tree)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-109-Convert-Sorted-List-to-Binary-Search-Tree-题解"><a href="#LeetCode-109-Convert-Sorted-List-to-Binary-Search-Tree-题解" class="headerlink" title="LeetCode(109. Convert Sorted List to Binary Search Tree)题解"></a>LeetCode(109. Convert Sorted List to Binary Search Tree)题解</h1><hr>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<p>Example:</p>
<pre><code>Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

     0
    / \
  -3   9
  /   /
-10  5</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个单调递增的链表序列，将其转变为BST。</p>
<p>一个简单的方法，可以将链表内的Val都拿出来形成一个数组，然后直接每次对半分开建立BST即可，这样空间复杂度O(n)，时间复杂度O(n)。不过为了省内存，可以直接在链表上操作，空间复杂度O(1)，但是时间复杂度会变成O(n2)。这里我选择第一种。</p>
<p>代码如下：</p>
<p>Runtime: 712 ms, faster than 5.11% of C++ online submissions for Convert Sorted List to Binary Search Tree.<br>Memory Usage: 354.1 MB, less than 5.03% of C++ online submissions for Convert Sorted List to Binary Search Tree.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; H, <span class="keyword">int</span> sta, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sta&gt;<span class="built_in">end</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (sta + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(H[mid]);</span><br><span class="line">        root-&gt;left = buildBST(H, sta, mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = buildBST(H, mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; H;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            H.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildBST(H, <span class="number">0</span>, H.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-06-29</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(113.%20Path%20Sum%20II)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(113.%20Path%20Sum%20II)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(113. Path Sum II)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-113-Path-Sum-II-题解"><a href="#LeetCode-113-Path-Sum-II-题解" class="headerlink" title="LeetCode(113. Path Sum II)题解"></a>LeetCode(113. Path Sum II)题解</h1><hr>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<pre><code>Given the below binary tree and sum = 22,

       5
      / \
     4   8
    /   / \
   11  13  4
  /  \    / \
 7    2  5   1</code></pre><p>Return:</p>
<pre><code>[
    [5,4,11,2],
    [5,8,4,5]
]</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个二叉树，和一个值，从二叉树中找出所有从根节点出发向下走到叶子节点的路径，其节点之和为给定的值。</p>
<p>可以使用递归的方法，使用vector记录一个路径，走到当前节点，看是否当前节点加上之前的和为给定的值。如果等于则存储，如果大于就放弃这条路，如果小于则加入，再继续向下走。</p>
<p>代码如下：</p>
<p>Runtime: 24 ms, faster than 39.82% of C++ online submissions for Path Sum II.<br>Memory Usage: 38.2 MB, less than 12.98% of C++ online submissions for Path Sum II.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pathSum_</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp, <span class="keyword">int</span> lsum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        lsum += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(lsum == sum &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pathSum_(root-&gt;left, sum, tmp, lsum);</span><br><span class="line">        pathSum_(root-&gt;right, sum, tmp, lsum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> lsum = <span class="number">0</span>;</span><br><span class="line">        pathSum_(root, sum, tmp, lsum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-06-30</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(11.%20Container%20With%20Most%20Water)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(11.%20Container%20With%20Most%20Water)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(11. Container With Most Water)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-11-Container-With-Most-Water-题解"><a href="#LeetCode-11-Container-With-Most-Water-题解" class="headerlink" title="LeetCode(11. Container With Most Water)题解"></a>LeetCode(11. Container With Most Water)题解</h1><hr>
<p>原文如下：</p>
<p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note:</strong> You may not slant the container and n is at least 2.</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49."></p>
<p>Example:</p>
<pre><code>Input: [1,8,6,2,5,4,8,3,7]
Output: 49</code></pre><h2 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h2><p>题目是LeetCode内一个Medium难度的题目，并不难。要求从给定的条件中找出最大容量的容器组成。如果抽离出现实，就是要求给定一个数组A = [a1, a2, …, an]，寻找一个M = max abs(i-j)* min(ai, aj) (i,j = 1,2, …, n)。</p>
<h2 id="思路一O-n2-："><a href="#思路一O-n2-：" class="headerlink" title="思路一O(n2)："></a>思路一O(n2)：</h2><p>题目并未给定时间复杂度的要求，一个最简单的思路就是遍历，比较任意两个数之间的大小，时间复杂度O(n2)。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">0</span>, len = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt;len; j++)&#123;</span><br><span class="line">                M = M&gt;(j-i)*<span class="built_in">min</span>(<span class="built_in">height</span>[i], <span class="built_in">height</span>[j])? M:(j-i)*<span class="built_in">min</span>(<span class="built_in">height</span>[i], <span class="built_in">height</span>[j]);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="思路二O-nlogn-："><a href="#思路二O-nlogn-：" class="headerlink" title="思路二O(nlogn)："></a>思路二O(nlogn)：</h2><p>一个可以提速的办法是，基于这样的一个事实：ai与aj(i&lt;\j)组成的值为abs(i-j)<em>min(ai,aj)，而在i与j之中的任何低于min(ai,aj)的ak肯定不会在是整个数组中作为最大容量时的选择，因为假如最大的容量组成为M = abs(p-k)</em>min(ak, ap)，基于i&lt;\k&lt;\j, ak&lt;=min(ai, aj)那么有如下几种情况。</p>
<pre><code>p&lt;i&lt;j: M &lt;= abs(p-j)*min(aj, ap)。
i&lt;j&lt;p: M &lt;= abs(p-i)*min(ai, ap)。
i&lt;=p&lt;=j: M &lt;= min(abs(i-p)*min(ai, ap), abs(p-j)*min(aj, ap))。</code></pre><p>因此，我们可以记录数组内元素和初始位置的关系，然后将数组降序排序，得到新的数组B = [b1, b2, …, bn]，依次遍历。<br>    初始化left=min(b1的初始位置p1, b2的初始位置p2)，right= max(b1的初始位置p1, b2的初始位置p2)，M = abs(p1-p2)<em>b2。<br>    依次向下遍历，在位置pi。<br>    如果left&lt;pi&lt;right: M = M，跳过。<br>    如果pi&lt;left&lt;right: M = max(M, (right-pi)</em>B[i])，更新 left = pi<br>    如果left&lt;right&lt;pi: M = max(M, (pi-left)*B[i])，更新 right = pi</p>
<p>这里要注意，只要pi在当前[left, right]区间之外，都要进行更新（important），不管M是否需要更新，因为B降序排序，A[pi]总是剩下的最大的，因此其间的都应该不考虑。</p>
<p>注意B[i] = A[pi], 所以C++代码实现时，可以利用数组B只存储位置，按照A内的元素大小排序位置。不过我这里是使用Vector建立了一个二维数组，大小A.size()*2，内部存储位置与元素值。自定义比较函数。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">height</span>.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">B</span><span class="params">(<span class="built_in">height</span>.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">height</span>.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            B[i][<span class="number">0</span>] = i;</span><br><span class="line">            B[i][<span class="number">1</span>] = <span class="built_in">height</span>[i];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// O(nlogn)</span></span><br><span class="line">        sort(B.<span class="built_in">begin</span>(), B.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">min</span>(B[<span class="number">0</span>][<span class="number">0</span>], B[<span class="number">1</span>][<span class="number">0</span>]), right = <span class="built_in">max</span>(B[<span class="number">0</span>][<span class="number">0</span>], B[<span class="number">1</span>][<span class="number">0</span>]), M;</span><br><span class="line">        M = (right - left) * <span class="built_in">min</span>(B[<span class="number">0</span>][<span class="number">1</span>], B[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;B.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pi = B[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(left &lt; pi &amp;&amp; pi &lt; right) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pi &lt; left)&#123;</span><br><span class="line">                M = <span class="built_in">max</span>(M, (right - pi) * B[i][<span class="number">1</span>]);</span><br><span class="line">                left = pi;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                M = <span class="built_in">max</span>(M, (pi - left) * B[i][<span class="number">1</span>]);</span><br><span class="line">                right = pi;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> M;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，代码美观一点的话，也可以这样写。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">height</span>.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">B</span><span class="params">(<span class="built_in">height</span>.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">height</span>.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            B[i][<span class="number">0</span>] = i;</span><br><span class="line">            B[i][<span class="number">1</span>] = <span class="built_in">height</span>[i];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// O(nlogn)</span></span><br><span class="line">        sort(B.<span class="built_in">begin</span>(), B.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">min</span>(B[<span class="number">0</span>][<span class="number">0</span>], B[<span class="number">1</span>][<span class="number">0</span>]), right = <span class="built_in">max</span>(B[<span class="number">0</span>][<span class="number">0</span>], B[<span class="number">1</span>][<span class="number">0</span>]), M;</span><br><span class="line">        M = (right - left) * <span class="built_in">min</span>(B[<span class="number">0</span>][<span class="number">1</span>], B[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;B.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pi = B[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(left &lt; pi &amp;&amp; pi &lt; right) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            M = (pi &lt; left)? <span class="built_in">max</span>(M, (right - pi) * B[i][<span class="number">1</span>]) : <span class="built_in">max</span>(M, (pi - left) * B[i][<span class="number">1</span>]);</span><br><span class="line">            left = <span class="built_in">min</span>(left, pi);</span><br><span class="line">            right = <span class="built_in">max</span>(right, pi);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> M;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>PS: 版权所有，翻版必究（所有的解法完全都是自己想出来的，很开心）。</strong><br>BitBrave, 2019-04-16</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(1094.%20Car%20Pooling)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(1094.%20Car%20Pooling)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(1094. Car Pooling)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-1094-Car-Pooling-题解"><a href="#LeetCode-1094-Car-Pooling-题解" class="headerlink" title="LeetCode(\1094. Car Pooling)题解"></a>LeetCode(\1094. Car Pooling)题解</h1><p>You are driving a vehicle that has <code>capacity</code> empty seats initially available for passengers. The vehicle <strong>only</strong> drives east (ie. it <strong>cannot</strong> turn around and drive west.)</p>
<p>Given a list of <code>trips</code>, <code>trip[i] = [num_passengers, start_location, end_location]</code> contains information about the <code>i</code>-th trip: the number of passengers that must be picked up, and the locations to pick them up and drop them off. The locations are given as the number of kilometers due east from your vehicle’s initial location.</p>
<p>Return <code>true</code> if and only if it is possible to pick up and drop off all passengers for all the given trips. </p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips &#x3D; [[2,1,5],[3,3,7]], capacity &#x3D; 4</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips &#x3D; [[2,1,5],[3,3,7]], capacity &#x3D; 5</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips &#x3D; [[2,1,5],[3,5,7]], capacity &#x3D; 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips &#x3D; [[3,2,7],[3,7,9],[8,3,9]], capacity &#x3D; 11</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>





<p><strong>Constraints:</strong></p>
<ol>
<li><code>trips.length &lt;= 1000</code></li>
<li><code>trips[i].length == 3</code></li>
<li><code>1 &lt;= trips[i][0] &lt;= 100</code></li>
<li><code>0 &lt;= trips[i][1] &lt; trips[i][2] &lt;= 1000</code></li>
<li><code>1 &lt;= capacity &lt;= 100000</code></li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>有一个车站序列，一辆固定容量的汽车每站停下来下乘客和上乘客。问给定一个乘客的上下站位置和数目的数组，判断这个汽车是否可以成功载人到终点。</p>
<p>这个题有点类似于教室安排的情况，用最少的教室来排出所有的课，这个题转化过来就是满足开课的最小教室数和给定的教室数之间的比较。</p>
<p>因此我们可以使用Greedy办法做，设定一个与车站数等长的数组，数组i位置记录车站i-1到i之间的乘客数目。因此我们需要做的就是用乘客组来填充这个数组。最后遍历数组，如果有数大于车的载重返回False，否则返回True。</p>
<p>代码如下，时间复杂度O(乘客组数*车站数)，空间复杂度O(车站数)。</p>
<p><code>Runtime: 20 ms, faster than 16.98% of C++ online submissions for Car Pooling.</code></p>
<p><code>Memory Usage: 10.4 MB, less than 100.00% of C++ online submissions for Car Pooling.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="number">1001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; trip : trips) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=trip[<span class="number">1</span>]; i&lt;trip[<span class="number">2</span>]; i++) &#123;</span><br><span class="line">                ret[i] += trip[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (ret[i] &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int r : ret) &#123;</span></span><br><span class="line">        <span class="comment">//     if (r &gt; capacity) return false;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2019-12-19</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(1139.%20Largest%201-Bordered%20Square)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(1139.%20Largest%201-Bordered%20Square)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(1139. Largest 1-Bordered Square)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-1139-Largest-1-Bordered-Square-题解"><a href="#LeetCode-1139-Largest-1-Bordered-Square-题解" class="headerlink" title="LeetCode(\1139. Largest 1-Bordered Square)题解"></a>LeetCode(\1139. Largest 1-Bordered Square)题解</h1><p>Given a 2D <code>grid</code> of <code>0</code>s and <code>1</code>s, return the number of elements in the largest <strong>square</strong> subgrid that has all <code>1</code>s on its <strong>border</strong>, or <code>0</code> if such a subgrid doesn’t exist in the <code>grid</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,1,0,0]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= grid.length &lt;= 100</code></li>
<li><code>1 &lt;= grid[0].length &lt;= 100</code></li>
<li><code>grid[i][j]</code> is <code>0</code> or <code>1</code></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个由0和1组成的数组，找出其中由1圈成的最大的正方形的面积。</p>
<p>这个题可以使用DP完成，从上到下，从左到右对每一个元素，我们分别计算以这个元素为正方形右下角时的最大正方形面积。分别找出元素对应的向上的列和向左的行的连续1组成的元素，然后计算对应边长的合法正方形面积。</p>
<p>这个题的DP思想体现在哪里呢？按照上述办法计算时，我们需要计算指定元素为右下角时的最大正方形，这需要O(N2)时间，全部计算一遍就需要O(N4)，但是我们分别维护两个等大的DP数组，记录元素对应向上数的连续1的个数，元素对应向左数的行的连续1的个数。而这是DP可以计算的，总共花费O(n2)时间，最后计算上述答案时只需要O(n3)时间。</p>
<p>代码如下，时间复杂度O(n3)，空间复杂度O(n2)。</p>
<p><code>Runtime: 16 ms, faster than 73.07% of C++ online submissions for Largest 1-Bordered Square.</code></p>
<p><code>Memory Usage: 10.8 MB, less than 100.00% of C++ online submissions for Largest 1-Bordered Square.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largest1_</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; Row, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; Col, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">min</span>(Row[r][c], Col[r][c]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">min</span>(Col[r][c-i], Row[r-i][c]) &gt; i) ret = <span class="built_in">max</span>(ret, (i+<span class="number">1</span>) * (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largest1BorderedSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rlen = grid.<span class="built_in">size</span>(), clen = grid[<span class="number">0</span>].<span class="built_in">size</span>(), ret = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; Row(rlen+1, vector&lt;int&gt;(clen+1,0)), Col(rlen+1, vector&lt;int&gt;(clen+1,0));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;rlen; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;clen; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c]==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Row[r+<span class="number">1</span>][c+<span class="number">1</span>] = Row[r+<span class="number">1</span>][c] + <span class="number">1</span>;</span><br><span class="line">                Col[r+<span class="number">1</span>][c+<span class="number">1</span>] = Col[r][c+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                ret = <span class="built_in">max</span>(ret, largest1_(Row, Col, r+<span class="number">1</span>, c+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>BitBrave，2019-12-18</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XJ"
      src="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
  <p class="site-author-name" itemprop="name">XJ</p>
  <div class="site-description" itemprop="description">幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">276</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BitBrave, IIE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
