<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:type" content="website">
<meta property="og:title" content="BitBrave">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="BitBrave">
<meta property="og:description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XJ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>BitBrave</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BitBrave</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">IIE</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/27/LeetCode(765.%20Couples%20Holding%20Hands)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/27/LeetCode(765.%20Couples%20Holding%20Hands)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(765. Couples Holding Hands)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-27 11:03:46 / 修改时间：11:04:01" itemprop="dateCreated datePublished" datetime="2020-03-27T11:03:46+08:00">2020-03-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-765-Couples-Holding-Hands-题解"><a href="#LeetCode-765-Couples-Holding-Hands-题解" class="headerlink" title="LeetCode(\765. Couples Holding Hands)题解"></a>LeetCode(\765. Couples Holding Hands)题解</h1><p>N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A <em>swap</em> consists of choosing <strong>any</strong> two people, then they stand up and switch seats.</p>
<p>The people and seats are represented by an integer from <code>0</code> to <code>2N-1</code>, the couples are numbered in order, the first couple being <code>(0, 1)</code>, the second couple being <code>(2, 3)</code>, and so on with the last couple being <code>(2N-2, 2N-1)</code>.</p>
<p>The couples’ initial seating is given by <code>row[i]</code> being the value of the person who is initially sitting in the i-th seat.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: row &#x3D; [0, 2, 1, 3]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We only need to swap the second (row[1]) and third (row[2]) person.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: row &#x3D; [3, 2, 0, 1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: All couples are already seated side by side.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>len(row)</code> is even and in the range of <code>[4, 60]</code>.</li>
<li><code>row</code> is guaranteed to be a permutation of <code>0...len(row)-1</code>.</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>有N对人，编号0，1，2，···，2N-1。他们两两一对，0和1一对，2和3一对，···，2N-2和2N-1一对。现在数组中这些数是打乱的，每次可以交换两个人的位置，使用最少的交换次数使得这个数组内，每一对都是挨着的。返回交换的最小次数。</p>
<p>这个题使用Greedy。使用Map记录下每个数原本在的位置。然后从左到右每两个元素遍历。如果这两个元素是一对，那就不必交换了，直接跳过，如果不是一对，那么其中肯定有一个需要与另一个的另一半交换。直接交换即可，然后更新Map。然后继续向下走，因为从左到右逐渐配对，所以未配对的和缺少的都肯定在右边。</p>
<p>我在算法中每次遇到不成对的元素，都选择将右边的与左边的另一半交换，这样好写代码一点。</p>
<p>如何证明这是最优的呢？如果这样的交换方式不是最优的，那就是说在某一步，遇到一个不成对的元素对之后，如果按照上述的方式交换，会导致多出来比较次数。那什么会导致多出来比较次数呢。有以下原因：</p>
<ol>
<li>我们这次交换导致了原本成对的元素拆开了</li>
<li>这次交换没有使得元素成对，是无意义的交换</li>
<li>这次交换成了一对，而如果按最优方案来说是成2对</li>
</ol>
<p>逐步分析上述原因，1，我们是遇到不匹配的元素才交换，而当前这一对不匹配，可知这一对中的各自另一半在其他位置肯定也不匹配，因为每个元素的另一半只有1个。2，我们每次交换是成了至少1对的，所以2也不成立。3，最优方案如果是成2对，说明我们当前元素的另一半各自挨着，那么我们交换的时候同样也会成2对，因此3不成立。</p>
<p>注意，最优方案不止一种，最少交换次数则是固定的。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上，O(N)，空间上，O(N)。</p>
<p><code>Runtime: 4 ms, faster than 39.96% of C++ online submissions for Couples Holding Hands.</code></p>
<p><code>Memory Usage: 6.4 MB, less than 100.00% of C++ online submissions for Couples Holding Hands.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = row.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            M[row[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(row[i]-row[i+<span class="number">1</span>]) == <span class="number">1</span> <span class="keyword">and</span> (<span class="built_in">min</span>(row[i],row[i+<span class="number">1</span>]) &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span> ((row[i]&amp;<span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = row[i+<span class="number">1</span>];</span><br><span class="line">                row[i+<span class="number">1</span>] = row[i] + <span class="number">1</span>;</span><br><span class="line">                row[M[row[i]+<span class="number">1</span>]] = tmp;</span><br><span class="line">                M[tmp] = M[row[i]+<span class="number">1</span>];</span><br><span class="line">                M[row[i]+<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = row[i+<span class="number">1</span>];</span><br><span class="line">                row[i+<span class="number">1</span>] = row[i] - <span class="number">1</span>;</span><br><span class="line">                row[M[row[i]<span class="number">-1</span>]] = tmp;</span><br><span class="line">                M[tmp] = M[row[i]<span class="number">-1</span>];</span><br><span class="line">                M[row[i]<span class="number">-1</span>] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-27</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/LeetCode(936.%20Stamping%20The%20Sequence)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/LeetCode(936.%20Stamping%20The%20Sequence)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(936. Stamping The Sequence)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-26 23:21:40" itemprop="dateCreated datePublished" datetime="2020-03-26T23:21:40+08:00">2020-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-27 11:09:03" itemprop="dateModified" datetime="2020-03-27T11:09:03+08:00">2020-03-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-936-Stamping-The-Sequence-题解"><a href="#LeetCode-936-Stamping-The-Sequence-题解" class="headerlink" title="LeetCode(\936. Stamping The Sequence)题解"></a>LeetCode(\936. Stamping The Sequence)题解</h1><p>You want to form a <code>target</code> string of <strong>lowercase letters</strong>.</p>
<p>At the beginning, your sequence is <code>target.length</code> <code>&#39;?&#39;</code> marks. You also have a <code>stamp</code> of lowercase letters.</p>
<p>On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp. You can make up to <code>10 * target.length</code> turns.</p>
<p>For example, if the initial sequence is “?????”, and your stamp is <code>&quot;abc&quot;</code>, then you may make “abc??”, “?abc?”, “??abc” in the first turn. (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.)</p>
<p>If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn. If the sequence is not possible to stamp, return an empty array.</p>
<p>For example, if the sequence is “ababc”, and the stamp is <code>&quot;abc&quot;</code>, then we could return the answer <code>[0, 2]</code>, corresponding to the moves “?????” -&gt; “abc??” -&gt; “ababc”.</p>
<p>Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within <code>10 * target.length</code> moves. Any answers specifying more than this number of moves will not be accepted.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: stamp &#x3D; &quot;abc&quot;, target &#x3D; &quot;ababc&quot;</span><br><span class="line">Output: [0,2]</span><br><span class="line">([1,0,2] would also be accepted as an answer, as well as some other answers.)</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: stamp &#x3D; &quot;abca&quot;, target &#x3D; &quot;aabcaca&quot;</span><br><span class="line">Output: [3,0,1]</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= stamp.length &lt;= target.length &lt;= 1000</code></li>
<li><code>stamp</code> and <code>target</code> only contain lowercase letters.</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>一个目标字符串，使用另一个字符串通过左右移动去拼凑，移动后的字符如果和之间的有重叠，则覆盖掉之前的，比如abc，左移1位组成abcbc，掩盖了之前的a，在目标字符串内，按顺序写出每一次移动后停留的位置最终在目标字符串中的位置。如果不存在就返回[]。限制移动次数为10*目标字符串长度。</p>
<p>本题可以使用贪心，也可以说是暴力了。其实每个目标字符中，每个字符最多有一个移动的对应，因为如果多个的话，最后移动的会覆盖掉前面的，所以10倍是绰绰有余的。</p>
<p>使用count记录目标字符串中已经匹配的字符数，如果已经达到目标字符串就结束，没有就从左到右寻找一个符合另一个字符串的匹配字符串，从i=0到目标字符串长度-匹配字符串长度之间遍历。如果没找到，说明无解。如果找到了，找出其中不是”?”的字符即还未被匹配的字符，将其全部设为”?”。最后将这个i设为True，即已经移动到了。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上，目标字符串长度N，匹配字符串长度K，那么每次最少匹配一个，最多有N轮，每一轮需要将目标字符串全部遍历(N-K)次，一次花费K次比较，K小于等于N。因此最终的时间复杂度$O(N^3)$，空间复杂度$O(N)$。</p>
<p><code>Runtime: 84 ms, faster than 24.69% of C++ online submissions for Stamping The Sequence.</code></p>
<p><code>Memory Usage: 110.5 MB, less than 7.69% of C++ online submissions for Stamping The Sequence.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isStamp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> K, <span class="built_in">string</span> sta, <span class="built_in">string</span> tar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;K; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sta[k] != tar[i+k] <span class="keyword">and</span> tar[i+k] != <span class="string">'?'</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tar[i+k] != <span class="string">'?'</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">movesToStamp</span><span class="params">(<span class="built_in">string</span> stamp, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = target.<span class="built_in">size</span>(), K = stamp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visit</span><span class="params">(len, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">bool</span> change = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; len) &#123;</span><br><span class="line">            change = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=len-K; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visit[i] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> tmp = isStamp(i, K, stamp, target);</span><br><span class="line">                <span class="keyword">if</span> (tmp &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    change = <span class="literal">true</span>;</span><br><span class="line">                    count += tmp;</span><br><span class="line">                    visit[i] = <span class="literal">true</span>;</span><br><span class="line">                    res.insert(res.<span class="built_in">begin</span>(), i);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;K; k++) target[i+k] = <span class="string">'?'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (change == <span class="literal">false</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2020-03-27</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/LeetCode(995.%20Minimum%20Number%20of%20K%20Consecutive%20Bit%20Flips)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/LeetCode(995.%20Minimum%20Number%20of%20K%20Consecutive%20Bit%20Flips)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(995. Minimum Number of K Consecutive Bit Flips)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-26 18:09:57 / 修改时间：18:11:16" itemprop="dateCreated datePublished" datetime="2020-03-26T18:09:57+08:00">2020-03-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-995-Minimum-Number-of-K-Consecutive-Bit-Flips-题解"><a href="#LeetCode-995-Minimum-Number-of-K-Consecutive-Bit-Flips-题解" class="headerlink" title="LeetCode(\995. Minimum Number of K Consecutive Bit Flips)题解"></a>LeetCode(\995. Minimum Number of K Consecutive Bit Flips)题解</h1><p>In an array <code>A</code> containing only 0s and 1s, a <em><code>K</code>-bit flip</em> consists of choosing a (contiguous) subarray of length <code>K</code> and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.</p>
<p>Return the minimum number of <code>K</code>-bit flips required so that there is no 0 in the array. If it is not possible, return <code>-1</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [0,1,0], K &#x3D; 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Flip A[0], then flip A[2].</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [1,1,0], K &#x3D; 2</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: No matter how we flip subarrays of size 2, we can&#39;t make the array become [1,1,1].</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [0,0,0,1,0,1,1,0], K &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]</span><br><span class="line">Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]</span><br><span class="line">Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>1 &lt;= K &lt;= A.length</code></li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>将一个由0和1组成的数组的连续k个元素进行翻转，0变为1，1变为0，求最少的翻转次数将数组的元素全部变为1。如果不能变为1，就返回-1。</p>
<p>本题可以使用Greedy的办法，我们假设一个数组有解，并且存在一个最优方案，每一个都将一部分连续数组进行翻转，那么这些翻转是没有顺序的，不管什么顺序都能得到最终解。同时翻转的时候，最左边的翻转位置一定是0，因为不是的话，肯定还有更左边的才能将其翻为1。因此我们可以从左到右维持一个长度为K的窗口，依次划过去，如果出窗口的元素为0，就将窗口内的元素翻转，次数+1，否则就略过。走到最后，如果窗口内还有0存在，就表示不能得到答案，无解。否则就返回次数即可。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间复杂度O(N)，空间复杂度O(N)。</p>
<p><code>Runtime: 108 ms, faster than 27.75% of C++ online submissions for Minimum Number of K Consecutive Bit Flips.</code></p>
<p><code>Memory Usage: 17.7 MB, less than 100.00% of C++ online submissions for Minimum Number of K Consecutive Bit Flips.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, len = A.<span class="built_in">size</span>(), flip = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;K; i++) Q.push(A[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=K; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flip ^ Q.front() == <span class="number">0</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                flip = <span class="number">1</span> - flip;</span><br><span class="line">            &#125;</span><br><span class="line">            Q.pop();</span><br><span class="line">            Q.push(flip ^ A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flip ^ Q.front() == <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            flip = <span class="number">1</span> - flip;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty() <span class="keyword">and</span> flip ^ Q.front() == <span class="number">1</span>) Q.pop();</span><br><span class="line">        <span class="keyword">if</span> (!Q.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Bitbrave，2020-03-25.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/LeetCode(1392.%20Longest%20Happy%20Prefix)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/LeetCode(1392.%20Longest%20Happy%20Prefix)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(1392. Longest Happy Prefix)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-26 16:42:18 / 修改时间：16:42:19" itemprop="dateCreated datePublished" datetime="2020-03-26T16:42:18+08:00">2020-03-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-1392-Longest-Happy-Prefix-题解"><a href="#LeetCode-1392-Longest-Happy-Prefix-题解" class="headerlink" title="LeetCode(\1392. Longest Happy Prefix)题解"></a>LeetCode(\1392. Longest Happy Prefix)题解</h1><p>A string is called a <em>happy prefix</em> if is a <strong>non-empty</strong> prefix which is also a suffix (excluding itself).</p>
<p>Given a string <code>s</code>. Return the <strong>longest happy prefix</strong> of <code>s</code> .</p>
<p>Return an empty string if no such prefix exists.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;level&quot;</span><br><span class="line">Output: &quot;l&quot;</span><br><span class="line">Explanation: s contains 4 prefix excluding itself (&quot;l&quot;, &quot;le&quot;, &quot;lev&quot;, &quot;leve&quot;), and suffix (&quot;l&quot;, &quot;el&quot;, &quot;vel&quot;, &quot;evel&quot;). The largest prefix which is also suffix is given by &quot;l&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ababab&quot;</span><br><span class="line">Output: &quot;abab&quot;</span><br><span class="line">Explanation: &quot;abab&quot; is the largest prefix which is also suffix. They can overlap in the original string.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcodeleet&quot;</span><br><span class="line">Output: &quot;leet&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>s</code> contains only lowercase English letters.</li>
</ul>
<p><a href="https://leetcode.com/problems/longest-happy-prefix/discuss" target="_blank" rel="noopener">Discuss</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>求出一个字符串的公共前后缀最长值。</p>
<p>这个乍一看很难在O(n)的时间内解决。但是知道KMP的人来说，这就是求Next数组而已。同时Rolling hash也可以解决，将字符串映射到一个值，将前缀的值依次放入Set 中，然后将后缀依次转为整数，然后在O(1)时间内就可以判断是否存在。</p>
<p>这里我使用Next的方式。</p>
<p>代码如下，时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPrefix</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Next</span><span class="params">(len + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">0</span> || s[j<span class="number">-1</span>] == s[t<span class="number">-1</span>]) &#123;</span><br><span class="line">                Next[j+<span class="number">1</span>] = t + <span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">                t++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t = Next[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(<span class="number">0</span>, Next[len+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-25</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95KMP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95KMP/" class="post-title-link" itemprop="url">字符串匹配算法KMP</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-26 14:45:24 / 修改时间：16:36:44" itemprop="dateCreated datePublished" datetime="2020-03-26T14:45:24+08:00">2020-03-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字符串匹配算法KMP"><a href="#字符串匹配算法KMP" class="headerlink" title="字符串匹配算法KMP"></a>字符串匹配算法KMP</h1><p>存在一个字符串主串S，和一个模式串P。寻找P是否是S的子串，如果是就返回第一次匹配的位置，否则返回-1。</p>
<p>这里统一定义一下：对于S和P中的字符，从前到后，每个字符的编号从1开始，分别为1，2，3，···。比如S[0]为1号字符，所以如果第一次匹配的位置就是开头，就返回1。（在C++中，string类的length与size没有区别）。</p>
<p>###算法思路</p>
<p>KMP是非常经典的字符串匹配算法，可以在$O(N+M)$的时间内得到结果，相比于普通的比较算法$O(MN)$极大地提升了效率，N为S的长度，M为P的长度。</p>
<p>因为我只能说大概理解了KMP算法，但是能够信手拈来给别人讲目前还做不到，所以这里写出来让自己熟悉一下。</p>
<h4 id="普通的比较算法"><a href="#普通的比较算法" class="headerlink" title="普通的比较算法"></a>普通的比较算法</h4><p>一般来说要寻找P在S中的位置，我们都是从S的开头开始依次与P比较，记录下S的开始位置k，然后开以k开始的长度为M的子串是不是和P相等，是就结束算法，不是就k++，继续之前的步骤。这样的算法每一步都需要M次比较，总的时间复杂度$O(MN)$。</p>
<p>算法的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通的匹配算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">naive</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">string</span> pstr)</span> </span>&#123; <span class="comment">// 主串，模式串</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, k = i;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= str.<span class="built_in">size</span>() <span class="keyword">and</span> j &lt;= pstr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i<span class="number">-1</span>] == pstr[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = ++k;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; pstr.<span class="built_in">size</span>()) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><p>普通的匹配算法，在遇到不匹配的时候，主串会回溯到最开始匹配的地方，造成了浪费。比如aba，如果3号上的a与主串的某个地方匹配，那么1号上的a就肯定与这个位置匹配，就不用重复比较。因此KMP算法对模式串构造一个Next数组，存储每个字符前面的子串的公共前后缀长度+1，也就是如果当前字符与主串的不匹配，那么应该与模式串的哪一个位置匹配。Next[1]=0，Next[2]=1。</p>
<p>总的来说，从S和P的1号字符开始匹配，如果相等就各自++，如果遇到不匹配的地方，此时S中为i号字符，P中为j号字符，将j = Next[j]匹配即可，如果j=0，表示P的第一个字符就不匹配，此i++，j++即可。</p>
<p>算法的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">string</span> pstr, <span class="keyword">int</span> next[])</span> </span>&#123; <span class="comment">// 主串，模式串</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= str.<span class="built_in">size</span>() <span class="keyword">and</span> j &lt;= pstr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> <span class="keyword">or</span> str[i<span class="number">-1</span>] == pstr[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; pstr.<span class="built_in">size</span>()) <span class="keyword">return</span> i - pstr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Next数组填充（Most-Important）"><a href="#Next数组填充（Most-Important）" class="headerlink" title="Next数组填充（Most Important）"></a>Next数组填充（Most Important）</h4><p>字符串P存在一个Next整数数组，P[i]对应Next[i]，Next[i]表示字符串P在匹配时，如果i号字符不匹配的时候，应该取哪个字符进行下一步的匹配，就是i字符前面的子串的公共前后缀长度+1。</p>
<p>在填充Next[j+1]的时候，我们假设小于等于j的都已经填充完毕。</p>
<p>那么根据前缀是固定的，后缀是相对的。这里使用类似于DP的方法。</p>
<p>此时Next[j] = t，根据两种情况来分别推导：</p>
<ul>
<li>Pj = Pt，此时直接——Next[j+1] = t + 1;</li>
<li>Pj != Pt，则循环地将t赋值为Next[t]，直到t=0，或者满足Pj=Pt。如果t=0，表示当前子串没有公共前后缀，则直接就是到第一个字符比较，因此Next[j+1] = 1;</li>
</ul>
<p>填充的算法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充Next</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> pstr, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// next[0]空置，可以用于存储模式串的长度</span></span><br><span class="line">    <span class="comment">// next.size() = pstr.size() + 2.</span></span><br><span class="line">    <span class="comment">// next[0]无用，next[i]存储1号到i-1号的子串的公共前后缀长度+1</span></span><br><span class="line">    <span class="comment">// next[pstr.size()+1]存储整个字符串的公共前后缀长度+1</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= pstr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">0</span> <span class="keyword">or</span> pstr[j<span class="number">-1</span>] == pstr[t<span class="number">-1</span>]) &#123;</span><br><span class="line">            next[j+<span class="number">1</span>] = t + <span class="number">1</span>;</span><br><span class="line">            j++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = next[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KMP算法的优化，一个更好的Next数组：Nextval数组填充"><a href="#KMP算法的优化，一个更好的Next数组：Nextval数组填充" class="headerlink" title="KMP算法的优化，一个更好的Next数组：Nextval数组填充"></a>KMP算法的优化，一个更好的Next数组：Nextval数组填充</h4><p>Next数组用于KMP已经很好了，但是还是有优化的空间。考虑这样的一样情况，如果Pj != Pt。那么就令t = Next[t]，如果这时候原有的Pt现在的Pt，其实是不用比较的，直接就再次执行t = Next[t]即可。</p>
<p>这里我们将优化的数组成为Nextval，填充策略如下, t 初始化为0：</p>
<ul>
<li>j = 1时，Nextval[j] = 0，作为特殊标记，表示模式串的第一个字符就不匹配应该怎么办。</li>
<li>j &gt; 1时，（1）若Pj != Pt，则Nextval[j] = t + 1 （2）若Pj = Pt，则Nextval[j] = Nextval[t+1]; </li>
</ul>
<p>因此优化代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充Nextval</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNextval</span><span class="params">(<span class="built_in">string</span> pstr, <span class="keyword">int</span> nextval [])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; pstr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">0</span> <span class="keyword">or</span> pstr[j<span class="number">-1</span>] == pstr[t<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pstr[j] != pstr[t]) nextval[j+<span class="number">1</span>] = t + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> nextval[j+<span class="number">1</span>] = nextval[t+<span class="number">1</span>];</span><br><span class="line">            j++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = nextval[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-26.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/LeetCode(757.%20Set%20Intersection%20Size%20At%20Least%20Two)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/LeetCode(757.%20Set%20Intersection%20Size%20At%20Least%20Two)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(757. Set Intersection Size At Least Two)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 23:56:24" itemprop="dateCreated datePublished" datetime="2020-03-20T23:56:24+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-23 23:42:52" itemprop="dateModified" datetime="2020-03-23T23:42:52+08:00">2020-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-757-Set-Intersection-Size-At-Least-Two-题解"><a href="#LeetCode-757-Set-Intersection-Size-At-Least-Two-题解" class="headerlink" title="LeetCode(\757. Set Intersection Size At Least Two)题解"></a>LeetCode(\757. Set Intersection Size At Least Two)题解</h1><p>An integer interval <code>[a, b]</code> (for integers <code>a &lt; b</code>) is a set of all consecutive integers from <code>a</code> to <code>b</code>, including <code>a</code> and <code>b</code>.</p>
<p>Find the minimum size of a set S such that for every integer interval A in <code>intervals</code>, the intersection of S with A has size at least 2.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1, 3], [1, 4], [2, 5], [3, 5]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Consider the set S &#x3D; &#123;2, 3, 4&#125;.  For each interval, there are at least 2 elements from S in the interval.</span><br><span class="line">Also, there isn&#39;t a smaller size set that fulfills the above condition.</span><br><span class="line">Thus, we output the size of this set, which is 3.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1, 2], [2, 3], [2, 4], [4, 5]]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">An example of a minimum sized set is &#123;1, 2, 3, 4, 5&#125;.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>intervals</code> will have length in range <code>[1, 3000]</code>.</li>
<li><code>intervals[i]</code> will have length <code>2</code>, representing some integer interval.</li>
<li><code>intervals[i][j]</code> will be an integer in <code>[0, 10^8]</code>.</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>给出一系列区间，区间的表示使用[a,b]，表示a~b之间包括ab的所有值，现在寻找一个最小的集合，保证对于每个给定的区间，集合S内至少有两个元素在这个区间内，请问这个最小集合的长度是多少。</p>
<p>本题使用Greedy。有两种方法，不过都是一样的思路，都是对于一个区间，集合S与之相交的两个值尽可能也与其他相交。</p>
<h2 id="第一种，按照右区间排序（相同右区间的左区间更大在前！）"><a href="#第一种，按照右区间排序（相同右区间的左区间更大在前！）" class="headerlink" title="第一种，按照右区间排序（相同右区间的左区间更大在前！）"></a>第一种，按照右区间排序（相同右区间的左区间更大在前！）</h2><p>将所有的区间按照右边界升序排序，然后从第一个区间x开始，可知区间x与S至少有两个元素相交，如何选取这两个元素呢？因为要尽可能兼容其他区间，所以这个值我们选x区间的最后两个，如果x=[x1, x2]，那么就选m=x2-1，n=x2。因为后面的区间右边界都比当前x的右边界大，因此我们尽可能靠后选择。然后遍历到下一个区间y=[y1,y2]，判断y1和n、m的大小，如果y1&lt;=m，表示m、n可以包含在y中，就不需要增加新的数， 如果y1==n，表示只包含了一个，就需要增加一个值=y2，如果都不在就增加两个值y2和y2-1。注意我们每次只需要比较最新的两个值，也就是最大的两个值，m和n。因此要更新m和n，然后继续遍历到下一个区间即可。</p>
<p>注意相同右边区间的时候，一定要左区间更大的在前，否则在判断的时候会出错。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上，排序$O(nlogn)$，空间上，不需要记录集合元素，$O(1)$。</p>
<p><code>Runtime: 340 ms, faster than 5.32% of C++ online submissions for Set Intersection Size At Least Two.</code></p>
<p><code>Memory Usage: 51.9 MB, less than 33.33% of C++ online submissions for Set Intersection Size At Least Two.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">intersectionSizeTwo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = INT_MIN, n = INT_MIN + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123; <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>] <span class="keyword">or</span> (a[<span class="number">1</span>] == b[<span class="number">1</span>] <span class="keyword">and</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]); &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; n) &#123;</span><br><span class="line">                m = interval[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">                n = m + <span class="number">1</span>;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; m) &#123;</span><br><span class="line">                m = n;</span><br><span class="line">                n = interval[<span class="number">1</span>];</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="第二种，按照左区间排序（相同左区间的右区间更小在前！）"><a href="#第二种，按照左区间排序（相同左区间的右区间更小在前！）" class="headerlink" title="第二种，按照左区间排序（相同左区间的右区间更小在前！）"></a>第二种，按照左区间排序（相同左区间的右区间更小在前！）</h2><p>将所有的区间按照左边界升序排序，然后从最后一个区间x开始，可知区间x与S至少有两个元素相交，如何选取这两个元素呢？因为要尽可能兼容其他区间，所以这个值我们选x区间的前两个，如果x=[x1, x2]，那么就选m=x1，n=x1+1。因为前面的区间左边界都比当前x的左边界大，因此我们尽可能靠前选择。然后遍历到下一个区间y=[y1,y2]，判断y2和m、n的大小，如果y2&gt;=n，表示m、n可以包含在y中，就不需要增加新的数， 如果y2==m，表示只包含了一个，就需要增加一个值=y1，如果都不在就增加两个值y1和y1+1。注意我们每次只需要比较最新的两个值，也就是最小的两个值，m和n。因此要更新m和n，然后继续遍历到下一个区间即可。</p>
<h2 id="时空复杂度-1"><a href="#时空复杂度-1" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上，排序$O(nlogn)$，空间上，不需要记录集合元素，$O(1)$。</p>
<p><code>Runtime: 372 ms, faster than 5.32% of C++ online submissions for Set Intersection Size At Least Two.</code></p>
<p><code>Memory Usage: 52 MB, less than 33.33% of C++ online submissions for Set Intersection Size At Least Two.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">intersectionSizeTwo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = INT_MAX - <span class="number">1</span>, n = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123; <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] <span class="keyword">or</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>] <span class="keyword">and</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]); &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; m) &#123;</span><br><span class="line">                m = interval[<span class="number">0</span>];</span><br><span class="line">                n = m + <span class="number">1</span>;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; n) &#123;</span><br><span class="line">                n = m;</span><br><span class="line">                m = interval[<span class="number">0</span>];</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-20</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/LeetCode(630.%20Course%20Schedule%20III)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/LeetCode(630.%20Course%20Schedule%20III)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(630. Course Schedule III)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-20 00:58:39 / 修改时间：01:04:42" itemprop="dateCreated datePublished" datetime="2020-03-20T00:58:39+08:00">2020-03-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-630-Course-Schedule-III-题解"><a href="#LeetCode-630-Course-Schedule-III-题解" class="headerlink" title="LeetCode(\630. Course Schedule III)题解"></a>LeetCode(\630. Course Schedule III)题解</h1><p>There are <code>n</code> different online courses numbered from <code>1</code> to <code>n</code>. Each course has some duration(course length) <code>t</code> and closed on <code>dth</code> day. A course should be taken <strong>continuously</strong> for <code>t</code> days and must be finished before or on the <code>dth</code> day. You will start at the <code>1st</code> day.</p>
<p>Given <code>n</code> online courses represented by pairs <code>(t,d)</code>, your task is to find the maximal number of courses that can be taken.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">There&#39;re totally 4 courses, but you can take 3 courses at most:</span><br><span class="line">First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.</span><br><span class="line">Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. </span><br><span class="line">Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. </span><br><span class="line">The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The integer 1 &lt;= d, t, n &lt;= 10,000.</li>
<li>You can’t take two courses simultaneously.</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>课程调度的一个变种问题。存在一批课程，每个课程存在包括两个数(t，d)，t为课程持续的时间，d为课程最晚的截止时间，即课程必须在d之前完成。现在在不冲突的情况下，串行地执行课程，可以放弃掉一些课程，请问可以成功执行的课程有最多有多少？</p>
<p>这个题还是使用使用Greedy，蛮难想到的其实。和最小延迟调度一样，我们同样将课程按照截止时间升序排序，因为还是尽可能执行截止时间更早的课程。但是和最小延迟调度每个课程都选用不一样的是，加入一门课程，如果发现这个课程超过了截止时间，那么就从已经加入的课程中删除一个耗时最久即t最大的课程，如果加入的这个课程就是最耗时的，那自然就删除当前这个课程。</p>
<p>按照上述策略，就可以得到最多的可以成功执行的课程，至于最优性证明，假设存在一个最优的选择方案，那么一定可以调整成上述策略选择出来的课程。</p>
<p>这里删除耗时最久的课程，可以使用优先队列，大顶堆。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上，排序加选择，$O(nlogn)$，空间上，$O(n)$。</p>
<p><code>Runtime: 1096 ms, faster than 12.12% of C++ online submissions for Course Schedule III.</code></p>
<p><code>Memory Usage: 248.3 MB, less than 100.00% of C++ online submissions for Course Schedule III.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">scheduleCourse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; courses)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, len = courses.<span class="built_in">size</span>(), courseLen = <span class="number">0</span>;</span><br><span class="line">        sort(courses.<span class="built_in">begin</span>(), courses.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            Q.push(courses[i][<span class="number">0</span>]);</span><br><span class="line">            courseLen += courses[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (courseLen &gt; courses[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                courseLen -= Q.top();</span><br><span class="line">                Q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Q.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-19</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/19/LeetCode(330.%20Patching%20Array)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/19/LeetCode(330.%20Patching%20Array)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(330. Patching Array)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-19 12:12:15 / 修改时间：12:12:18" itemprop="dateCreated datePublished" datetime="2020-03-19T12:12:15+08:00">2020-03-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-330-Patching-Array-题解"><a href="#LeetCode-330-Patching-Array-题解" class="headerlink" title="LeetCode(\330. Patching Array)题解"></a>LeetCode(\330. Patching Array)题解</h1><p>Given a sorted positive integer array <em>nums</em> and an integer <em>n</em>, add/patch elements to the array such that any number in range <code>[1, n]</code> inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3], n &#x3D; 6</span><br><span class="line">Output: 1 </span><br><span class="line">Explanation:</span><br><span class="line">Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.</span><br><span class="line">Now if we add&#x2F;patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].</span><br><span class="line">Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].</span><br><span class="line">So we only need 1 patch.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,5,10], n &#x3D; 20</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The two patches can be [2, 4].</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,2], n &#x3D; 5</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>给一个排序的整数数组nums，和一个n。通过向nums中增加一些元素，使得1~n可以通过nums中的元素进行组合求和得到。返回需要增加的最少元素个数。</p>
<p>这题使用Greedy。总体来说，贪心策略为：我们从1开始，尽可能向着连续增长最快的方向前进，遇到无法增长的时候，尽可能从nums中寻找可以使当前无法覆盖的被覆盖，找不到才增加一个数。比如1，2，走到最远端的是1+2=3，下一个无法达到的数是4，因此直接增加一个4。这种方法可以使用反证法证明是最优的，因为如果增加的数不是最近的无法达到的数，如果增加的比这个数小，最后的总的增加数肯定是小于等于这种方式，如果增加的比这个数大，那这个数就永远也无法满足了。</p>
<p>因此，具体做法如下。</p>
<p>我们维护一个数miss，表示当前构造的序列中，最近一个无法抵达的数。比如当前构造的序列覆盖的范围为1~t，那么miss=t+1。初始化miss=1，因为此时序列中没有元素。</p>
<p>我们假设算法运行到一定程度了，这时候nums从左到右遍历到了i位置，最近的缺失值为miss，那么可以推断出，当前的序列构造到了1~miss-1。</p>
<p>那么这时候判断nums[i]的值，如果大于miss，说明这时候nums中的所有未加入的都大于miss，加入任何值都不能使得miss被覆盖，因此需要我们加入一个为val=miss的值到构造序列中。如果nums[i]&lt;=miss，那么nums[i]与构造序列中的miss-nums[i]或者nums[i]本身就可以组合出miss，因此这时候不需要加入新的数，而是加入val=nums[i]即可，同时i++。通过上述操作之后，构造序列的覆盖范围变成了1~miss-1+val，那么下一个miss值就是miss+val。这样循环下去，直到miss+val&gt;n。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上$O(n)$，空间上$O(1)$。</p>
<p><code>Runtime: 8 ms, faster than 66.49% of C++ online submissions for Patching Array.</code></p>
<p><code>Memory Usage: 8.2 MB, less than 100.00% of C++ online submissions for Patching Array.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> miss = <span class="number">1</span>, i = <span class="number">0</span>, len = nums.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (miss &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len <span class="keyword">and</span> nums[i] &lt;= miss) &#123;</span><br><span class="line">                miss = miss + nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res++;</span><br><span class="line">                miss = miss + miss;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-19</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/LeetCode(321.%20Create%20Maximum%20Number)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/17/LeetCode(321.%20Create%20Maximum%20Number)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(321. Create Maximum Number)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-17 23:42:06" itemprop="dateCreated datePublished" datetime="2020-03-17T23:42:06+08:00">2020-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-18 15:36:37" itemprop="dateModified" datetime="2020-03-18T15:36:37+08:00">2020-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-321-Create-Maximum-Number-题解"><a href="#LeetCode-321-Create-Maximum-Number-题解" class="headerlink" title="LeetCode(\321. Create Maximum Number)题解"></a>LeetCode(\321. Create Maximum Number)题解</h1><p>Given two arrays of length <code>m</code> and <code>n</code> with digits <code>0-9</code> representing two numbers. Create the maximum number of length <code>k &lt;= m + n</code> from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the <code>k</code> digits.</p>
<p><strong>Note:</strong> You should try to optimize your time and space complexity.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [3, 4, 6, 5]</span><br><span class="line">nums2 &#x3D; [9, 1, 2, 5, 8, 3]</span><br><span class="line">k &#x3D; 5</span><br><span class="line">Output:</span><br><span class="line">[9, 8, 6, 5, 3]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [6, 7]</span><br><span class="line">nums2 &#x3D; [6, 0, 4]</span><br><span class="line">k &#x3D; 5</span><br><span class="line">Output:</span><br><span class="line">[6, 7, 6, 0, 4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [3, 9]</span><br><span class="line">nums2 &#x3D; [8, 9]</span><br><span class="line">k &#x3D; 3</span><br><span class="line">Output:</span><br><span class="line">[9, 8, 9]</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>有m和n长的两个整数数组nums1和nums2，整数数组表示一个大的多位整数。从前到后每个元素都是0-9的值。现在从两个数组中选出K(K&lt;m+n)个数组成一个新的整数数组来表示一个大的K位数，选出的元素要保持在原有数组的相对顺序，返回选定的最大的K位数数组。</p>
<p>这个题如何来做呢？我的思路是这样的——</p>
<p>首先不考虑边界问题，我们组成一个K位数，一定是从nums1中选一些数，再从nums2中选一些数组成K个数，再组合成一个K位数。那么我们就遍历从nums1选0个数和nums2选K个数，nums1选1个数和nums2选K-1个数，…，nums1选K个数和nums2选0个数，这样遍历K种情况，每种情况下都得到对应的最大的K位数整数数组，最后比较一下就可以。这个步骤的时间复杂度$O(K)$。</p>
<p>好，现在考虑选定了数之后怎么组合的问题。假定从nums1中选了a个数，从nums2中选了b个数，a+b=K。那么nums1的a个数和nums2的b个数在保持原有相对顺序不变的情况下得到最大的K位数数组的组合方式就很简单了。我们直接按照类似于归并排序内的merge方式就可以。在a个数和b个数的开头分别设置一个指针，每次选择两个指针中较大的那个值放入组合的K位数中的尾部即可，然后对应的指针后移一位。但是这里要注意如果两个指针指向的元素是一样的话，那么就要判断后面的元素大大小才能确定移动哪个指针（移动后面元素更大的那个数组的指针）。这个步骤的时间复杂度为$O(K)$。</p>
<p>那么现在就应该考虑如何从两个数组中选数了。假定我们要从nums1中选出a个数，一共有多少种方式呢，答案是$ C_{m}^{a} $ 种。如果再加上nums2的二者一乘，时间复杂度就太高了。但其实想一想，我们只需要nums1中最大的a个数就可以了，怎么定义最大呢，就是a个数组成的a位数是所有a个数组成的数中最大的。</p>
<p>那么现在，问题就变成了——怎么从一个0-9的整数数组中选出a个数，假设数组为nums1，在保持原有顺序的前提下，使得选出的a个数组成最大的a位数。</p>
<p>在这里我们可以使用贪心策略，即我们尽可能保证选出的a个数，位于前列的数更大，这样最后组成的a位数就尽可能大。比如选第一个数，我们就首先去寻找9的位置，如果存在9且这个9后面的数大于等于a-1个，那么我们就可以选这个，然后在后面的序列中选剩下的a-1个数。如果不满足条件，就依次寻找8、7、6等。</p>
<p>这里我们可以选择使用Stack来帮助我们，维护一个递减栈，从nums1的左边开始向右遍历。当遍历到一个数时，如果栈为空或者当前元素加上栈内的元素个数再加上剩余未遍历的元素等于a，就直接将元素入栈。否则就判断当前元素是否小于栈顶元素，小于等于就直接入栈。如果大于，就在保证当前元素加上栈内的元素个数再加上剩余未遍历的元素等于a，同时栈顶元素小于当前元素的前提下，不断出栈，最后将当前元素入栈。最后遍历结束时，栈中的元素个数一定大于等于a，返回栈底前a个元素，这就是最大的a个符合顺序的元素。这个步骤时间复杂度为$O(m)$。同样对nums2操作，时间复杂度为$O(n)$。</p>
<p>因此，按照上述方法，时间复杂度为$O(K(K+m+n))$。空间复杂度$O(K+m+n)$。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下。</p>
<p><code>Runtime: 48 ms, faster than 70.26% of C++ online submissions for Create Maximum Number.</code></p>
<p><code>Memory Usage: 23.4 MB, less than 80.00% of C++ online submissions for Create Maximum Number.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxNumberOfSingleArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!S.empty() <span class="keyword">and</span> S.back() &lt; nums[i] <span class="keyword">and</span> S.<span class="built_in">size</span>() + len - i &gt; k) S.pop_back();</span><br><span class="line">            S.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            res[i] = S.front();</span><br><span class="line">            S.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k1 = res1.<span class="built_in">size</span>(), k2 = res2.<span class="built_in">size</span>(), i1 = <span class="number">0</span>, i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i1 &lt; k1 <span class="keyword">and</span> i2 &lt; k2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res1[i1] &gt; res2[i2]) res.push_back(res1[i1++]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (res1[i1] &lt; res2[i2]) res.push_back(res2[i2++]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> ti1 = i1 + <span class="number">1</span>, ti2 = i2 + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (ti1 &lt; k1 <span class="keyword">and</span> ti2 &lt; k2 <span class="keyword">and</span> res1[ti1] == res2[ti2]) &#123;</span><br><span class="line">                    ti1++;</span><br><span class="line">                    ti2++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ti1 == k1) res.push_back(res2[i2++]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ti2 == k2) res.push_back(res1[i1++]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (res1[ti1] &gt; res2[ti2]) res.push_back(res1[i1++]);</span><br><span class="line">                <span class="keyword">else</span> res.push_back(res2[i2++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i1 &lt; k1) res.push_back(res1[i1++]);</span><br><span class="line">        <span class="keyword">while</span> (i2 &lt; k2) res.push_back(res2[i2++]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBigger</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res1[i] &gt; res2[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (res1[i] &lt; res2[i]) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; m <span class="keyword">or</span> k-i &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp1 = maxNumberOfSingleArray(nums1, i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp2 = maxNumberOfSingleArray(nums2, k-i);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = merge(tmp1, tmp2);</span><br><span class="line">            <span class="keyword">if</span> (isBigger(tmp, res, k)) &#123;</span><br><span class="line">                res = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-18</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/16/LeetCode(1383.%20Maximum%20Performance%20of%20a%20Team)%E5%91%A8%E8%B5%9B%E9%A2%984%E9%A2%98%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/16/LeetCode(1383.%20Maximum%20Performance%20of%20a%20Team)%E5%91%A8%E8%B5%9B%E9%A2%984%E9%A2%98%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(1383. Maximum Performance of a Team)周赛题4题题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-16 10:36:53 / 修改时间：10:48:04" itemprop="dateCreated datePublished" datetime="2020-03-16T10:36:53+08:00">2020-03-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-1383-Maximum-Performance-of-a-Team-周赛题4题题解"><a href="#LeetCode-1383-Maximum-Performance-of-a-Team-周赛题4题题解" class="headerlink" title="LeetCode(\1383. Maximum Performance of a Team)周赛题4题题解"></a>LeetCode(\1383. Maximum Performance of a Team)周赛题4题题解</h1><p>There are <code>n</code> engineers numbered from 1 to <code>n</code> and two arrays: <code>speed</code> and <code>efficiency</code>, where <code>speed[i]</code> and <code>efficiency[i]</code> represent the speed and efficiency for the i-th engineer respectively. <em>Return the maximum <strong>performance</strong> of a team composed of at most <code>k</code> engineers, since the answer can be a huge number, return this modulo 10^9 + 7.</em></p>
<p>The <strong>performance</strong> of a team is the sum of their engineers’ speeds multiplied by the minimum efficiency among their engineers. </p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 6, speed &#x3D; [2,10,3,1,5,8], efficiency &#x3D; [5,4,3,9,7,2], k &#x3D; 2</span><br><span class="line">Output: 60</span><br><span class="line">Explanation: </span><br><span class="line">We have the maximum performance of the team by selecting engineer 2 (with speed&#x3D;10 and efficiency&#x3D;4) and engineer 5 (with speed&#x3D;5 and efficiency&#x3D;7). That is, performance &#x3D; (10 + 5) * min(4, 7) &#x3D; 60.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 6, speed &#x3D; [2,10,3,1,5,8], efficiency &#x3D; [5,4,3,9,7,2], k &#x3D; 3</span><br><span class="line">Output: 68</span><br><span class="line">Explanation:</span><br><span class="line">This is the same example as the first but k &#x3D; 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance &#x3D; (2 + 10 + 5) * min(5, 4, 7) &#x3D; 68.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 6, speed &#x3D; [2,10,3,1,5,8], efficiency &#x3D; [5,4,3,9,7,2], k &#x3D; 4</span><br><span class="line">Output: 72</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>speed.length == n</code></li>
<li><code>efficiency.length == n</code></li>
<li><code>1 &lt;= speed[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= efficiency[i] &lt;= 10^8</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>这题可以这样想，有N名工人，每个工人有一个勤奋度和做事速度，二者都越大越好。现在最多要招K名员工组成一个团队，团队整体的质量是由团队所有人的做事速度相加再乘上最低的勤奋度得到的，请问如何选择才能得到最高的质量，返回这个值，不过记得取余数。</p>
<p>这个题使用Greedy解决，可以使用优先队列。首先将所有工人按照勤奋度降序排序，从前到后遍历工人，然后维护一个最大为K个元素的最小堆，每次将工人的做事速度放入堆中，堆中的元素就代表了要选的工人，如果超过了K个元素就将速度最小的那个去掉，在这个过程中记录最高的团队质量。</p>
<p>而贪心策略就是，如果必须要要加入一个人同时必须在团队内删除一个人的话，那我就去掉那个速度最慢的，因为勤奋度在排序之后已经入了团队的人的勤奋度是不会成为最低的勤奋度的。</p>
<p>这个题和<a href="https://leetcode.com/problems/minimum-cost-to-hire-k-workers/" target="_blank" rel="noopener">857. Minimum Cost to Hire K Workers</a>是一样的解法，不过857是按单价从低到高排序，每次从最大堆里推掉质量最大的人。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间复杂度主要用在排序上面，$O(nlogn)$，空间上$O(n)$.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPerformance</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; speed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; efficiency, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;int, int&gt;&gt; se(n);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>, m = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">9</span>) + <span class="number">7</span>, speedSum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) se[i] = make_pair(speed[i], efficiency[i]);</span><br><span class="line">        sort(se.<span class="built_in">begin</span>(), se.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; minHeap;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minHeap.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">                minHeap.push(se[i].first);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                speedSum -= minHeap.top();</span><br><span class="line">                minHeap.pop();</span><br><span class="line">                minHeap.push(se[i].first);</span><br><span class="line">            &#125;</span><br><span class="line">            speedSum += se[i].first;</span><br><span class="line"></span><br><span class="line">            res = <span class="built_in">max</span>(res, speedSum * se[i].second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res % m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2020-03-15</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">XJ</p>
  <div class="site-description" itemprop="description">幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">350</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XJ</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
