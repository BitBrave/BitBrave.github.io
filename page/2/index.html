<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:type" content="website">
<meta property="og:title" content="BitBrave">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="BitBrave">
<meta property="og:description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XJ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>BitBrave</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7e6d55cf2fa14e729703953237f65413";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BitBrave</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">IIE</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/18/LeetCode%E6%98%A5%E5%AD%A3%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98%E8%B5%9B(LCP%2009.%20%E6%9C%80%E5%B0%8F%E8%B7%B3%E8%B7%83%E6%AC%A1%E6%95%B0)4%E9%A2%98%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/LeetCode%E6%98%A5%E5%AD%A3%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98%E8%B5%9B(LCP%2009.%20%E6%9C%80%E5%B0%8F%E8%B7%B3%E8%B7%83%E6%AC%A1%E6%95%B0)4%E9%A2%98%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode春季编程挑战赛(LCP 09. 最小跳跃次数)4题题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-18 22:43:18 / 修改时间：22:43:19" itemprop="dateCreated datePublished" datetime="2020-04-18T22:43:18+08:00">2020-04-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode春季编程挑战赛-LCP-09-最小跳跃次数-4题题解"><a href="#LeetCode春季编程挑战赛-LCP-09-最小跳跃次数-4题题解" class="headerlink" title="LeetCode春季编程挑战赛(LCP 09. 最小跳跃次数)4题题解"></a>LeetCode春季编程挑战赛(<a href="https://leetcode-cn.com/problems/zui-xiao-tiao-yue-ci-shu/" target="_blank" rel="noopener">LCP 09. 最小跳跃次数</a>)4题题解</h1><p>为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由 N 个特殊弹簧排成一排，编号为 0 到 N-1。初始有一个小球在编号 0 的弹簧处。若小球在编号为 i 的弹簧处，通过按动弹簧，可以选择把小球向右弹射 jump[i] 的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为 i 弹簧处按动弹簧，小球可以弹向 0 到 i-1 中任意弹簧或者 i+jump[i] 的弹簧（若 i+jump[i]&gt;=N ，则表示小球弹出了机器）。小球位于编号 0 处的弹簧时不能再向左弹。</p>
<p>为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号 0 弹簧弹出整个机器，即向右越过编号 N-1 的弹簧。</p>
<p>示例 1：</p>
<p>输入：jump = [2, 5, 1, 1, 1, 1]</p>
<p>输出：3</p>
<p>解释：小 Z 最少需要按动 3 次弹簧，小球依次到达的顺序为 0 -&gt; 2 -&gt; 1 -&gt; 6，最终小球弹出了机器。</p>
<p>限制：</p>
<p>1 &lt;= jump.length &lt;= 10^6<br>1 &lt;= jump[i] &lt;= 10000</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>这个题可以使用BFS在O(N)的时间内解决。我们利用BFS的层序遍历特性，最先超过end时的层数就是题目的解。</p>
<p>首先将jump[0]的入队，然后后续每次按一层的方式将元素出队列，对于出的队列的每个值，判断其jump一次是否可以超过end，如果超过，算法结束，返回层数。否则就看是否已经入过队列，没有就将其入队。</p>
<p>然后往左遍历每个元素，因为往左跳的节点都不可能是end后的，所以这里不用判断是否超过了end，都判断是否已经在队列了，不在就加入队列。</p>
<p>注意这里左边的每个元素其实只需要判断一次，利用其它的元素判断过的就不用再判断了。因此可以用一个递增的pre每次判断之后+1，这样就避免重复遍历了。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间复杂度，O(n)，空间复杂度O(n)。</p>
<p><code>执行用时 :652 ms, 在所有 C++ 提交中击败了100.00%的用户</code></p>
<p><code>内存消耗 :111.9 MB, 在所有 C++ 提交中击败了100.00%的用户</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jump)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = jump.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visit</span><span class="params">(len, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (jump[<span class="number">0</span>] &gt;= len) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Q.push(jump[<span class="number">0</span>]);</span><br><span class="line">        visit[<span class="number">0</span>] = <span class="literal">true</span>; visit[jump[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">int</span> L = Q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (L-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> node = Q.front(), next = node + jump[node]; Q.pop();</span><br><span class="line">                <span class="keyword">if</span> (next &gt;= len) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">if</span> (visit[next] == <span class="literal">false</span>) &#123;</span><br><span class="line">                    visit[next] = <span class="literal">true</span>;</span><br><span class="line">                    Q.push(next);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> (pre &lt;= node) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visit[pre] == <span class="literal">false</span>) &#123;</span><br><span class="line">                        Q.push(pre);</span><br><span class="line">                        visit[pre] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre++; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-04-17</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/18/LeetCode(523.%20Continuous%20Subarray%20Sum)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/LeetCode(523.%20Continuous%20Subarray%20Sum)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(523. Continuous Subarray Sum)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-18 10:16:11 / 修改时间：10:16:12" itemprop="dateCreated datePublished" datetime="2020-04-18T10:16:11+08:00">2020-04-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="LeetCode-523-Continuous-Subarray-Sum-题解"><a href="#LeetCode-523-Continuous-Subarray-Sum-题解" class="headerlink" title="LeetCode(\523. Continuous Subarray Sum)题解"></a>LeetCode(\523. Continuous Subarray Sum)题解</h2><p>Given a list of <strong>non-negative</strong> numbers and a target <strong>integer</strong> k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of <strong>k</strong>, that is, sums up to n<em>k where n is also an *</em>integer**.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [23, 2, 4, 6, 7],  k&#x3D;6</span><br><span class="line">Output: True</span><br><span class="line">Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [23, 2, 6, 4, 7],  k&#x3D;6</span><br><span class="line">Output: True</span><br><span class="line">Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The length of the array won’t exceed 10,000.</li>
<li>You may assume the sum of all the numbers is in the range of a signed 32-bit integer.</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Medium</p>
<p>给一个非负数组nums和整数k，检查是否数组中存在连续子数组的和为k的整数倍，连续子数组的元素个数必须大于等于2.</p>
<p>这个题最简单的就是枚举，依次检查所有的序列，只要遇到满足和为k的整数倍就结束。这样也可以AC，时间复杂度为O(n2)。</p>
<p>一个更聪明的办法是使用DP。</p>
<p>我们观察数组有这样一个性质，假设前i个元素的和为s1，前j个元素和为s2，i&lt;j，如果s1%k == s2%k。那么i+1，…，j这些元素和也就是s2-s1就是可以整除k的。</p>
<p>因此我们可以使用一个map记录，以数组开始到某一个元素的子数组和对k的余数为key，对应和的子序列最后一个元素所在位置为value。当走到位置i时，得到和为s1，查看Map[s1 % k]是否存在，如果不存在就记录Map[s1 % k] = i + 1. 如果存在就查看其位置和i是否相隔至少两个，因为子序列最少要两个元素。如果是，说明满足条件，算法结束返回true。否则就跳过，这里不要更新Map[s1 % k]，因为我们对于相同的元素，尽可能保存前面的位置，这是为了后面的元素与之相隔尽可能宽。</p>
<p>另外，如果数组的符号条件的子序列就是从开头算起怎么办？所以这里需要定一个Map[0]=0.</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>代码如下，时间上，O(n)，空间上，O(n).</p>
<p><code>Runtime: 28 ms, faster than 84.89% of C++ online submissions for Continuous Subarray Sum.</code></p>
<p><code>Memory Usage: 9.5 MB, less than 100.00% of C++ online submissions for Continuous Subarray Sum.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i<span class="number">-1</span>] == nums[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt; M;</span><br><span class="line">        M[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> s = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            s += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (M.<span class="built_in">find</span>(s % k) != M.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (M[s % k] &lt; i) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> M[s % k] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2020-04-17</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/16/LeetCode(467.%20Unique%20Substrings%20in%20Wraparound%20String)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/16/LeetCode(467.%20Unique%20Substrings%20in%20Wraparound%20String)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(467. Unique Substrings in Wraparound String)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-16 12:27:20 / 修改时间：12:27:23" itemprop="dateCreated datePublished" datetime="2020-04-16T12:27:20+08:00">2020-04-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-467-Unique-Substrings-in-Wraparound-String-题解"><a href="#LeetCode-467-Unique-Substrings-in-Wraparound-String-题解" class="headerlink" title="LeetCode(\467. Unique Substrings in Wraparound String)题解"></a>LeetCode(\467. Unique Substrings in Wraparound String)题解</h1><p>Consider the string <code>s</code> to be the infinite wraparound string of “abcdefghijklmnopqrstuvwxyz”, so <code>s</code> will look like this: “…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….”.</p>
<p>Now we have another string <code>p</code>. Your job is to find out how many unique non-empty substrings of <code>p</code> are present in <code>s</code>. In particular, your input is the string <code>p</code> and you need to output the number of different non-empty substrings of <code>p</code> in the string <code>s</code>.</p>
<p><strong>Note:</strong> <code>p</code> consists of only lowercase English letters and the size of p might be over 10000.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;a&quot;</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: Only the substring &quot;a&quot; of string &quot;a&quot; is in the string s.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cac&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two substrings &quot;a&quot;, &quot;c&quot; of string &quot;cac&quot; in the string s.</span><br></pre></td></tr></table></figure>



<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;zab&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: There are six substrings &quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, &quot;zab&quot; of string &quot;zab&quot; in the string s.</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Medium</p>
<p>有一个由’abcd…zabcd..z….’无限扩展的字符串s，现给定一个字符串p，寻找p中有多少子串时s中的子串。</p>
<p>这是一个DP问题，想不到转移方程的话是有点难的（比如说我）。我就以我的理解写一下这个题怎么做吧。</p>
<p>首先s中的字符可以看成都是连续的abcd…，那么p中就是要找有多少个连续子串。进一步的，我们可以找出以具体某一个字符结尾的子字符串有多少个。比如怕p中以‘a’结尾的子串数目。然后将26个字符结尾的子串数目相加即可。</p>
<p>以‘a’为例子，那现在问题就变成了，从p中找出以‘a’结尾的子串数目。这个子串是连续的，也就是说，以‘a’结尾的长度为1的子串只能是‘a’，长度为2的只能是‘za’，长度为3的只能是‘yza’，以此类推。那也就是说，p中以‘a’结尾的最长连续子串一定包含了p中所有以‘a’结尾的连续子串，最长连续子串的长度就是p中所有以‘a’结尾的子串的数目。</p>
<p>那好，这个题目的问题就变成了，在p中找出分别以‘a’、‘b’、…、‘z’结尾的最长连续子串的数目。一个办法是，在p中分别找到‘a’、‘b’、‘c’，···，‘z’的字符的位置，然后向前遍历，寻找最长的连续子串。但这样比较耗时。一个更好的办法是，建立一个26大小的数组，分别记录以不同字符结尾的最长连续子串的长度。然后从左到右遍历字符串p，记录走到当前位置时的连续子串的长度，如果跟前面可以组成连续的，就是在现有记录的长度上++，否则就是1，然后作为当前位置的连续子串的长度，最后把这个位置的字符的最长连续子串的长度进行更新。看到这相信大家都明白了，这个记录长度的做法就是最长子序列的方法。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上，O(N)，空间上，O(1)。</p>
<p><code>Runtime: 8 ms, faster than 91.17% of C++ online submissions for Unique Substrings in Wraparound String.</code></p>
<p><code>Memory Usage: 7.4 MB, less than 100.00% of C++ online submissions for Unique Substrings in Wraparound String.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> len; </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> con_len = <span class="number">1</span>;</span><br><span class="line">        dp[p[<span class="number">0</span>]-<span class="string">'a'</span>] = con_len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i]-p[i<span class="number">-1</span>]==<span class="number">1</span> || p[i<span class="number">-1</span>]-p[i]==<span class="number">25</span>) con_len++;</span><br><span class="line">            <span class="keyword">else</span> con_len = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            dp[p[i]-<span class="string">'a'</span>] = <span class="built_in">max</span>(dp[p[i]-<span class="string">'a'</span>], con_len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// accumulate带有三个形参：头两个形参指定要累加的元素范围，第三个形参则是累加的初值。</span></span><br><span class="line">        <span class="keyword">return</span> accumulate(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/12/LeetCode(464.%20Can%20I%20Win)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/12/LeetCode(464.%20Can%20I%20Win)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(464. Can I Win)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-12 22:16:45" itemprop="dateCreated datePublished" datetime="2020-04-12T22:16:45+08:00">2020-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-13 11:03:18" itemprop="dateModified" datetime="2020-04-13T11:03:18+08:00">2020-04-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-464-Can-I-Win-题解"><a href="#LeetCode-464-Can-I-Win-题解" class="headerlink" title="LeetCode(\464. Can I Win)题解"></a>LeetCode(\464. Can I Win)题解</h1><p>In the “100 game,” two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.</p>
<p>What if we change the game so that players cannot re-use integers?</p>
<p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100.</p>
<p>Given an integer <code>maxChoosableInteger</code> and another integer <code>desiredTotal</code>, determine if the first player to move can force a win, assuming both players play optimally.</p>
<p>You can always assume that <code>maxChoosableInteger</code> will not be larger than 20 and <code>desiredTotal</code> will not be larger than 300.</p>
<p><strong>Example</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">maxChoosableInteger &#x3D; 10</span><br><span class="line">desiredTotal &#x3D; 11</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">No matter which integer the first player choose, the first player will lose.</span><br><span class="line">The first player can choose an integer from 1 up to 10.</span><br><span class="line">If the first player choose 1, the second player can only choose integers from 2 up to 10.</span><br><span class="line">The second player will win by choosing 10 and get a total &#x3D; 11, which is &gt;&#x3D; desiredTotal.</span><br><span class="line">Same with other integers chosen by the first player, the second player will always win.</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Medium</p>
<p>给一个maxChoosableInteger和desiredTotal，两个人依次在1，2，···，maxChoosableInteger选一个数，不可重复选，选一个少一个。如果谁先选择一个数使得两人选过的数之和大于等于desiredTotal，就判断这个人胜利。假设两人都按最优策略来走，那么请问第一个选的人是赢是输。</p>
<p>这个题虽然是Medium，但对我来说还是挺难的。首先还是说下思路。</p>
<p>首先是使用回溯法，建立一个递归函数helper，表示在当前选定条件下，接下来第一个选择的人是一定胜利还是一定输。因为maxChoosableInteger不大，所以可以用一个字符串pos的01串来表示哪些数已经被选择了，然后使用递归，在里面依次选择还未被选择的数，再更新pos和剩下的整数。这里使用Map记录已经得到结果的pos的值。</p>
<p>写出了这个代码，一般都会想到是不是能使用DP解决问题。从这个代码就可以看出来，一个pos依赖于后面的pos的选取，只是要把pos中的一个0变为1而已。其实如果数能重用的话，就很容易转为DP，f(i) = ~f(i-d)。这里一个数只能用一次，因此很难使用DP。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上为O(N2)，空间上理论上是O(2^N)，但实际上用不到这么多。</p>
<p><code>Runtime: 800 ms, faster than 6.46% of C++ online submissions for Can I Win.</code></p>
<p><code>Memory Usage: 119.8 MB, less than 20.00% of C++ online submissions for Can I Win.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; M;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal, <span class="built_in">string</span> pos_)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (M.<span class="built_in">find</span>(pos_) != M.<span class="built_in">end</span>()) <span class="keyword">return</span> M[pos_];</span><br><span class="line">        M[pos_] = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">string</span> pos = pos_;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=maxChoosableInteger; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos[i] == <span class="string">'1'</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            pos[i] = <span class="string">'1'</span>;</span><br><span class="line">            <span class="keyword">if</span> (desiredTotal&lt;=i) &#123;</span><br><span class="line">                M[pos_] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!helper(maxChoosableInteger, desiredTotal-i, pos)) &#123;</span><br><span class="line">                M[pos_] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pos[i] = <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (desiredTotal &lt;= maxChoosableInteger) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ((maxChoosableInteger + <span class="number">1</span>) * maxChoosableInteger / <span class="number">2</span> &lt; desiredTotal) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">pos</span><span class="params">(maxChoosableInteger+<span class="number">1</span>, <span class="string">'0'</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(maxChoosableInteger, desiredTotal, pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-04-12.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/11/LeetCode(446.%20Arithmetic%20Slices%20II%20-%20Subsequence)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/11/LeetCode(446.%20Arithmetic%20Slices%20II%20-%20Subsequence)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(446. Arithmetic Slices II - Subsequence)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-11 21:56:10 / 修改时间：21:56:14" itemprop="dateCreated datePublished" datetime="2020-04-11T21:56:10+08:00">2020-04-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-446-Arithmetic-Slices-II-Subsequence-题解"><a href="#LeetCode-446-Arithmetic-Slices-II-Subsequence-题解" class="headerlink" title="LeetCode(\446. Arithmetic Slices II - Subsequence)题解"></a>LeetCode(\446. Arithmetic Slices II - Subsequence)题解</h1><p>A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>
<p>For example, these are arithmetic sequences:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure>

<p>The following sequence is not arithmetic.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure>



<p>A zero-indexed array A consisting of N numbers is given. A <strong>subsequence</strong> slice of that array is any sequence of integers (P0, P1, …, Pk) such that 0 ≤ P0 &lt; P1 &lt; … &lt; Pk &lt; N.</p>
<p>A <strong>subsequence</strong> slice (P0, P1, …, Pk) of array A is called arithmetic if the sequence A[P0], A[P1], …, A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2.</p>
<p>The function should return the number of arithmetic subsequence slices in the array A.</p>
<p>The input contains N integers. Every integer is in the range of -231 and 231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 231-1.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 4, 6, 8, 10]</span><br><span class="line"></span><br><span class="line">Output: 7</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">All arithmetic subsequence slices are:</span><br><span class="line">[2,4,6]</span><br><span class="line">[4,6,8]</span><br><span class="line">[6,8,10]</span><br><span class="line">[2,4,6,8]</span><br><span class="line">[4,6,8,10]</span><br><span class="line">[2,4,6,8,10]</span><br><span class="line">[2,6,10]</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>从一个整数数组A中选取不少于三个数按相对顺序组成等差数列。问数组中最多能选多少个这样的子数组。</p>
<p>这个题可以使用DP，我们设定dp2(i,diff)，表示在前i+1个数中，以A[i]结尾，差值为diff的等差数列的个数，特殊的是，每个数列只有2个数。然后再设定一个dp3(i,diff)表示在前i+1个数中，以A[i]结尾，差值为diff的等差数列的个数，特殊的是，每个数列都大于等于3个数，dp2是为了填充后续的dp3的。</p>
<p>那么dp2(i,*)，dp3(i,*)，如何填充呢？状态转移方程如下，对于元素A[i]，遍历前面的元素A[j]，j&lt;i。diff = A[i]-A[j]。dp3(i,diff)+=dp2(j,diff)+dp3(j,diff)。而dp2(i,diff) += 1.</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上O(N2)，空间上O(N)。</p>
<p><code>Runtime: 1188 ms, faster than 21.61% of C++ online submissions for Arithmetic Slices II - Subsequence.</code></p>
<p><code>Memory Usage: 155 MB, less than 40.00% of C++ online submissions for Arithmetic Slices II - Subsequence.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;unordered_map&lt;long, long&gt;&gt; dp2(len), dp3(len);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> diff;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">                diff = (<span class="keyword">long</span>)A[i]- (<span class="keyword">long</span>)A[j];</span><br><span class="line">                <span class="keyword">if</span> (dp2[i].<span class="built_in">find</span>(diff) == dp2[i].<span class="built_in">end</span>()) dp2[i][diff] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp2[i][diff] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dp3[i][diff] = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;<span class="number">0</span>; j--) &#123;</span><br><span class="line">                diff = (<span class="keyword">long</span>)A[i] - (<span class="keyword">long</span>)A[j];</span><br><span class="line">                <span class="keyword">if</span> (dp2[j].<span class="built_in">find</span>(diff) != dp2[j].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    res += dp2[j][diff];</span><br><span class="line">                    dp3[i][diff] += dp2[j][diff];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (dp3[j].<span class="built_in">find</span>(diff) != dp3[j].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    res += dp3[j][diff];</span><br><span class="line">                    dp3[i][diff] += dp3[j][diff];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/09/LeetCode(/403.%20Frog%20Jump)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/09/LeetCode(%5C403.%20Frog%20Jump)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(\403. Frog Jump)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-09 18:57:01 / 修改时间：22:44:29" itemprop="dateCreated datePublished" datetime="2020-04-09T18:57:01+08:00">2020-04-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-403-Frog-Jump-题解"><a href="#LeetCode-403-Frog-Jump-题解" class="headerlink" title="LeetCode(\403. Frog Jump)题解"></a>LeetCode(\403. Frog Jump)题解</h1><p>A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.</p>
<p>Given a list of stones’ positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.</p>
<p>If the frog’s last jump was <em>k</em> units, then its next jump must be either <em>k</em> - 1, <em>k</em>, or <em>k</em> + 1 units. Note that the frog can only jump in the forward direction.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The number of stones is ≥ 2 and is &lt; 1,100.</li>
<li>Each stone’s position will be a non-negative integer &lt; 231.</li>
<li>The first stone’s position is always 0.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0,1,3,5,6,8,12,17]</span><br><span class="line"></span><br><span class="line">There are a total of 8 stones.</span><br><span class="line">The first stone at the 0th unit, second stone at the 1st unit,</span><br><span class="line">third stone at the 3rd unit, and so on...</span><br><span class="line">The last stone at the 17th unit.</span><br><span class="line"></span><br><span class="line">Return true. The frog can jump to the last stone by jumping </span><br><span class="line">1 unit to the 2nd stone, then 2 units to the 3rd stone, then </span><br><span class="line">2 units to the 4th stone, then 3 units to the 6th stone, </span><br><span class="line">4 units to the 7th stone, and 5 units to the 8th stone.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0,1,2,3,4,8,9,11]</span><br><span class="line"></span><br><span class="line">Return false. There is no way to jump to the last stone as </span><br><span class="line">the gap between the 5th and 6th stone is too large.</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>一只青蛙要过河，河里有一些石头。给定一个递增数组，表示石头的位置。如果青蛙能跳到最后一个石头上，那么他就能过河。青蛙从0位置开始以速度1往后跳，跳到1之后可以，继续往后跳。有这样一个条件：青蛙跳到某一步时的速度为k，那么下一步就可以是k-1，k和k+1中的1个，往后跳。青蛙只能往后跳，并且只能跳到石头上，请问给定了数组，这只青蛙是否能够过河？</p>
<p>这个题分析一下就可以发现，我们最简单的就是暴力搜索。青蛙从0开始，下一个一定是1，那么就可以查看数组的前两个，如果不是0和1，那就肯定不能。其次，我们可以用一个递归函数，输入位置和当前速度，然后以三种速度（k-1、k、k+1）分别往后跳。只要搜索到跳到最后一个石头，就说明能到，跳过了最后一个石头就停止搜索，就表示不能到，同时其它情况也说明不能到。</p>
<p>递归代码如下，毫无疑问超时了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">int</span> target;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; target <span class="keyword">or</span> k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (S.<span class="built_in">find</span>(pos) == S.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(pos+k<span class="number">-1</span>, k<span class="number">-1</span>) <span class="keyword">or</span> helper(pos+k, k) <span class="keyword">or</span> helper(pos+k+<span class="number">1</span>, k+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (stones[<span class="number">0</span>] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &gt;= <span class="number">2</span> <span class="keyword">and</span> stones[<span class="number">1</span>] != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        S = <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>());</span><br><span class="line">        target = stones[len<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>上述代码虽然超时了，但是我们可以进行优化。就是用一个Map记录下pos和k的子状态，当下一次再次走到相同的pos和k时，就不用再继续向下走了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">int</span> target;</span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">bool</span>&gt; M;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (M.<span class="built_in">find</span>(make_pair(pos, k)) != M.<span class="built_in">end</span>()) <span class="keyword">return</span> M[make_pair(pos, k)];</span><br><span class="line">        <span class="keyword">if</span> (pos == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; target <span class="keyword">or</span> k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (S.<span class="built_in">find</span>(pos) == S.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        M[make_pair(pos, k)] = helper(pos+k<span class="number">-1</span>, k<span class="number">-1</span>) <span class="keyword">or</span> helper(pos+k, k) <span class="keyword">or</span> helper(pos+k+<span class="number">1</span>, k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> M[make_pair(pos, k)];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (stones[<span class="number">0</span>] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &gt;= <span class="number">2</span> <span class="keyword">and</span> stones[<span class="number">1</span>] != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        S = <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>());</span><br><span class="line">        target = stones[len<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>万万没想到，这样的操作就AC了。其实分析一下，加上Map的理论上的时间复杂度就是$O(N<em>target</em>2)$，空间复杂度为$O(N*target)$。时间复杂度中，乘2是因为要遍历到k&gt;target的数，这个时间复杂度是可以接受的，但是有的递归，就判断这个越界其实就容易超时。这里还好，数量级没有增加。</p>
<p><code>Runtime: 164 ms, faster than 42.18% of C++ online submissions for Frog Jump.</code></p>
<p><code>Memory Usage: 15.1 MB, less than 40.00% of C++ online submissions for Frog Jump.</code></p>
<p>其实这个问题最好还是使用DP问题，观察上述的优化后的递归算法，DP问题就呼之欲出了。我们用f来表示dp数组。那么f(pos, k)就表示走到目标是否可以走到pos位置，同时到达的时候速度为k，因为pos直接用表示位置来说就太大了，题目里石头小于1100块，位置最大却是2的31次方，所以这里我们用pos表示第pos块石头。因为从上一个地方跳过来的距离肯定是stones[pos]-k，而那时候的速度肯定是k、k-1或者k+1，那么上一个跳的地方就可以算出来了。状态转移方程更新如下——</p>
<p>如果stones[pos]-k处的石头不存在，则f(pos,k)直接为false。如果存在，设为第i个石头，则转移方程为——<br>$$<br>f(pos, k) = f(i, k) || f(i, k-1) || f(i, k+1) (pos-k)&gt;=0<br>$$<br>因为青蛙必须从0开始，以速度1跳到1位置然后才能继续运算。因此，f(1, 1) = true. 其他的f(1, *)=false。所以这里我们直接从1开始就好了。因为青蛙必须跳到1，然后以速度1开始往后面跳。</p>
<p>这里k最大就是石头的个数，因为最好的情况是青蛙的速度持续增加，每次都跳到石头上到最后一个，那么大小就是石头的个数-1。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上，$O(N * N)$，空间复杂度为$O(N*N)$。</p>
<p><code>Runtime: 500 ms, faster than 10.20% of C++ online submissions for Frog Jump.</code></p>
<p><code>Memory Usage: 13.2 MB, less than 50.00% of C++ online submissions for Frog Jump.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//unordered_map&lt;int, int&gt; M;</span></span><br><span class="line">        <span class="comment">//for (int i=0; i&lt;len; i++) M[stones[i]] = i;</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(len, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len + <span class="number">2</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (len &gt;= <span class="number">2</span> <span class="keyword">and</span> stones[<span class="number">1</span>] != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pos=<span class="number">2</span>; pos&lt;len; pos++) &#123;</span><br><span class="line">            <span class="comment">//for (int k=1; k&lt;=pos; k++) &#123;</span></span><br><span class="line">            <span class="comment">//    if (M.find(stones[pos]-k) == M.end()) continue;</span></span><br><span class="line">            <span class="comment">//    dp[pos][k] = dp[M[stones[pos]-k]][k-1] || dp[M[stones[pos]-k]][k] || dp[M[stones[pos]-k]][k+1];</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> prep=pos<span class="number">-1</span>; prep&gt;=<span class="number">1</span>; prep--) &#123;</span><br><span class="line">                <span class="keyword">int</span> diff = stones[pos] - stones[prep];</span><br><span class="line">                <span class="keyword">if</span> (diff &gt; pos) <span class="keyword">continue</span>;</span><br><span class="line">                dp[pos][diff] = dp[prep][diff<span class="number">-1</span>] || dp[prep][diff] || dp[prep][diff+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=len; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[len<span class="number">-1</span>][k] == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述的算法中，如果使用map来记录的话，然后用map寻找上一个，总是LTE，比递归还差。我觉得是两个原因，1是map的寻找其实第多余的，因为第pos个石头，只可能是前面某一个位置跳过来的，只需要看前面的石头就可以了，使用map多余了，但是也应该花不了太多时间啊····。2就是测试用例的问题，可能测试用例比较特殊，用递归反而比较省时间。</p>
<p>BitBrave，2020-04-09.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/09/LeetCode(377.%20Combination%20Sum%20IV)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/09/LeetCode(377.%20Combination%20Sum%20IV)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(377. Combination Sum IV)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-09 12:12:54 / 修改时间：12:53:45" itemprop="dateCreated datePublished" datetime="2020-04-09T12:12:54+08:00">2020-04-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-377-Combination-Sum-IV-题解"><a href="#LeetCode-377-Combination-Sum-IV-题解" class="headerlink" title="LeetCode(\377. Combination Sum IV)题解"></a>LeetCode(\377. Combination Sum IV)题解</h1><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">nums &#x3D; [1, 2, 3]</span><br><span class="line">target &#x3D; 4</span><br><span class="line"></span><br><span class="line">The possible combination ways are:</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">Note that different sequences are counted as different combinations.</span><br><span class="line"></span><br><span class="line">Therefore the output is 7.</span><br></pre></td></tr></table></figure>



<p><strong>Follow up:</strong><br>What if negative numbers are allowed in the given array?<br>How does it change the problem?<br>What limitation we need to add to the question to allow negative numbers?</p>
<p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/pbrother/" target="_blank" rel="noopener">@pbrother</a> for adding this problem and creating all test cases.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Medium</p>
<p>给定一个不包含重复数的正整数数组，从中选取一些整数，可以重复选取，使得其和为target，选择的顺序不同带来不同的答案，求解最后可以得到多少个这样的子数组。</p>
<p>下面我按照做题的思路逐步论述这道题。</p>
<p>这个题看到的第一时间尝试使用回溯法。设计一个递归函数返回符合target目标的所有合法序列的总数。考虑选第一个数，假设现在要选出所有的合法序列，我们选择一个数作为第一个。然后target减少，进入下一层递归，然后又从整个数组中选择一个数，再进入下一层递归···，这样因为每一层递归在同层对应的位置上选择的数都是不一样的（因为所有元素不同），所以最后得到的序列一定是不一样的。</p>
<p>结束递归就是，target小于0，或者等于0，等于0说明这一路选择的序列是合法的，ans+1即可。因此代码就很容易写了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// select</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">            helper(nums, target - n, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        helper(nums, target, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>毫无疑问，TLE了···。</p>
<p>那我们就对上面的进行优化，查看每个target，因为都是从同一个数组中选择数据。所以，我们可以记录下target的值，子问题的搜索次数。稍微修改下代码。用一个dp的vector记录target的值，初始化dp[0] = 1. 当然dp[target] &gt; 0总是。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[target] &gt; <span class="number">0</span>) <span class="keyword">return</span> dp[target];</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if (target &lt; 0) return 0; // no effect</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// select</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; target) <span class="keyword">continue</span>;</span><br><span class="line">            ans += helper(nums, target - n, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[target] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(target + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        helper(nums, target, dp);</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果还是TLE，这是因为，虽然优化了子问题的搜索方式，但是对于子问题的规模并没有变，即使查看所有的子问题（遍历一遍），查看是否已经解决了所花费的时间都还是很大。当然还有其它的优化方式，比如将数组排序，然后如果当前数大于target就可以不用再向后找了之类的。</p>
<h4 id="DP解法"><a href="#DP解法" class="headerlink" title="DP解法"></a>DP解法</h4><p>这个题其实可以使用DP解决。我们设定f(i)表示在整个数组寻找的合法的数组满足target=i的数目。那么如何来设定转移方程，即f(i)如何填充呢？</p>
<p>其实我们可以这样想，f(i)现在要选一个数作为序列的第一个，那么假如选择了nums[k]，那么剩下的target为i-nums[k]。因为序列第一个是nums[k]，加在后面的f(i-nums[k])对应的序列的前面即可，肯定是不重复的。然后我们选择另一个元素nums[p]，那么又得到一个后面的子序列个数。</p>
<p>所以我们可以填充$f(i) = \sum f(i-nums[k])\ \ (0=&lt;k&lt;n, i-nums[k]&gt;=0)$ </p>
<p>然后又同志可能会问，因为这个选择的序列是可以排列的，不同的排列是不同的序列啊，如果nums[k]不是放在第一个呢？其实这时候如果不是nums[k]在第一个，那就是别的，那就对应别的f(XX)了啊，我们一样会遍历到这个情况的。</p>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>因此改写代码如下(这里int会超限，因此改为unsigned long也可, long都不行)，时间上，$O(target * N)$，空间上，$O(target)$。</p>
<p><code>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Combination Sum IV.</code></p>
<p><code>Memory Usage: 6.5 MB, less than 100.00% of C++ online submissions for Combination Sum IV.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; dp = <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt;(target + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t=<span class="number">1</span>; t&lt;=target; ++t) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n &gt; t) <span class="keyword">continue</span>;</span><br><span class="line">                dp[t] += dp[t - n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2020-04-09.</p>
<p>注：这个题最后说如果存在负数，应该怎么改，其实如果有负数的时候，那么有可能满足target的条件有无数个。因此需要设定一个上界，如果答案数满足了上界了，就不再寻找了。此外就算遇到n&gt;t即DP代码中n&gt;target的情况，也不跳过，而是继续寻找，但是负数有可能会重复加上，因此可以判断每次加入一个负数，两个负数,····。然后后面就不再加入负数了等操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/08/LeetCode(818.%20Race%20Car)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/LeetCode(818.%20Race%20Car)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(818. Race Car)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-08 12:36:17 / 修改时间：12:36:19" itemprop="dateCreated datePublished" datetime="2020-04-08T12:36:17+08:00">2020-04-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-818-Race-Car-题解"><a href="#LeetCode-818-Race-Car-题解" class="headerlink" title="LeetCode(\818. Race Car)题解"></a>LeetCode(\818. Race Car)题解</h1><p>Your car starts at position 0 and speed +1 on an infinite number line. (Your car can go into negative positions.)</p>
<p>Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse).</p>
<p>When you get an instruction “A”, your car does the following: <code>position += speed, speed *= 2</code>.</p>
<p>When you get an instruction “R”, your car does the following: if your speed is positive then <code>speed = -1</code> , otherwise <code>speed = 1</code>. (Your position stays the same.)</p>
<p>For example, after commands “AAR”, your car goes to positions 0-&gt;1-&gt;3-&gt;3, and your speed goes to 1-&gt;2-&gt;4-&gt;-1.</p>
<p>Now for some target position, say the <strong>length</strong> of the shortest sequence of instructions to get there.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: </span><br><span class="line">target &#x3D; 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">The shortest instruction sequence is &quot;AA&quot;.</span><br><span class="line">Your position goes from 0-&gt;1-&gt;3.</span><br><span class="line">Example 2:</span><br><span class="line">Input: </span><br><span class="line">target &#x3D; 6</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">The shortest instruction sequence is &quot;AAARA&quot;.</span><br><span class="line">Your position goes from 0-&gt;1-&gt;3-&gt;7-&gt;7-&gt;6.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 10000</code>.</li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>起始时有个小车在位置0，速度为1，有个目标位置 target，是小车要到达的地方。而小车只有两种操作，第一种是加速操作，首先当前位置加上小车速度，然后小车速度乘以2。第二种是反向操作，小车位置不变，小车速度重置为单位长度，并且反向。问我们最少需要多少个操作才能到达 target。</p>
<p>本题可以使用DP解决。</p>
<p>我们首先来看下若小车一直加速的话，都能经过哪些位置，从起点开始，若小车连加五次速，位置的变化为：</p>
<p>0 -&gt; 1 -&gt; 3 -&gt; 7 -&gt; 15 -&gt; 31。</p>
<p>得出了结论，当小车从0开始连加n个速的话，其将会到达位置 2^n - 1。我们可以看出，小车越往后，位置跨度越大，那么当 target 不在这些位置上，很有可能一脚油门就开过了。</p>
<p>假设target的位置有：$2^{n-1}&lt;=target&lt;2^n$。</p>
<p>执行如下策略，小车尽可能靠近target，即走了n步之后，如果刚好就在target，则结束算法。</p>
<p>如果不在，此时有两种情况：</p>
<ol>
<li>n步之后刚刚好越过target，此时不能再向前走了（因为再向后走的话，一次增大的间距会变成2^n，如果要往回返，需要从速度1开始多走至少2^n的长度，肯定不是到target的最优路径）。这时候直接停下，然后计算返回路径。</li>
<li>n步之后，还差一步就越过target。此时不能再直接向前，我们选择停住向后走m步，并且不能往回走超过n步，理由和上述一致。(往回走n步会回到原点)。然后再停住回返，计算到target的路径。至于为什么不在n步之前就回返二次，我目前没有办法给出确定证明，只是感觉要么可以用到了n步回返代替，要么就这种方式肯定不是最优的。</li>
</ol>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上，O(targetlog(target))，空间上，O(target)。</p>
<p><code>Runtime: 4 ms, faster than 88.37% of C++ online submissions for Race Car.</code></p>
<p><code>Memory Usage: 8.9 MB, less than 33.33% of C++ online submissions for Race Car.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp = <span class="built_in">vector</span>(<span class="number">10001</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">racecar</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[target] &gt; <span class="number">0</span>) <span class="keyword">return</span> dp[target];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">floor</span>(log2(target)) + <span class="number">1</span>; <span class="comment">// 2^(n-1) &lt;= target &lt; 2^n</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (target+<span class="number">1</span> == <span class="number">1</span>&lt;&lt;n) dp[target] = n;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[target] = racecar((<span class="number">1</span>&lt;&lt;n) - <span class="number">1</span> - target) + n + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">0</span>; m&lt;n<span class="number">-1</span>; m++) &#123;</span><br><span class="line">                dp[target] = <span class="built_in">min</span>(dp[target], racecar(target - (<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>)) + (<span class="number">1</span>&lt;&lt;m)) + n + m + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-04-08.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88/" class="post-title-link" itemprop="url">机器学习概览</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 11:40:17" itemprop="dateCreated datePublished" datetime="2020-04-06T11:40:17+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-16 22:05:49" itemprop="dateModified" datetime="2020-04-16T22:05:49+08:00">2020-04-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="机器学习概览"><a href="#机器学习概览" class="headerlink" title="机器学习概览"></a>机器学习概览</h1><h2 id="派别"><a href="#派别" class="headerlink" title="派别"></a>派别</h2><p>频率派（统计机器学习），贝叶斯派（概率图模型）</p>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p>李航《统计机器学习》：频率派，感K朴决逻，支提E隐条。（讲的不深，可以当个手册）</p>
<p>周志华《机器学习》</p>
<p>《PRML》：贝叶斯派，回分神核稀，图混近采连，顺组</p>
<p>ESL：厚，百科全书类型</p>
<p>DeepLearning：“圣经”。中译版（张志华团队）</p>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>台大，林轩田，《基石》，理论，通俗易懂。《技石》，SVM讲得非常好。总体非常精彩。</p>
<p>张志华，两门课《机器学习导论》，频率派。《统计机器学习》，贝叶斯派。公式推导有点多，可能看不下去，但是能看下去是极好的。</p>
<p>NG：CS229，斯坦福课程（2017版），比Course上难一些。</p>
<p>徐亦达，概率模型系列课程（内容不多，但很深）。他的GitHub-&gt;notes上有他的全面资料和学习内容</p>
<p><strong>DL</strong>，台大，李宏毅，ML（2017），MLDS（2018）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/05/LeetCode(/1406.%20Stone%20Game%20III)%E5%91%A8%E8%B5%9B4%E9%A2%98%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/05/LeetCode(%5C1406.%20Stone%20Game%20III)%E5%91%A8%E8%B5%9B4%E9%A2%98%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(\1406. Stone Game III)周赛4题题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-05 23:04:34 / 修改时间：23:25:30" itemprop="dateCreated datePublished" datetime="2020-04-05T23:04:34+08:00">2020-04-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-1406-Stone-Game-III-周赛4题题解"><a href="#LeetCode-1406-Stone-Game-III-周赛4题题解" class="headerlink" title="LeetCode(\1406. Stone Game III)周赛4题题解"></a>LeetCode(\1406. Stone Game III)周赛4题题解</h1><p>Alice and Bob continue their games with piles of stones. There are several stones <strong>arranged in a row</strong>, and each stone has an associated value which is an integer given in the array <code>stoneValue</code>.</p>
<p>Alice and Bob take turns, with <strong>Alice</strong> starting first. On each player’s turn, that player can take <strong>1, 2 or 3 stones</strong> from the <strong>first</strong> remaining stones in the row.</p>
<p>The score of each player is the sum of values of the stones taken. The score of each player is <strong>0</strong> initially.</p>
<p>The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.</p>
<p>Assume Alice and Bob <strong>play optimally</strong>.</p>
<p>Return *”Alice”* if Alice will win, *”Bob”* if Bob will win or *”Tie”* if they end the game with the same score.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: values &#x3D; [1,2,3,7]</span><br><span class="line">Output: &quot;Bob&quot;</span><br><span class="line">Explanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: values &#x3D; [1,2,3,-9]</span><br><span class="line">Output: &quot;Alice&quot;</span><br><span class="line">Explanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.</span><br><span class="line">If Alice chooses one pile her score will be 1 and the next move Bob&#39;s score becomes 5. The next move Alice will take the pile with value &#x3D; -9 and lose.</span><br><span class="line">If Alice chooses two piles her score will be 3 and the next move Bob&#39;s score becomes 3. The next move Alice will take the pile with value &#x3D; -9 and also lose.</span><br><span class="line">Remember that both play optimally so here Alice will choose the scenario that makes her win.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: values &#x3D; [1,2,3,6]</span><br><span class="line">Output: &quot;Tie&quot;</span><br><span class="line">Explanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: values &#x3D; [1,2,3,-1,-2,-3,7]</span><br><span class="line">Output: &quot;Alice&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: values &#x3D; [-1,-2,-3]</span><br><span class="line">Output: &quot;Tie&quot;</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= values.length &lt;= 50000</code></li>
<li><code>-1000 &lt;= values[i] &lt;= 1000</code></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>有一堆宝石，排成一行，给出一行数分别表达每个宝石的价值。现在Alice和Bob轮流选一次，从左边依次向右，每次可以选1~3个石头，Alice先选。假设Alice和Bob都以最优策略选择，请问最后谁拿到的宝石价值更高，返回对应的名字。如果是平局就返回Tie。</p>
<p>这里我想了很久没想出来好的解法。真是太佩服<a href="https://leetcode.com/lee215" target="_blank" rel="noopener">lee215</a>了，简洁高效！</p>
<p>本题可以使用DP。我们设定f(i)表示宝石堆i，i+1，i+2，…，n-1中，第一个从i开始选石头的人能够赢对方多少分。而f(0)因为是Alice第一个选，因此就是Alice赢Bob的分。我们只要判断f(0)即可，大于0就是Alice胜利，小于就是Bob，等于就是平局。</p>
<p>非常地简洁。</p>
<p>因此，f(i) = max(A[i]-f(i+1), A[i]+A[i+1]-f(i+2), A[i]+A[i+1]+A[i+2]-f(i+3))，这里可以将空间优化到O(1)。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码下，时间上，O(N)，空间上，O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">stoneGameIII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = stoneValue.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i] = stoneValue[i] - dp[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; len) dp[i] = <span class="built_in">max</span>(dp[i], stoneValue[i]+stoneValue[i+<span class="number">1</span>]-dp[i+<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">2</span> &lt; len) dp[i] = <span class="built_in">max</span>(dp[i], stoneValue[i]+stoneValue[i+<span class="number">1</span>]+stoneValue[i+<span class="number">2</span>]-dp[i+<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">0</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"Alice"</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">0</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"Bob"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Tie"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化空间到O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">stoneGameIII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = stoneValue.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">4</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = stoneValue[i] - dp[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; len) dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], stoneValue[i]+stoneValue[i+<span class="number">1</span>]-dp[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">2</span> &lt; len) dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], stoneValue[i]+stoneValue[i+<span class="number">1</span>]+stoneValue[i+<span class="number">2</span>]-dp[<span class="number">3</span>]);</span><br><span class="line">            dp[<span class="number">3</span>] = dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">2</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">0</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"Alice"</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">0</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"Bob"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Tie"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-04-05.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XJ"
      src="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
  <p class="site-author-name" itemprop="name">XJ</p>
  <div class="site-description" itemprop="description">幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BitBrave, IIE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
