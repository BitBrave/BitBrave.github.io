<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:type" content="website">
<meta property="og:title" content="BitBrave">
<meta property="og:url" content="http://yoursite.com/page/37/index.html">
<meta property="og:site_name" content="BitBrave">
<meta property="og:description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XJ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/37/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>BitBrave</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BitBrave</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">IIE</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(932.%20Beautiful%20Array)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(932.%20Beautiful%20Array)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(932. Beautiful Array)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-932-Beautiful-Array-题解"><a href="#LeetCode-932-Beautiful-Array-题解" class="headerlink" title="LeetCode(932. Beautiful Array)题解"></a>LeetCode(932. Beautiful Array)题解</h1><p>For some fixed <code>N</code>, an array <code>A</code> is <em>beautiful</em> if it is a permutation of the integers <code>1, 2, ..., N</code>, such that:</p>
<p>For every <code>i &lt; j</code>, there is <strong>no</strong> <code>k</code> with <code>i &lt; k &lt; j</code> such that <code>A[k] * 2 = A[i] + A[j]</code>.</p>
<p>Given <code>N</code>, return <strong>any</strong> beautiful array <code>A</code>.  (It is guaranteed that one exists.)</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: [2,1,4,3]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: [3,1,2,5,4]</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ul>
<li><code>1 &lt;= N &lt;= 1000</code></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给出一个数N，要求返回一个由1,2,3,4,…N的数组，这个数组必须是一个漂亮数组。即，任意A[i]和A[j]之间，即i&lt;k&lt;j，都有A[i]+A[j]!=2*A[k]。</p>
<p>这个题可以使用DC的办法解决。首先假设一个数组B是漂亮数组，那么B中的元素整体加减一个元素和整体乘上除上一个数得到的数组仍然是一个漂亮数组。因为如果B[i]+B[j] != 2*B[k]，那么.</p>
<ul>
<li>B[i]+a+B[j]+a != 2*(B[k]+a)</li>
<li>B[i]*a+B[j]*a != 2*(B[k]*a)</li>
</ul>
<p>而观察可知，中间元素的两倍一定是一个偶数，因此只要保证B[i]+B[j] 等于一个奇数一定就可以满足k位置元素的要求了。</p>
<p>那么可以假设这样一个数组A，元素分别是1,2,3,…N。我们将其分成两组数，在左边分别放奇数1,3,5,7, …,一共(N+1)/2个，右边放上2,4,6,8,…一共N/2个。假设这两个数组内部是漂亮数组，那么这两个数组左右组合起来，也一定是一个漂亮数组。</p>
<p>观察左边，将所有元素+1得到2,4,6,8,…，再除二就得到一个1,2,3,4,…共(N+1)/2的和一开始一样的数组。</p>
<p>观察右边，将所有元素除二就得到一个1,2,3,4,…共N/2的和一开始一样的数组。</p>
<p>这两个数组和一开始一样，只不过规模变小，并且只要这两个数组构成了漂亮数组，左边的只需要所有元素乘2-1，右边乘2，组合在一起就是初始问题的解。</p>
<p>因此一个N的问题就变成了一个(N+1)/2和N/2的两个规模的问题。</p>
<p>这个问题可以使用递归的办法解决,代码如下，时间复杂度O(nlogn)，空间复杂度O(1).</p>
<p><code>Runtime: 16 ms, faster than 31.48% of C++ online submissions for Beautiful Array.</code></p>
<p><code>Memory Usage: 19.8 MB, less than 100.00% of C++ online submissions for Beautiful Array.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">beautifulArray</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = beautifulArray((N+<span class="number">1</span>)/<span class="number">2</span>), right = beautifulArray(N/<span class="number">2</span>), ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : left) ret.push_back(a*<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : right) ret.push_back(a*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是上述递归还是花费太多时间了因为折半的时候对于N=1,2,3这样的低阶计算了很多次，一个办法是将对应的答案存储起来，最后时间复杂度只需要O(N)，但需要O(N)的空间复杂度(1+2+4+…+N)。</p>
<p>这里还有一个优化的办法，观察数组有以下性质，假设有一个N+1的漂亮数组，现在删除掉其中的N+1，剩下的额仍旧是漂亮数组，因为如果不是的话，那么加上N+1之后也就不是了。因此推论出，一个为N的漂亮数组，可以依次删除N,N-1,N-2等数得到一个更低阶的漂亮数组。</p>
<p>因此，一个N的问题是这样增长过来的，以左边和右边数组的各自的元素长度计算来说分别是说。</p>
<ul>
<li>1,1-&gt;2,2-&gt;4,4-&gt;4,4-&gt;…-&gt;m,m。直到2*m&gt;=N.</li>
</ul>
<p>因此，这个题可以从左边为1个元素，右边为1个元素开始，逐步增加。每次增加，到达M时，都将当前数组的元素整体乘2-1作为M+1数组的左边，整体*2作为M+1的右边。知道数组长度大于等于N就停下，然后从中删除那些大于N的元素即可。</p>
<p>这样的时间复杂度O(n)，空间复杂度O(1)。（均不计算答案的空间）。代码如下。</p>
<p><code>Runtime: 4 ms, faster than 99.72% of C++ online submissions for Beautiful Array.</code></p>
<p><code>Memory Usage: 8.8 MB, less than 100.00% of C++ online submissions for Beautiful Array.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">beautifulArray</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        vector&lt;int&gt; V(&#123;1,2&#125;), ret;</span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(M &lt; N)&#123;</span><br><span class="line">            V.insert(V.<span class="built_in">end</span>(), V.<span class="built_in">begin</span>(), V.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;M; i++) V[i] = V[i] * <span class="number">2</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=M; i&lt;<span class="number">2</span>*M; i++) V[i] = V[i] * <span class="number">2</span>;</span><br><span class="line">            M *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;M; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(V[i] &lt;= N) ret.push_back(V[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2019-11-13</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(939.%20Minimum%20Area%20Rectangle)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(939.%20Minimum%20Area%20Rectangle)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(939. Minimum Area Rectangle)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-939-Minimum-Area-Rectangle-题解"><a href="#LeetCode-939-Minimum-Area-Rectangle-题解" class="headerlink" title="LeetCode(939. Minimum Area Rectangle)题解"></a>LeetCode(939. Minimum Area Rectangle)题解</h1><p>Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes.</p>
<p>If there isn’t any rectangle, return 0.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[1,3],[3,1],[3,3],[2,2]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>



<p><strong>Note</strong>:</p>
<ol>
<li><code>1 &lt;= points.length &lt;= 500</code></li>
<li><code>0 &lt;= points[i][0] &lt;= 40000</code></li>
<li><code>0 &lt;= points[i][1] &lt;= 40000</code></li>
<li>All points are distinct.</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一些二维平面上的点，计算其组成的最小矩形点，矩形的四边必须平行于X和Y轴，如果不存在就返回0.</p>
<p>这个题可以直接使用暴力枚举，但是也要注意方法。 每次选定要两个点，将其作为对角点，有了对角点之后查看另外两个点是否在数组中，如果在就记录其面积，如果不在的话就放弃这两个点，再次选择一对。这个过程中要一直记录最小的面积。</p>
<p>代码如下，时间复杂度O(N2)，空间复杂度O(n).</p>
<p><code>Runtime: 576 ms, faster than 30.14% of C++ online submissions for Minimum Area Rectangle.</code></p>
<p><code>Memory Usage: 18 MB, less than 75.00% of C++ online submissions for Minimum Area Rectangle.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAreaRect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = INT_MAX, len = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; S;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p : points)&#123;</span><br><span class="line">            S.insert(make_pair(p[<span class="number">0</span>], p[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(points[i][<span class="number">0</span>] == points[j][<span class="number">0</span>] <span class="keyword">or</span> points[i][<span class="number">1</span>] == points[j][<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(S.<span class="built_in">find</span>(make_pair(points[i][<span class="number">0</span>], points[j][<span class="number">1</span>])) == S.<span class="built_in">end</span>() <span class="keyword">or</span> S.<span class="built_in">find</span>(make_pair(points[j][<span class="number">0</span>], points[i][<span class="number">1</span>])) == S.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                ret = <span class="built_in">min</span>(ret, <span class="built_in">abs</span>((points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>]) * (points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INT_MAX == ret ? <span class="number">0</span> : ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-11-07</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(94.%20Binary%20Tree%20Inorder%20Traversal)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(94.%20Binary%20Tree%20Inorder%20Traversal)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(94. Binary Tree Inorder Traversal)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-94-Binary-Tree-Inorder-Traversal-题解"><a href="#LeetCode-94-Binary-Tree-Inorder-Traversal-题解" class="headerlink" title="LeetCode(94. Binary Tree Inorder Traversal)题解"></a>LeetCode(94. Binary Tree Inorder Traversal)题解</h1><hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用中序遍历法遍历一棵树。先左子树，再根节点，再右子树。</p>
<p>使用递归的代码如下：</p>
<p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Inorder Traversal.<br>Memory Usage: 9.2 MB, less than 54.89% of C++ online submissions for Binary Tree Inorder Traversal.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal_</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        inorderTraversal_(root-&gt;left, res);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        inorderTraversal_(root-&gt;right, res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        inorderTraversal_(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归的办法很简单，但是有没有一种不使用递归，而是迭代的方法去得到中序遍历呢。</p>
<p>可以使用栈的方式：</p>
<p>a. 遇到一个节点，访问它，然后把它压栈，并去遍历它的左子树；</p>
<p>b. 当左子树遍历结束后，打印节点值，从栈顶弹出该节点并将其指向右儿子，继续a步骤；</p>
<p>c. 当所有节点访问完即最后访问的树节点为空且栈空时，停止。</p>
<p>非递归代码如下：</p>
<p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Inorder Traversal.<br>Memory Usage: 9.1 MB, less than 67.08% of C++ online submissions for Binary Tree Inorder Traversal.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !S.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                S.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!S.empty())&#123;</span><br><span class="line">                res.push_back(S.top()-&gt;val);</span><br><span class="line">                root = S.top()-&gt;right;</span><br><span class="line">                S.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BitBrave, 2019-06-23</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(945.%20Minimum%20Increment%20to%20Make%20Array%20Unique)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(945.%20Minimum%20Increment%20to%20Make%20Array%20Unique)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(945. Minimum Increment to Make Array Unique)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-945-Minimum-Increment-to-Make-Array-Unique-题解"><a href="#LeetCode-945-Minimum-Increment-to-Make-Array-Unique-题解" class="headerlink" title="LeetCode(945. Minimum Increment to Make Array Unique)题解"></a>LeetCode(945. Minimum Increment to Make Array Unique)题解</h1><p>Given an array of integers A, a <em>move</em> consists of choosing any <code>A[i]</code>, and incrementing it by <code>1</code>.</p>
<p>Return the least number of moves to make every value in <code>A</code> unique.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:  After 1 move, the array could be [1, 2, 3].</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,1,2,1,7]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:  After 6 moves, the array could be [3, 4, 1, 2, 5, 7].</span><br><span class="line">It can be shown with 5 or less moves that it is impossible for the array to have all unique values.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>0 &lt;= A.length &lt;= 40000</code></li>
<li><code>0 &lt;= A[i] &lt; 40000</code></li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给定一个数组，对其中每次元素可以执行一个操作，即元素值+1。求使用最少的操作使得数组内的元素都不一样。</p>
<p>这个题可以使用排序，首先将所有的元素从小到大排序，然后从左到右遍历。遍历到A[i]，如果和A[i-1]一样或者比A[i]小，就表示A[i]这个数需要调整，因为我们从左到右，第一次遇到需要调整的一定是两个相同元素（因为元素是从小到大排列的），那么如果遇到相同的，我们就将后面的元素+1，尽可能执行最少的加法操作。然后再向后走如果发现A[i]比A[i-1]就表示这个数肯定重复了两次以上。那么久仍旧将A[i]调整到恰好比A[i-1]大1即可。即加A[i-1]-A[i]次即可。就这样走到最后，返回ret。</p>
<p>如何证明这个算法是正确的呢？可以这样想，如果要想使得两个数不同，那么其中任意一个数不同即可，即+1.如果三个相同的数要不同，那么其中一个数必然要加1，另一个必然要两次加1.而比如1,1,2,3,4这样五个数，可以直接将1加到5加四次，也可以1,2,3,4各自都加1，这是一样的，因为加法是可以移植的。我们这里采用的就是第二种算法。</p>
<p>代码如下，时间复杂度O(nlpgn)，空间复杂度O(1)。</p>
<p><code>Runtime: 76 ms, faster than 88.16% of C++ online submissions for Minimum Increment to Make Array Unique.</code></p>
<p><code>Memory Usage: 12 MB, less than 100.00% of C++ online submissions for Minimum Increment to Make Array Unique.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>, len = A.<span class="built_in">size</span>();</span><br><span class="line">        sort(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            ret += A[i<span class="number">-1</span>] - A[i] + <span class="number">1</span>;</span><br><span class="line">            A[i] = A[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2019-11-14</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(946.%20Validate%20Stack%20Sequences)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(946.%20Validate%20Stack%20Sequences)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(946. Validate Stack Sequences)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-946-Validate-Stack-Sequences-题解"><a href="#LeetCode-946-Validate-Stack-Sequences-题解" class="headerlink" title="LeetCode(946. Validate Stack Sequences)题解"></a>LeetCode(946. Validate Stack Sequences)题解</h1><p>Given two sequences <code>pushed</code> and <code>popped</code> <strong>with distinct values</strong>, return <code>true</code> if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We might do the following sequence:</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: 1 cannot be popped before 2.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li>
<li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li>
<li><code>pushed</code> is a permutation of <code>popped</code>.</li>
<li><code>pushed</code> and <code>popped</code> have distinct values.</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给出两个数组pushed和poped，每个数组内的元素互相之间是不相等的。现在要判断这两个数组是否可能是从一个栈的操作上得来的，即入栈的数放入pushed，出栈的数放入poped。如果是返回True，否则False。</p>
<p>这个题可以直接使用模拟实现，可以知道首先肯定是入栈，那么stack首先肯定是放入pushed，然后看poped，表示第一个出栈的，那么就在pushed数组内查找这个数字，pushed内这个数字之前的一定是入栈才能将这个数入栈，然后才能出栈。因此，将pushed内的数不断入栈，找到这个数之后，poped向后移动一个，栈就出栈一个，继续看poped下一个，如果等于pushed当前位置的，就继续向下走，不在就从上一个pushed走到的位置继续往后走，并入栈。如果走到最后，栈内为空，则表示是匹配的，返回True，否则False。</p>
<p>代码如下，时间复杂度O(n)，空间复杂度O(n)。</p>
<p><code>Runtime: 12 ms, faster than 48.89% of C++ online submissions for Validate Stack Sequences.</code></p>
<p><code>Memory Usage: 9 MB, less than 100.00% of C++ online submissions for Validate Stack Sequences.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = pushed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pushed[i] == popped[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!S.empty() &amp;&amp; S.top() == popped[j])&#123;</span><br><span class="line">                S.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> S.push(pushed[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!S.empty() &amp;&amp; S.top() == popped[j++]) S.pop();</span><br><span class="line">        <span class="keyword">return</span> S.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2019-11-06</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(948.%20Bag%20of%20Tokens)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(948.%20Bag%20of%20Tokens)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(948. Bag of Tokens)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-948-Bag-of-Tokens-题解"><a href="#LeetCode-948-Bag-of-Tokens-题解" class="headerlink" title="LeetCode(\948. Bag of Tokens)题解"></a>LeetCode(\948. Bag of Tokens)题解</h1><p>You have an initial power <code>P</code>, an initial score of <code>0</code> points, and a bag of tokens.</p>
<p>Each token can be used at most once, has a value <code>token[i]</code>, and has potentially two ways to use it.</p>
<ul>
<li>If we have at least <code>token[i]</code> power, we may play the token face up, losing <code>token[i]</code> power, and gaining <code>1</code> point.</li>
<li>If we have at least <code>1</code> point, we may play the token face down, gaining <code>token[i]</code> power, and losing <code>1</code> point.</li>
</ul>
<p>Return the largest number of points we can have after playing any number of tokens.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [100], P &#x3D; 50</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [100,200], P &#x3D; 150</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [100,200,300,400], P &#x3D; 200</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>tokens.length &lt;= 1000</code></li>
<li><code>0 &lt;= tokens[i] &lt; 10000</code></li>
<li><code>0 &lt;= P &lt; 10000</code></li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个数组，每个元素表示一个能量，同时给定一个初始能量P。现在每选中一个元素需要花费对应元素值的能力，但能得一分。或者选中一个元素花掉一分，但能得到对应元素值的能量，一个元素只能用一次。问如何能得到最多的分，返回最多的分值。</p>
<p>这个题可以使用贪心，因为我们可以这样想，我们需要尽可能得到更多的分，那就用尽可能少的能量买更多的分，因此我们用能量去买元素值低的分，同时我们也要获得更多的能量去买分。因此当发现能量不够时，我们去花费分购买最多的元素值分。在这个过程中记录最大值。可以非常简单证明这一定是最优解。因为如果有一个最优解方案不是这样得出的，那么一定可以调整成这样的方案，同时不改变最优值。</p>
<p>代码如下，时间复杂度O(nlogn), 空间复杂度O(1)。</p>
<p><code>Runtime: 8 ms, faster than 74.68% of C++ online submissions for Bag of Tokens.</code></p>
<p><code>Memory Usage: 8.7 MB, less than 66.67% of C++ online submissions for Bag of Tokens.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bagOfTokensScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tokens, <span class="keyword">int</span> P)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>, sta = <span class="number">0</span>, <span class="built_in">end</span> = tokens.<span class="built_in">size</span>() - <span class="number">1</span>, M = P, p = <span class="number">0</span>;</span><br><span class="line">        sort(tokens.<span class="built_in">begin</span>(), tokens.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(sta &lt;= <span class="built_in">end</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(M &gt;= tokens[sta])&#123;</span><br><span class="line">                M -= tokens[sta++];</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, p);</span><br><span class="line">                p--;</span><br><span class="line">                M += tokens[<span class="built_in">end</span>--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ret, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> BitBrave，2019-11-16</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(95.%20Unique%20Binary%20Search%20Trees%20II)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(95.%20Unique%20Binary%20Search%20Trees%20II)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(95. Unique Binary Search Trees II)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-95-Unique-Binary-Search-Trees-II-题解"><a href="#LeetCode-95-Unique-Binary-Search-Trees-II-题解" class="headerlink" title="LeetCode(95. Unique Binary Search Trees II)题解"></a>LeetCode(95. Unique Binary Search Trees II)题解</h1><hr>
<p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.</p>
<p>Example:</p>
<pre><code>Input: 3
Output:
[
[1,null,3,2],
[3,2,null,1],
[3,1,null,null,2],
[2,1,3],
[1,null,2,null,3]
]</code></pre><p>Explanation:<br>The above output corresponds to the 5 unique BST’s shown below:</p>
<pre><code>1         3     3      2      1
\       /     /      / \      \
3     2     1      1   3      2
/     /       \                 \
2     1         2                 3</code></pre><h2 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h2><p>给定数N，生成所有的合适的BST树。</p>
<p>如何生成树呢？可以使用类似于DP的方法。当生成以i为根节点的树的时候，左边为1<del>i-1，右边为i+1</del>n，则左边可以生成一个向量组包括1<del>i-1的BST树，右边生成一个向量组包括i+1</del>n的向量组。要组成1~n的向量组。可以将左边取出一个来，右边取出一个来，然后加入i作为根节点即可。</p>
<p>代码如下</p>
<p>Runtime: 12 ms, faster than 99.00% of C++ online submissions for Unique Binary Search Trees II.<br>Memory Usage: 17.1 MB, less than 46.89% of C++ online submissions for Unique Binary Search Trees II.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees_</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n1==n2)&#123;</span><br><span class="line">            res.push_back(<span class="keyword">new</span> TreeNode(n1));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(n1&gt;n2)&#123;</span><br><span class="line">            res.push_back(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> res;         </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; left, right;</span><br><span class="line">        <span class="keyword">int</span> llen, rlen;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n1<span class="number">-1</span>; i&lt;n2; i++)&#123;</span><br><span class="line">            left = generateTrees_(n1, i); </span><br><span class="line">            right = generateTrees_(i+<span class="number">2</span>, n2);</span><br><span class="line">            llen = left.<span class="built_in">size</span>(); </span><br><span class="line">            rlen = right.<span class="built_in">size</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>; a&lt;llen; a++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>; b&lt;rlen; b++)&#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i+<span class="number">1</span>);</span><br><span class="line">                    root-&gt;left = left[a];</span><br><span class="line">                    root-&gt;right = right[b];</span><br><span class="line">                    res.push_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;();</span><br><span class="line">        <span class="keyword">return</span> generateTrees_(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-06-23</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(951.%20Flip%20Equivalent%20Binary%20Trees)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(951.%20Flip%20Equivalent%20Binary%20Trees)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(951. Flip Equivalent Binary Trees)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-951-Flip-Equivalent-Binary-Trees-题解"><a href="#LeetCode-951-Flip-Equivalent-Binary-Trees-题解" class="headerlink" title="LeetCode(951. Flip Equivalent Binary Trees)题解"></a>LeetCode(951. Flip Equivalent Binary Trees)题解</h1><p>For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.</p>
<p>A binary tree X is <em>flip equivalent</em> to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.</p>
<p>Write a function that determines whether two binary trees are <em>flip equivalent</em>.  The trees are given by root nodes <code>root1</code> and <code>root2</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root1 &#x3D; [1,2,3,4,5,6,null,null,null,7,8], root2 &#x3D; [1,3,2,null,6,4,5,null,null,null,null,8,7]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We flipped at nodes with values 1, 3, and 5.</span><br></pre></td></tr></table></figure>

<p> <img src="https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png" alt=""></p>
<p><strong>Note:</strong></p>
<ol>
<li>Each tree will have at most <code>100</code> nodes.</li>
<li>Each value in each tree will be a unique integer in the range <code>[0, 99]</code>.</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给出两个二叉树，每个二叉树内，各个节点的值都是不一样的。现在有一种操作，选定一个节点，将节点的左右子树进行交换。问，对一些节点进行交换，是否可以将两个二叉树变成一样的（一样的结构和值）？</p>
<p>这个题是个很明显的递归问题。假设函数就是返回两个二叉树是否可以变成相同的。</p>
<ul>
<li>首先看看两个根节点是否为空，如果都为空返回True，有一个为空返回Flase。都不为空进行下一步。</li>
<li>查看根节点的值是否一样，不一样就返回False，否则进行下一步。</li>
<li>将两个节点的左子树根节点作为参数同样运行这个函数，再将右子树根节点一起作为参数放入函数。查看返回结果，如果都是True，则返回True。否则就将一个节点的左子树和另一个节点右子树根节点一起，分别放入函数，看返回值，如果都为True，返回True，否则False。</li>
</ul>
<p>代码如下，时间复杂度O(N)，空间复杂度O(1)。这里有可能会让人觉得函数在运行的时候，搜寻子树明明进行了四次调用，时间复杂度肯定高，但是可以观察到，如果到达下一层的时候，两个数值不一样，就直接返回，不会继续递归，因此函数是线性往下走的。</p>
<p><code>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Flip Equivalent Binary Trees.</code></p>
<p><code>Memory Usage: 11.6 MB, less than 100.00% of C++ online submissions for Flip Equivalent Binary Trees.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">flipEquiv</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">NULL</span> || root2 == <span class="literal">NULL</span>) <span class="keyword">return</span> root1 == <span class="literal">NULL</span> <span class="keyword">and</span> root2 == <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1-&gt;val != root2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> flipEquiv(root1-&gt;left, root2-&gt;left) <span class="keyword">and</span> flipEquiv(root1-&gt;right, root2-&gt;right) <span class="keyword">or</span> flipEquiv(root1-&gt;right, root2-&gt;left) <span class="keyword">and</span> flipEquiv(root1-&gt;left, root2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>BitBrave， 2019-11-21</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(954.%20Array%20of%20Doubled%20Pairs)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(954.%20Array%20of%20Doubled%20Pairs)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(954. Array of Doubled Pairs)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-954-Array-of-Doubled-Pairs-题解"><a href="#LeetCode-954-Array-of-Doubled-Pairs-题解" class="headerlink" title="LeetCode(954. Array of Doubled Pairs)题解"></a>LeetCode(954. Array of Doubled Pairs)题解</h1><p>Given an array of integers <code>A</code> with even length, return <code>true</code> if and only if it is possible to reorder it such that <code>A[2 * i + 1] = 2 * A[2 * i]</code> for every <code>0 &lt;= i &lt; len(A) / 2</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,3,6]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,2,6]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,-2,2,-4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,4,16,8,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>0 &lt;= A.length &lt;= 30000</code></li>
<li><code>A.length</code> is even</li>
<li><code>-100000 &lt;= A[i] &lt;= 100000</code></li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个偶数个元素的数组，判断其是否能组成一个有如下规则的数组：每个偶数位置的元素都是前面一个奇数位置元素的两倍，如果可以就返回True，否则False。</p>
<p>这个题可以使用Map或者字典解决。使用一个字典记录数组每个元素出现的元素。然后对索引值即不同的元素进行排序，小的在前面。这样查看第一个元素，因为最小的，所以只能找放在奇数位置，然后查看是否存在对应到额偶数位置的元素值，如果不存在算法就结束了。如果存在就判断这个元素值是不是比最小的值多，如果少的话表示不够配对，算法也结束返回False。反之就将这个元素值的个数减去最小值的个数，同时更新字典。这时候等于最小值已经配对完成了且只能这样配对，而接下来的问题和初始问题一致，只是问题规模变小了。因此按照这种方法就可以判断数组是否符合要求，如果走到最后都没有不能配对，算法就返回True。</p>
<p>因为要建立字典和排序，使用python方便一些。代码如下，时间复杂度O(nlogn)，空间复杂度O(n)。</p>
<p><code>Runtime: 628 ms, faster than 96.71% of Python3 online submissions for Array of Doubled Pairs.</code></p>
<p><code>Memory Usage: 15.1 MB, less than 50.00% of Python3 online submissions for Array of Doubled Pairs.</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canReorderDoubled</span><span class="params">(self, A: List[int])</span> -&gt; bool:</span></span><br><span class="line">        A = [abs(a) <span class="keyword">for</span> a <span class="keyword">in</span> A]</span><br><span class="line">        C = Counter(A)</span><br><span class="line">        L = sorted(C)</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> L:</span><br><span class="line">            <span class="keyword">if</span> C[l] == <span class="number">0</span>: <span class="keyword">continue</span> <span class="comment"># 可注释掉</span></span><br><span class="line">            <span class="keyword">if</span> C.get(<span class="number">2</span>*l, <span class="number">0</span>) &lt; C[l]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            C[<span class="number">2</span>*l] -= C[l]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>BitBrave，2019-11-28</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(957.%20Prison%20Cells%20After%20N%20Days)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(957.%20Prison%20Cells%20After%20N%20Days)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(957. Prison Cells After N Days)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-957-Prison-Cells-After-N-Days-题解"><a href="#LeetCode-957-Prison-Cells-After-N-Days-题解" class="headerlink" title="LeetCode(\957. Prison Cells After N Days)题解"></a>LeetCode(\957. Prison Cells After N Days)题解</h1><p>There are 8 prison cells in a row, and each cell is either occupied or vacant.</p>
<p>Each day, whether the cell is occupied or vacant changes according to the following rules:</p>
<ul>
<li>If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.</li>
<li>Otherwise, it becomes vacant.</li>
</ul>
<p>(Note that because the prison is a row, the first and the last cells in the row can’t have two adjacent neighbors.)</p>
<p>We describe the current state of the prison in the following way: <code>cells[i] == 1</code> if the <code>i</code>-th cell is occupied, else <code>cells[i] == 0</code>.</p>
<p>Given the initial state of the prison, return the state of the prison after <code>N</code> days (and <code>N</code> such changes described above.)</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: cells &#x3D; [0,1,0,1,1,0,0,1], N &#x3D; 7</span><br><span class="line">Output: [0,0,1,1,0,0,0,0]</span><br><span class="line">Explanation: </span><br><span class="line">The following table summarizes the state of the prison on each day:</span><br><span class="line">Day 0: [0, 1, 0, 1, 1, 0, 0, 1]</span><br><span class="line">Day 1: [0, 1, 1, 0, 0, 0, 0, 0]</span><br><span class="line">Day 2: [0, 0, 0, 0, 1, 1, 1, 0]</span><br><span class="line">Day 3: [0, 1, 1, 0, 0, 1, 0, 0]</span><br><span class="line">Day 4: [0, 0, 0, 0, 0, 1, 0, 0]</span><br><span class="line">Day 5: [0, 1, 1, 1, 0, 1, 0, 0]</span><br><span class="line">Day 6: [0, 0, 1, 0, 1, 1, 0, 0]</span><br><span class="line">Day 7: [0, 0, 1, 1, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: cells &#x3D; [1,0,0,1,0,0,1,0], N &#x3D; 1000000000</span><br><span class="line">Output: [0,0,1,1,1,1,1,0]</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>cells.length == 8</code></li>
<li><code>cells[i]</code> is in <code>{0, 1}</code></li>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给有一个长度为8由0和1组成的数组，对其中的数，一个数如果两边都是1或者0，那么就将其变为1，否则变为0。求这样计算若干次之后序列是多少。</p>
<p>这个题肯定不能用纯暴力的办法，因为变化的次数上限是10亿次，肯定会TLE。我们可以分析，一个长度为8的01数组，那么总的组合最多只有256种，而且因为序列变化的缘故，首尾必然变换之后一直保持为0.那就必然只有最多32+1为33种，因此序列一定会以一个序列重复出现，N一定是可以缩减的。</p>
<p>我们使用一个Map记录变幻的序列的所处的变换次数，后边每次变换都判断这个序列是否出现过，没有就记录，出现了就表示后面的都是重复的，直接就可以通过求余得到最后答案。</p>
<p>代码如下，时间复杂度O(1)，空间复杂度O(1)。</p>
<p><code>Runtime: 4 ms, faster than 89.38% of C++ online submissions for Prison Cells After N Days.</code></p>
<p><code>Memory Usage: 9.8 MB, less than 7.14% of C++ online submissions for Prison Cells After N Days.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cells)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c : cells) res += (<span class="keyword">char</span>)(c + <span class="number">48</span>);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prisonAfterNDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cells, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> cells;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">V</span><span class="params">(<span class="number">33</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">8</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        M[toString(cells)] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) V[<span class="number">0</span>][i] = cells[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">1</span>; n&lt;=<span class="built_in">min</span>(<span class="number">33</span>, N); n++) &#123;</span><br><span class="line">            pos = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (V[n<span class="number">-1</span>][i<span class="number">-1</span>] == V[n<span class="number">-1</span>][i+<span class="number">1</span>]) V[n][i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> V[n][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            V[n][<span class="number">0</span>] = V[n][<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string</span> tmp = toString(V[n]);</span><br><span class="line">            <span class="keyword">if</span> (M.<span class="built_in">find</span>(tmp) == M.<span class="built_in">end</span>()) M[tmp] = n;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pos = (N - M[tmp]) % (n - M[tmp]) + M[tmp];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> V[pos];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave， 2020-01-07</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/36/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/36/">36</a><span class="page-number current">37</span><a class="page-number" href="/page/38/">38</a><a class="page-number" href="/page/39/">39</a><a class="extend next" rel="next" href="/page/38/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">XJ</p>
  <div class="site-description" itemprop="description">幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">386</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XJ</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
