<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:type" content="website">
<meta property="og:title" content="BitBrave">
<meta property="og:url" content="http://yoursite.com/page/36/index.html">
<meta property="og:site_name" content="BitBrave">
<meta property="og:description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XJ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/36/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>BitBrave</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BitBrave</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">IIE</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(948.%20Bag%20of%20Tokens)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(948.%20Bag%20of%20Tokens)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(948. Bag of Tokens)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-948-Bag-of-Tokens-题解"><a href="#LeetCode-948-Bag-of-Tokens-题解" class="headerlink" title="LeetCode(\948. Bag of Tokens)题解"></a>LeetCode(\948. Bag of Tokens)题解</h1><p>You have an initial power <code>P</code>, an initial score of <code>0</code> points, and a bag of tokens.</p>
<p>Each token can be used at most once, has a value <code>token[i]</code>, and has potentially two ways to use it.</p>
<ul>
<li>If we have at least <code>token[i]</code> power, we may play the token face up, losing <code>token[i]</code> power, and gaining <code>1</code> point.</li>
<li>If we have at least <code>1</code> point, we may play the token face down, gaining <code>token[i]</code> power, and losing <code>1</code> point.</li>
</ul>
<p>Return the largest number of points we can have after playing any number of tokens.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [100], P &#x3D; 50</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [100,200], P &#x3D; 150</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [100,200,300,400], P &#x3D; 200</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>tokens.length &lt;= 1000</code></li>
<li><code>0 &lt;= tokens[i] &lt; 10000</code></li>
<li><code>0 &lt;= P &lt; 10000</code></li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个数组，每个元素表示一个能量，同时给定一个初始能量P。现在每选中一个元素需要花费对应元素值的能力，但能得一分。或者选中一个元素花掉一分，但能得到对应元素值的能量，一个元素只能用一次。问如何能得到最多的分，返回最多的分值。</p>
<p>这个题可以使用贪心，因为我们可以这样想，我们需要尽可能得到更多的分，那就用尽可能少的能量买更多的分，因此我们用能量去买元素值低的分，同时我们也要获得更多的能量去买分。因此当发现能量不够时，我们去花费分购买最多的元素值分。在这个过程中记录最大值。可以非常简单证明这一定是最优解。因为如果有一个最优解方案不是这样得出的，那么一定可以调整成这样的方案，同时不改变最优值。</p>
<p>代码如下，时间复杂度O(nlogn), 空间复杂度O(1)。</p>
<p><code>Runtime: 8 ms, faster than 74.68% of C++ online submissions for Bag of Tokens.</code></p>
<p><code>Memory Usage: 8.7 MB, less than 66.67% of C++ online submissions for Bag of Tokens.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bagOfTokensScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tokens, <span class="keyword">int</span> P)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>, sta = <span class="number">0</span>, <span class="built_in">end</span> = tokens.<span class="built_in">size</span>() - <span class="number">1</span>, M = P, p = <span class="number">0</span>;</span><br><span class="line">        sort(tokens.<span class="built_in">begin</span>(), tokens.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(sta &lt;= <span class="built_in">end</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(M &gt;= tokens[sta])&#123;</span><br><span class="line">                M -= tokens[sta++];</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, p);</span><br><span class="line">                p--;</span><br><span class="line">                M += tokens[<span class="built_in">end</span>--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ret, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> BitBrave，2019-11-16</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(95.%20Unique%20Binary%20Search%20Trees%20II)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(95.%20Unique%20Binary%20Search%20Trees%20II)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(95. Unique Binary Search Trees II)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-95-Unique-Binary-Search-Trees-II-题解"><a href="#LeetCode-95-Unique-Binary-Search-Trees-II-题解" class="headerlink" title="LeetCode(95. Unique Binary Search Trees II)题解"></a>LeetCode(95. Unique Binary Search Trees II)题解</h1><hr>
<p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.</p>
<p>Example:</p>
<pre><code>Input: 3
Output:
[
[1,null,3,2],
[3,2,null,1],
[3,1,null,null,2],
[2,1,3],
[1,null,2,null,3]
]</code></pre><p>Explanation:<br>The above output corresponds to the 5 unique BST’s shown below:</p>
<pre><code>1         3     3      2      1
\       /     /      / \      \
3     2     1      1   3      2
/     /       \                 \
2     1         2                 3</code></pre><h2 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h2><p>给定数N，生成所有的合适的BST树。</p>
<p>如何生成树呢？可以使用类似于DP的方法。当生成以i为根节点的树的时候，左边为1<del>i-1，右边为i+1</del>n，则左边可以生成一个向量组包括1<del>i-1的BST树，右边生成一个向量组包括i+1</del>n的向量组。要组成1~n的向量组。可以将左边取出一个来，右边取出一个来，然后加入i作为根节点即可。</p>
<p>代码如下</p>
<p>Runtime: 12 ms, faster than 99.00% of C++ online submissions for Unique Binary Search Trees II.<br>Memory Usage: 17.1 MB, less than 46.89% of C++ online submissions for Unique Binary Search Trees II.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees_</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n1==n2)&#123;</span><br><span class="line">            res.push_back(<span class="keyword">new</span> TreeNode(n1));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(n1&gt;n2)&#123;</span><br><span class="line">            res.push_back(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> res;         </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; left, right;</span><br><span class="line">        <span class="keyword">int</span> llen, rlen;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n1<span class="number">-1</span>; i&lt;n2; i++)&#123;</span><br><span class="line">            left = generateTrees_(n1, i); </span><br><span class="line">            right = generateTrees_(i+<span class="number">2</span>, n2);</span><br><span class="line">            llen = left.<span class="built_in">size</span>(); </span><br><span class="line">            rlen = right.<span class="built_in">size</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>; a&lt;llen; a++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>; b&lt;rlen; b++)&#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i+<span class="number">1</span>);</span><br><span class="line">                    root-&gt;left = left[a];</span><br><span class="line">                    root-&gt;right = right[b];</span><br><span class="line">                    res.push_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;();</span><br><span class="line">        <span class="keyword">return</span> generateTrees_(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-06-23</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(951.%20Flip%20Equivalent%20Binary%20Trees)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(951.%20Flip%20Equivalent%20Binary%20Trees)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(951. Flip Equivalent Binary Trees)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-951-Flip-Equivalent-Binary-Trees-题解"><a href="#LeetCode-951-Flip-Equivalent-Binary-Trees-题解" class="headerlink" title="LeetCode(951. Flip Equivalent Binary Trees)题解"></a>LeetCode(951. Flip Equivalent Binary Trees)题解</h1><p>For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.</p>
<p>A binary tree X is <em>flip equivalent</em> to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.</p>
<p>Write a function that determines whether two binary trees are <em>flip equivalent</em>.  The trees are given by root nodes <code>root1</code> and <code>root2</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root1 &#x3D; [1,2,3,4,5,6,null,null,null,7,8], root2 &#x3D; [1,3,2,null,6,4,5,null,null,null,null,8,7]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We flipped at nodes with values 1, 3, and 5.</span><br></pre></td></tr></table></figure>

<p> <img src="https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png" alt=""></p>
<p><strong>Note:</strong></p>
<ol>
<li>Each tree will have at most <code>100</code> nodes.</li>
<li>Each value in each tree will be a unique integer in the range <code>[0, 99]</code>.</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给出两个二叉树，每个二叉树内，各个节点的值都是不一样的。现在有一种操作，选定一个节点，将节点的左右子树进行交换。问，对一些节点进行交换，是否可以将两个二叉树变成一样的（一样的结构和值）？</p>
<p>这个题是个很明显的递归问题。假设函数就是返回两个二叉树是否可以变成相同的。</p>
<ul>
<li>首先看看两个根节点是否为空，如果都为空返回True，有一个为空返回Flase。都不为空进行下一步。</li>
<li>查看根节点的值是否一样，不一样就返回False，否则进行下一步。</li>
<li>将两个节点的左子树根节点作为参数同样运行这个函数，再将右子树根节点一起作为参数放入函数。查看返回结果，如果都是True，则返回True。否则就将一个节点的左子树和另一个节点右子树根节点一起，分别放入函数，看返回值，如果都为True，返回True，否则False。</li>
</ul>
<p>代码如下，时间复杂度O(N)，空间复杂度O(1)。这里有可能会让人觉得函数在运行的时候，搜寻子树明明进行了四次调用，时间复杂度肯定高，但是可以观察到，如果到达下一层的时候，两个数值不一样，就直接返回，不会继续递归，因此函数是线性往下走的。</p>
<p><code>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Flip Equivalent Binary Trees.</code></p>
<p><code>Memory Usage: 11.6 MB, less than 100.00% of C++ online submissions for Flip Equivalent Binary Trees.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">flipEquiv</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">NULL</span> || root2 == <span class="literal">NULL</span>) <span class="keyword">return</span> root1 == <span class="literal">NULL</span> <span class="keyword">and</span> root2 == <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1-&gt;val != root2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> flipEquiv(root1-&gt;left, root2-&gt;left) <span class="keyword">and</span> flipEquiv(root1-&gt;right, root2-&gt;right) <span class="keyword">or</span> flipEquiv(root1-&gt;right, root2-&gt;left) <span class="keyword">and</span> flipEquiv(root1-&gt;left, root2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>BitBrave， 2019-11-21</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(954.%20Array%20of%20Doubled%20Pairs)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(954.%20Array%20of%20Doubled%20Pairs)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(954. Array of Doubled Pairs)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-954-Array-of-Doubled-Pairs-题解"><a href="#LeetCode-954-Array-of-Doubled-Pairs-题解" class="headerlink" title="LeetCode(954. Array of Doubled Pairs)题解"></a>LeetCode(954. Array of Doubled Pairs)题解</h1><p>Given an array of integers <code>A</code> with even length, return <code>true</code> if and only if it is possible to reorder it such that <code>A[2 * i + 1] = 2 * A[2 * i]</code> for every <code>0 &lt;= i &lt; len(A) / 2</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,3,6]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,2,6]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,-2,2,-4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,4,16,8,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>0 &lt;= A.length &lt;= 30000</code></li>
<li><code>A.length</code> is even</li>
<li><code>-100000 &lt;= A[i] &lt;= 100000</code></li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个偶数个元素的数组，判断其是否能组成一个有如下规则的数组：每个偶数位置的元素都是前面一个奇数位置元素的两倍，如果可以就返回True，否则False。</p>
<p>这个题可以使用Map或者字典解决。使用一个字典记录数组每个元素出现的元素。然后对索引值即不同的元素进行排序，小的在前面。这样查看第一个元素，因为最小的，所以只能找放在奇数位置，然后查看是否存在对应到额偶数位置的元素值，如果不存在算法就结束了。如果存在就判断这个元素值是不是比最小的值多，如果少的话表示不够配对，算法也结束返回False。反之就将这个元素值的个数减去最小值的个数，同时更新字典。这时候等于最小值已经配对完成了且只能这样配对，而接下来的问题和初始问题一致，只是问题规模变小了。因此按照这种方法就可以判断数组是否符合要求，如果走到最后都没有不能配对，算法就返回True。</p>
<p>因为要建立字典和排序，使用python方便一些。代码如下，时间复杂度O(nlogn)，空间复杂度O(n)。</p>
<p><code>Runtime: 628 ms, faster than 96.71% of Python3 online submissions for Array of Doubled Pairs.</code></p>
<p><code>Memory Usage: 15.1 MB, less than 50.00% of Python3 online submissions for Array of Doubled Pairs.</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canReorderDoubled</span><span class="params">(self, A: List[int])</span> -&gt; bool:</span></span><br><span class="line">        A = [abs(a) <span class="keyword">for</span> a <span class="keyword">in</span> A]</span><br><span class="line">        C = Counter(A)</span><br><span class="line">        L = sorted(C)</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> L:</span><br><span class="line">            <span class="keyword">if</span> C[l] == <span class="number">0</span>: <span class="keyword">continue</span> <span class="comment"># 可注释掉</span></span><br><span class="line">            <span class="keyword">if</span> C.get(<span class="number">2</span>*l, <span class="number">0</span>) &lt; C[l]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            C[<span class="number">2</span>*l] -= C[l]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>BitBrave，2019-11-28</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(957.%20Prison%20Cells%20After%20N%20Days)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(957.%20Prison%20Cells%20After%20N%20Days)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(957. Prison Cells After N Days)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-957-Prison-Cells-After-N-Days-题解"><a href="#LeetCode-957-Prison-Cells-After-N-Days-题解" class="headerlink" title="LeetCode(\957. Prison Cells After N Days)题解"></a>LeetCode(\957. Prison Cells After N Days)题解</h1><p>There are 8 prison cells in a row, and each cell is either occupied or vacant.</p>
<p>Each day, whether the cell is occupied or vacant changes according to the following rules:</p>
<ul>
<li>If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.</li>
<li>Otherwise, it becomes vacant.</li>
</ul>
<p>(Note that because the prison is a row, the first and the last cells in the row can’t have two adjacent neighbors.)</p>
<p>We describe the current state of the prison in the following way: <code>cells[i] == 1</code> if the <code>i</code>-th cell is occupied, else <code>cells[i] == 0</code>.</p>
<p>Given the initial state of the prison, return the state of the prison after <code>N</code> days (and <code>N</code> such changes described above.)</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: cells &#x3D; [0,1,0,1,1,0,0,1], N &#x3D; 7</span><br><span class="line">Output: [0,0,1,1,0,0,0,0]</span><br><span class="line">Explanation: </span><br><span class="line">The following table summarizes the state of the prison on each day:</span><br><span class="line">Day 0: [0, 1, 0, 1, 1, 0, 0, 1]</span><br><span class="line">Day 1: [0, 1, 1, 0, 0, 0, 0, 0]</span><br><span class="line">Day 2: [0, 0, 0, 0, 1, 1, 1, 0]</span><br><span class="line">Day 3: [0, 1, 1, 0, 0, 1, 0, 0]</span><br><span class="line">Day 4: [0, 0, 0, 0, 0, 1, 0, 0]</span><br><span class="line">Day 5: [0, 1, 1, 1, 0, 1, 0, 0]</span><br><span class="line">Day 6: [0, 0, 1, 0, 1, 1, 0, 0]</span><br><span class="line">Day 7: [0, 0, 1, 1, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: cells &#x3D; [1,0,0,1,0,0,1,0], N &#x3D; 1000000000</span><br><span class="line">Output: [0,0,1,1,1,1,1,0]</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>cells.length == 8</code></li>
<li><code>cells[i]</code> is in <code>{0, 1}</code></li>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给有一个长度为8由0和1组成的数组，对其中的数，一个数如果两边都是1或者0，那么就将其变为1，否则变为0。求这样计算若干次之后序列是多少。</p>
<p>这个题肯定不能用纯暴力的办法，因为变化的次数上限是10亿次，肯定会TLE。我们可以分析，一个长度为8的01数组，那么总的组合最多只有256种，而且因为序列变化的缘故，首尾必然变换之后一直保持为0.那就必然只有最多32+1为33种，因此序列一定会以一个序列重复出现，N一定是可以缩减的。</p>
<p>我们使用一个Map记录变幻的序列的所处的变换次数，后边每次变换都判断这个序列是否出现过，没有就记录，出现了就表示后面的都是重复的，直接就可以通过求余得到最后答案。</p>
<p>代码如下，时间复杂度O(1)，空间复杂度O(1)。</p>
<p><code>Runtime: 4 ms, faster than 89.38% of C++ online submissions for Prison Cells After N Days.</code></p>
<p><code>Memory Usage: 9.8 MB, less than 7.14% of C++ online submissions for Prison Cells After N Days.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cells)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c : cells) res += (<span class="keyword">char</span>)(c + <span class="number">48</span>);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prisonAfterNDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cells, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> cells;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">V</span><span class="params">(<span class="number">33</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">8</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        M[toString(cells)] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) V[<span class="number">0</span>][i] = cells[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">1</span>; n&lt;=<span class="built_in">min</span>(<span class="number">33</span>, N); n++) &#123;</span><br><span class="line">            pos = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (V[n<span class="number">-1</span>][i<span class="number">-1</span>] == V[n<span class="number">-1</span>][i+<span class="number">1</span>]) V[n][i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> V[n][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            V[n][<span class="number">0</span>] = V[n][<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string</span> tmp = toString(V[n]);</span><br><span class="line">            <span class="keyword">if</span> (M.<span class="built_in">find</span>(tmp) == M.<span class="built_in">end</span>()) M[tmp] = n;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pos = (N - M[tmp]) % (n - M[tmp]) + M[tmp];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> V[pos];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave， 2020-01-07</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(958.%20Check%20Completeness%20of%20a%20Binary%20Tree)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(958.%20Check%20Completeness%20of%20a%20Binary%20Tree)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(958. Check Completeness of a Binary Tree)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-958-Check-Completeness-of-a-Binary-Tree-题解"><a href="#LeetCode-958-Check-Completeness-of-a-Binary-Tree-题解" class="headerlink" title="LeetCode(958. Check Completeness of a Binary Tree)题解"></a>LeetCode(958. Check Completeness of a Binary Tree)题解</h1><p>Given a binary tree, determine if it is a <em>complete binary tree</em>.</p>
<p><strong>Definition of a complete binary tree from Wikipedia:</strong><br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Every level before the last is full (ie. levels with node-values &#123;1&#125; and &#123;2, 3&#125;), and all nodes in the last level (&#123;4, 5, 6&#125;) are as far left as possible.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-2.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,null,7]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The node with value 7 isn&#39;t as far left as possible.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The tree will have between 1 and 100 nodes.</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给出一个二叉树，判断是不是完全二叉树（除了最后一层，每一层的二叉树节点是满的，最后一层的节点也是从左到右一次排列的）。</p>
<p>这个题可以使用BFS队列的方式做，也可以使用DFS的方式。因为考虑到空间复杂度的缘故，可以使用DFS。</p>
<p>设定一个Height函数，返回一个整数值，表示二叉树的最大深度，同时返回二叉树的类型type，如果是满二叉树就是0，完全二叉树就是1，否则就是-1。那么输入一个节点，返回以这个节点为根节点的二叉树的深度，至于Type的值，看左右子树的Type值，如果有一个-1或者两边的深度相差超过1就直接返回-1。否则就看深度，如果两边深度一样，那么左边必须是满二叉树，此时直接将右边的type值赋值给当前节点的type即可否则就是-1.如果右边深度少1，那么右子树必须是满二叉树，此时左边如果是满二叉树（Type=0）或者完全二叉树（Type=1），那么当前节点就是一个完全二叉树（Type=1），否则就返回-1.</p>
<p>代码如下，时间复杂度O(N)，空间复杂度O(1)。</p>
<p><code>Runtime: 4 ms, faster than 88.77% of C++ online submissions for Check Completeness of a Binary Tree.</code></p>
<p><code>Memory Usage: 9.9 MB, less than 100.00% of C++ online submissions for Check Completeness of a Binary Tree.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            type = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        type = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> typel, typer;</span><br><span class="line">        <span class="keyword">int</span> l = Height(root-&gt;left, typel), r = Height(root-&gt;right, typer);</span><br><span class="line">        <span class="keyword">if</span>(l == r) type = (typel==<span class="number">0</span>) ? typer : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l == r + <span class="number">1</span>) type = (typer==<span class="number">0</span> <span class="keyword">and</span> typel+<span class="number">1</span>&gt;<span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        Height(root, type);</span><br><span class="line">        <span class="keyword">return</span> type != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>BitBrave，2019-11-22</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(96.%20Unique%20Binary%20Search%20Trees)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(96.%20Unique%20Binary%20Search%20Trees)/" class="post-title-link" itemprop="url">LeetCode(96. Unique Binary Search Trees)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-96-Unique-Binary-Search-Trees-题解"><a href="#LeetCode-96-Unique-Binary-Search-Trees-题解" class="headerlink" title="LeetCode(96. Unique Binary Search Trees)题解"></a>LeetCode(96. Unique Binary Search Trees)题解</h1><hr>
<pre><code>Given n, how many structurally unique BST&apos;s (binary search trees) that store values 1 ... n?

Example:

Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST&apos;s:

    1         3     3      2      1
    \       /     /      / \      \
    3     2     1      1   3      2
    /     /       \                 \
    2     1         2                 3</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个数n，求出可以存储值1-n的BST的树的数目。</p>
<p>思路很简单，可以也只能使用DP解决。用一个数组D，size为n的其中D[i]表示从1-i+1字符的可以存储的BST树多少。那么可以想象一下，一个BST有i个字符，一开始加入i+1字符，放在之前的一个树的根节点，之前的树的值都比这个数小，因此在左子树上。那么这时候有一共有D[i]种，然后将其左子树中移动一个最大的数过来到根节点上，对应的右节点肯定就是加入的i+1字符。这时候有D[i-1]<em>D[0]种，再次移动剩下的左子树中最大的到根节点上，则有D[i-2]</em>D[1]种。</p>
<p>因此，最优子结构性质为：</p>
<p>D[0] = 1; D[1] = 2</p>
<p>D[i] = D[i-1] + D[i-2]<em>D[0] + D[i-3]*D[1] + D[i-4]</em> D[2] + … + D[0]*D[i-2] + D[i-1]</p>
<p>具体代码如下：</p>
<p>Runtime: 4 ms, faster than 78.43% of C++ online submissions for Unique Binary Search Trees.<br>Memory Usage: 8.4 MB, less than 21.66% of C++ online submissions for Unique Binary Search Trees.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = i<span class="number">-2</span>;</span><br><span class="line">            res[i] = <span class="number">2</span>*res[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(c--&gt;=<span class="number">0</span>) res[i] += res[c+<span class="number">1</span>] * res[i<span class="number">-3</span>-c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-06-22</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(969.%20Pancake%20Sorting)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(969.%20Pancake%20Sorting)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(969. Pancake Sorting)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-969-Pancake-Sorting-题解"><a href="#LeetCode-969-Pancake-Sorting-题解" class="headerlink" title="LeetCode(\969. Pancake Sorting)题解"></a>LeetCode(\969. Pancake Sorting)题解</h1><p>Given an array <code>A</code>, we can perform a <em>pancake flip</em>: We choose some positive integer <code>**k** &lt;= A.length</code>, then reverse the order of the first <strong>k</strong> elements of <code>A</code>. We want to perform zero or more pancake flips (doing them one after another in succession) to sort the array <code>A</code>.</p>
<p>Return the k-values corresponding to a sequence of pancake flips that sort <code>A</code>. Any valid answer that sorts the array within <code>10 * A.length</code> flips will be judged as correct.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,4,1]</span><br><span class="line">Output: [4,2,4,3]</span><br><span class="line">Explanation: </span><br><span class="line">We perform 4 pancake flips, with k values 4, 2, 4, and 3.</span><br><span class="line">Starting state: A &#x3D; [3, 2, 4, 1]</span><br><span class="line">After 1st flip (k&#x3D;4): A &#x3D; [1, 4, 2, 3]</span><br><span class="line">After 2nd flip (k&#x3D;2): A &#x3D; [4, 1, 2, 3]</span><br><span class="line">After 3rd flip (k&#x3D;4): A &#x3D; [3, 2, 1, 4]</span><br><span class="line">After 4th flip (k&#x3D;3): A &#x3D; [1, 2, 3, 4], which is sorted.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The input is already sorted, so there is no need to flip anything.</span><br><span class="line">Note that other answers, such as [3, 3], would also be accepted.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>A[i]</code> is a permutation of <code>[1, 2, ..., A.length]</code></li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个由1到N组成的乱序的一维数组，现在有一个煎饼的翻转办法，每次可以选择前K个数翻转，请给出一种翻转次数在10*N次内的办法，将数组变为升序。返回这个办法中每次选择的K值。</p>
<p>这个分析一下就可以想到，我每次找到当前数组中最大的数，选择这个位置及之前的数进行翻转，将其翻转到第一个位置，然后再翻转整个序列，就将最大的数翻转到最后面。后续的操作就不再管这个数，将倒数第二大的数翻转到第一个后再翻转整个序列-1的长度，以此类推我们最多翻转2*N-1次即可。</p>
<p>代码如下，时间复杂度为O(n2)。每次翻转花费O(n)时间，一共翻转n次，空间复杂度O(1)。</p>
<p><code>Runtime: 8 ms, faster than 64.27% of C++ online submissions for Pancake Sorting.</code></p>
<p><code>Memory Usage: 8.5 MB, less than 100.00% of C++ online submissions for Pancake Sorting.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> K, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;K; i++, K--) &#123;</span><br><span class="line">            swap(A[i], A[K]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pancakeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n=A.<span class="built_in">size</span>(); n&gt;<span class="number">0</span>; n--) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (A[i] != n) i++;</span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ret.push_back(i + <span class="number">1</span>);</span><br><span class="line">            ret.push_back(n);</span><br><span class="line">            flip(i, A);</span><br><span class="line">            flip(n - <span class="number">1</span>, A);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-01-08.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(97.%20Interleaving%20String)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(97.%20Interleaving%20String)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(97. Interleaving String)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-97-Interleaving-String-题解"><a href="#LeetCode-97-Interleaving-String-题解" class="headerlink" title="LeetCode(97. Interleaving String)题解"></a>LeetCode(97. Interleaving String)题解</h1><hr>
<p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>Example 1:</p>
<pre><code>Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;
Output: true
Example 2:

Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;
Output: false</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>给出三个字符串，判断第三个字符串是不是可以由前两个字符串交叉而成。字符的顺序不能乱。</p>
<p>方法很简单。首先是判断前两个字符串的字符个数和必须和第三个一样。否则肯定不匹配。</p>
<p>然后可以使用DP的办法，建立一个DP数组D，D[i][j]表示s1的前i+1个字符和s2的前j+1个字符是否和s3的前i+j+2个字符相配。然后直接做就可以了。</p>
<p>代码如下：</p>
<p>Runtime: 56 ms, faster than 5.97% of C++ online submissions for Interleaving String.<br>Memory Usage: 8.5 MB, less than 66.33% of C++ online submissions for Interleaving String.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l1 = s1.<span class="built_in">size</span>(), l2 = s2.<span class="built_in">size</span>(), l3 = s3.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(l3 == <span class="number">0</span>) <span class="keyword">return</span> l1+l2 == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="number">0</span>) <span class="keyword">return</span> s2 == s3;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="number">0</span>) <span class="keyword">return</span> s1 == s3;</span><br><span class="line">        <span class="keyword">if</span>(l1+l2 != l3) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">DP</span><span class="params">(l1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(l2+<span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        DP[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;l3; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 &gt;= k+<span class="number">1</span> &amp;&amp; s1[k] == s3[k]) DP[k+<span class="number">1</span>][<span class="number">0</span>] = DP[k][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(l2 &gt;= k+<span class="number">1</span> &amp;&amp; s2[k] == s3[k]) DP[<span class="number">0</span>][k+<span class="number">1</span>] = DP[<span class="number">0</span>][k];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; (i&lt;=l1) &amp;&amp; (i&lt;k+<span class="number">1</span>); i++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=k+<span class="number">1</span>-i; j&lt;=l2; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s1[i<span class="number">-1</span>] != s3[k] &amp;&amp; s2[j<span class="number">-1</span>] != s3[k])&#123;</span><br><span class="line">                        DP[i][j] = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s3[k])&#123;</span><br><span class="line">                        DP[i][j] = DP[i<span class="number">-1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s2[j<span class="number">-1</span>] == s3[k])&#123;</span><br><span class="line">                        DP[i][j] = DP[i][j] == <span class="literal">true</span> ? <span class="literal">true</span> : DP[i][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DP[l1][l2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实还有一种更方便的办法，首先将s1与s3比较，删除s3中与s1相同的字符（一一对应，s1的一个字符在s3中只删一次），然后最后如果s1不为空就表示不匹配，为空就判断剩下的字符串s3是不是等于s2，等于则匹配，否则不匹配。(这是错误的想法)</p>
<p>BitBrave, 2019-06-23</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/LeetCode(973.%20K%20Closest%20Points%20to%20Origin)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/LeetCode(973.%20K%20Closest%20Points%20to%20Origin)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(973. K Closest Points to Origin)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-24 18:05:21" itemprop="dateCreated datePublished" datetime="2020-01-24T18:05:21+08:00">2020-01-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-973-K-Closest-Points-to-Origin-题解"><a href="#LeetCode-973-K-Closest-Points-to-Origin-题解" class="headerlink" title="LeetCode(973. K Closest Points to Origin)题解"></a>LeetCode(973. K Closest Points to Origin)题解</h1><p>We have a list of <code>points</code> on the plane.  Find the <code>K</code> closest points to the origin <code>(0, 0)</code>.</p>
<p>(Here, the distance between two points on a plane is the Euclidean distance.)</p>
<p>You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[1,3],[-2,2]], K &#x3D; 1</span><br><span class="line">Output: [[-2,2]]</span><br><span class="line">Explanation: </span><br><span class="line">The distance between (1, 3) and the origin is sqrt(10).</span><br><span class="line">The distance between (-2, 2) and the origin is sqrt(8).</span><br><span class="line">Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.</span><br><span class="line">We only want the closest K &#x3D; 1 points from the origin, so the answer is just [[-2,2]].</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[3,3],[5,-1],[-2,4]], K &#x3D; 2</span><br><span class="line">Output: [[3,3],[-2,4]]</span><br><span class="line">(The answer [[-2,4],[3,3]] would also be accepted.)</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li>
<li><code>-10000 &lt; points[i][0] &lt; 10000</code></li>
<li><code>-10000 &lt; points[i][1] &lt; 10000</code></li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一系列点，求出其里原点最近的K个点。（距离为欧几里得距离）</p>
<p>这个最简单的方式就是将所有点按照欧几里得距离进行排序，然后选取前K个即可。</p>
<p>这样时间复杂度为O(NlogN)，空间复杂度O(1)，代码如下。</p>
<p><code>Runtime: 852 ms, faster than 6.33% of C++ online submissions for K Closest Points to Origin.</code></p>
<p><code>Memory Usage: 189.1 MB, less than 10.94% of C++ online submissions for K Closest Points to Origin.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>]*a[<span class="number">0</span>]+a[<span class="number">1</span>]*a[<span class="number">1</span>] &lt; b[<span class="number">0</span>]*b[<span class="number">0</span>]+b[<span class="number">1</span>]*b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">kClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        sort(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(points.<span class="built_in">begin</span>(), points.<span class="built_in">begin</span>()+K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这样明显不是最优的，因为其实只需要前K个，而我们将所有的元素都进行了排序。因此我们可以使用Heap的方式，维护一个最大堆，然后遍历每一个坐标，在堆内元素少于K的时候，直接将点入堆，如果达到了K就判断坐标和堆顶元素的距离大小，如果小于堆顶元素就入堆，然后pop出最大堆，否则就放弃这个坐标。最后堆内的K个元素就是题目的解。</p>
<p>代码如下，时间复杂度O(NlogK)，空间复杂度O(K)。</p>
<p><code>Runtime: 496 ms, faster than 12.29% of C++ online submissions for K Closest Points to Origin.</code></p>
<p><code>Memory Usage: 103.5 MB, less than 14.06% of C++ online submissions for K Closest Points to Origin.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>]*a[<span class="number">0</span>]+a[<span class="number">1</span>]*a[<span class="number">1</span>] &lt; b[<span class="number">0</span>]*b[<span class="number">0</span>]+b[<span class="number">1</span>]*b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">kClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ret</span><span class="params">(&#123;points[<span class="number">0</span>]&#125;)</span></span>;</span><br><span class="line">        make_heap(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>, len = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k == K <span class="keyword">and</span> cmp(ret[<span class="number">0</span>], points[i])) <span class="keyword">continue</span>;</span><br><span class="line">            ret.push_back(points[i]);</span><br><span class="line">            k++;</span><br><span class="line">            push_heap(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>(), cmp);</span><br><span class="line">            <span class="keyword">if</span>(k &gt; K)&#123;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;"dayul"&lt;&lt;ret[0][1]&lt;&lt;endl;</span></span><br><span class="line">                pop_heap(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>(), cmp);</span><br><span class="line">                ret.pop_back();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>BitBrave，2019-11-26</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/35/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><span class="page-number current">36</span><a class="page-number" href="/page/37/">37</a><a class="page-number" href="/page/38/">38</a><a class="extend next" rel="next" href="/page/37/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">XJ</p>
  <div class="site-description" itemprop="description">幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">371</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XJ</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
