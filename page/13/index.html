<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:type" content="website">
<meta property="og:title" content="BitBrave">
<meta property="og:url" content="http://yoursite.com/page/13/index.html">
<meta property="og:site_name" content="BitBrave">
<meta property="og:description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="高级会所私人订制">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>BitBrave</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7e6d55cf2fa14e729703953237f65413";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BitBrave</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">IIE</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/25/LeetCode(99.%20Recover%20Binary%20Search%20Tree)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="高级会所私人订制">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/25/LeetCode(99.%20Recover%20Binary%20Search%20Tree)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(99. Recover Binary Search Tree)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-25 20:47:09" itemprop="dateCreated datePublished" datetime="2019-06-25T20:47:09+08:00">2019-06-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-99-Recover-Binary-Search-Tree-题解"><a href="#LeetCode-99-Recover-Binary-Search-Tree-题解" class="headerlink" title="LeetCode(99. Recover Binary Search Tree)题解"></a>LeetCode(99. Recover Binary Search Tree)题解</h1><hr>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p>Example 1:</p>
<pre><code>Input: [1,3,null,null,2]

1
/
3
 \
  2

Output: [3,1,null,null,2]

3
/
1
\
2</code></pre><p>Example 2:</p>
<pre><code>Input: [3,1,4,null,null,2]

 3
/ \
1   4
/
2

Output: [2,1,4,null,null,3]

  2
 / \
1   4
    /
    3</code></pre><p>Follow up:</p>
<pre><code>A solution using O(n) space is pretty straight forward.
Could you devise a constant space solution?</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给出一个BST树，其中有两个值交换了位置导致出错。需要在O(n)的时间内，O(1)的空间下纠正这个错误。</p>
<p>因为题目保证了只有两个值被交换，因此只要找出两处不和谐的地方，然后判断一下就可以了。可以利用中序遍历法（一个正确的BST的中序遍历下是递增的）找出局部降序点</p>
<p>使用函数从root节点出发，寻找局部降序点。</p>
<p>注意局部降序点有两种情况，一种是两个相邻的点交换了位置如（3，5，4）只有4和5交换，一种是不相邻的两个点交换了位置（3，8，5，6，7，4，9）8和4交换了位置。第一个的局部降序点是5，4。需要交换4和5。第二个的降序点是8，5和7，4，需要交换8和4.</p>
<p>因此，在使用函数寻找降序点的时候. 使用两个指针，首先找到第一个降序点，记录当前节点和上一个节点，如第一个记录4和5。然后继续寻找第二个。如果找到了第二个，就把之前记录的当前节点换成现在的当前节点。然后返回。如果找不到，表示是相邻的交换。直接返回即可。</p>
<p>代码如下：</p>
<p>Runtime: 16 ms, faster than 98.67% of C++ online submissions for Recover Binary Search Tree.<br>Memory Usage: 17.7 MB, less than 80.93% of C++ online submissions for Recover Binary Search Tree.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    TreeNode* back = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* fore = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* last = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(last != <span class="literal">NULL</span> &amp;&amp; last-&gt;val &gt; root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(back == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                back = last;</span><br><span class="line">                fore = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> fore = root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        last = root;</span><br><span class="line">        </span><br><span class="line">        inorder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(back != <span class="literal">NULL</span>) swap(back-&gt;val, fore-&gt;val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-06-25</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/24/LeetCode(76.%20Minimum%20Window%20Substring)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="高级会所私人订制">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/24/LeetCode(76.%20Minimum%20Window%20Substring)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(76. Minimum Window Substring)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-24 16:34:30" itemprop="dateCreated datePublished" datetime="2019-06-24T16:34:30+08:00">2019-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-76-Minimum-Window-Substring-题解"><a href="#LeetCode-76-Minimum-Window-Substring-题解" class="headerlink" title="LeetCode(76. Minimum Window Substring)题解"></a>LeetCode(76. Minimum Window Substring)题解</h1><hr>
<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>Example:</p>
<pre><code>Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;
Output: &quot;BANC&quot;</code></pre><p>Note:</p>
<pre><code>If there is no such window in S that covers all characters in T, return the empty string &quot;&quot;.
If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给两个字符串S和T，判断字符串S内包含T的最小的子字符串，并返回。如果不包含返回“”。</p>
<p>可以使用双指针的办法做到O(n)的时间复杂度。<br>首先建立两个map，MS和MP，分别记录S内和T内各个字符的数目</p>
<p>然后采用如下规则更新left和right。初始化left=right=0，从左到右遍历S。</p>
<p>查看遍历的字符是否在T内并且MT[S[right]]&gt;0，在就MT[S[right]]–，对应的记录T的个数的变量tcount–,然后right++，重复上述过程，直到tcount=0。表示此时left和right之间的S的子串包含了所有的T。</p>
<p>然后正式施行双指针法。重新用整个T更新MT，用left和right之间的字符更新MS，用scount = right-left+1。用一个begin和end记录最窄的S内包含T的子字符串。查看S[left]是否在T内（MT[S[left]]&gt;0），不在的话就直接left++。</p>
<p>如果在的话，就将MS[S[left]]–,然后left++，scount–;此时查看left和right之间是否满足T(tcount&lt;=scount; MT[S[left-1]]&lt;=MS[S[left]])。如果满足就更新begin和end。如果不满足表示当前left和right之间的数是不能覆盖T的。这时候就将right++，并进行操作scount++，MS[S[right]]++。直到满足覆盖T的条件。再更新begin和end。</p>
<p>当right到达最后，在此要求right++时，就直接返回。或者left&gt;=right时，也直接返回。最后返回S[begin,end]之间的字符即可。</p>
<p>同时因为给出的题目内是字母或者ASCLL字符。所以可以直接使用一个vector[128]的数组，这样也很方便。我偷懒就使用了这样的方式。</p>
<p>代码如下：</p>
<p>Runtime: 8 ms, faster than 97.89% of C++ online submissions for Minimum Window Substring.<br>Memory Usage: 10.2 MB, less than 42.93% of C++ online submissions for Minimum Window Substring.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">""</span> || t==<span class="string">""</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> tcount = t.<span class="built_in">size</span>(), slen = s.<span class="built_in">size</span>(), tlen = t.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>, <span class="built_in">begin</span> = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">        vector&lt;int&gt; MS(128, 0), MT(128, 0);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tlen; i++) MT[t[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(tcount&gt;<span class="number">0</span> &amp;&amp; right&lt;slen)&#123;</span><br><span class="line">            <span class="keyword">if</span>(MT[s[right]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                MT[s[right]]--;</span><br><span class="line">                tcount--;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tcount&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">end</span> = --right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tlen; i++) MT[t[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right; i++) MS[s[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;slen)&#123;</span><br><span class="line">            <span class="keyword">if</span>(MT[s[left]]==<span class="number">0</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(right-left&lt;<span class="built_in">end</span>-<span class="built_in">begin</span>)&#123;</span><br><span class="line">                    <span class="built_in">begin</span> = left; <span class="built_in">end</span> = right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            MS[s[left]]--;</span><br><span class="line">            <span class="keyword">while</span>(MS[s[left]]&lt;MT[s[left]] &amp;&amp; right+<span class="number">1</span> &lt; slen) MS[s[++right]]++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(MS[s[left]]&lt;MT[s[left]]) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(right-left&lt;<span class="built_in">end</span>-<span class="built_in">begin</span>)&#123;</span><br><span class="line">                <span class="built_in">begin</span> = left; <span class="built_in">end</span> = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(<span class="built_in">begin</span>, <span class="built_in">end</span>-<span class="built_in">begin</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-06-24</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/23/LeetCode(97.%20Interleaving%20String)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="高级会所私人订制">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/23/LeetCode(97.%20Interleaving%20String)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(97. Interleaving String)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-23 17:25:58" itemprop="dateCreated datePublished" datetime="2019-06-23T17:25:58+08:00">2019-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-97-Interleaving-String-题解"><a href="#LeetCode-97-Interleaving-String-题解" class="headerlink" title="LeetCode(97. Interleaving String)题解"></a>LeetCode(97. Interleaving String)题解</h1><hr>
<p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>Example 1:</p>
<pre><code>Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;
Output: true
Example 2:

Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;
Output: false</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>给出三个字符串，判断第三个字符串是不是可以由前两个字符串交叉而成。字符的顺序不能乱。</p>
<p>方法很简单。首先是判断前两个字符串的字符个数和必须和第三个一样。否则肯定不匹配。</p>
<p>然后可以使用DP的办法，建立一个DP数组D，D[i][j]表示s1的前i+1个字符和s2的前j+1个字符是否和s3的前i+j+2个字符相配。然后直接做就可以了。</p>
<p>代码如下：</p>
<p>Runtime: 56 ms, faster than 5.97% of C++ online submissions for Interleaving String.<br>Memory Usage: 8.5 MB, less than 66.33% of C++ online submissions for Interleaving String.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l1 = s1.<span class="built_in">size</span>(), l2 = s2.<span class="built_in">size</span>(), l3 = s3.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(l3 == <span class="number">0</span>) <span class="keyword">return</span> l1+l2 == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="number">0</span>) <span class="keyword">return</span> s2 == s3;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="number">0</span>) <span class="keyword">return</span> s1 == s3;</span><br><span class="line">        <span class="keyword">if</span>(l1+l2 != l3) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">DP</span><span class="params">(l1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(l2+<span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        DP[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;l3; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 &gt;= k+<span class="number">1</span> &amp;&amp; s1[k] == s3[k]) DP[k+<span class="number">1</span>][<span class="number">0</span>] = DP[k][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(l2 &gt;= k+<span class="number">1</span> &amp;&amp; s2[k] == s3[k]) DP[<span class="number">0</span>][k+<span class="number">1</span>] = DP[<span class="number">0</span>][k];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; (i&lt;=l1) &amp;&amp; (i&lt;k+<span class="number">1</span>); i++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=k+<span class="number">1</span>-i; j&lt;=l2; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s1[i<span class="number">-1</span>] != s3[k] &amp;&amp; s2[j<span class="number">-1</span>] != s3[k])&#123;</span><br><span class="line">                        DP[i][j] = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s3[k])&#123;</span><br><span class="line">                        DP[i][j] = DP[i<span class="number">-1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s2[j<span class="number">-1</span>] == s3[k])&#123;</span><br><span class="line">                        DP[i][j] = DP[i][j] == <span class="literal">true</span> ? <span class="literal">true</span> : DP[i][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DP[l1][l2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实还有一种更方便的办法，首先将s1与s3比较，删除s3中与s1相同的字符（一一对应，s1的一个字符在s3中只删一次），然后最后如果s1不为空就表示不匹配，为空就判断剩下的字符串s3是不是等于s2，等于则匹配，否则不匹配。(这是错误的想法)</p>
<p>BitBrave, 2019-06-23</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/23/LeetCode(95.%20Unique%20Binary%20Search%20Trees%20II)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="高级会所私人订制">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/23/LeetCode(95.%20Unique%20Binary%20Search%20Trees%20II)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(95. Unique Binary Search Trees II)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-06-23 15:48:02 / 修改时间：15:48:03" itemprop="dateCreated datePublished" datetime="2019-06-23T15:48:02+08:00">2019-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-95-Unique-Binary-Search-Trees-II-题解"><a href="#LeetCode-95-Unique-Binary-Search-Trees-II-题解" class="headerlink" title="LeetCode(95. Unique Binary Search Trees II)题解"></a>LeetCode(95. Unique Binary Search Trees II)题解</h1><hr>
<p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.</p>
<p>Example:</p>
<pre><code>Input: 3
Output:
[
[1,null,3,2],
[3,2,null,1],
[3,1,null,null,2],
[2,1,3],
[1,null,2,null,3]
]</code></pre><p>Explanation:<br>The above output corresponds to the 5 unique BST’s shown below:</p>
<pre><code>1         3     3      2      1
\       /     /      / \      \
3     2     1      1   3      2
/     /       \                 \
2     1         2                 3</code></pre><h2 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h2><p>给定数N，生成所有的合适的BST树。</p>
<p>如何生成树呢？可以使用类似于DP的方法。当生成以i为根节点的树的时候，左边为1<del>i-1，右边为i+1</del>n，则左边可以生成一个向量组包括1<del>i-1的BST树，右边生成一个向量组包括i+1</del>n的向量组。要组成1~n的向量组。可以将左边取出一个来，右边取出一个来，然后加入i作为根节点即可。</p>
<p>代码如下</p>
<p>Runtime: 12 ms, faster than 99.00% of C++ online submissions for Unique Binary Search Trees II.<br>Memory Usage: 17.1 MB, less than 46.89% of C++ online submissions for Unique Binary Search Trees II.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees_</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n1==n2)&#123;</span><br><span class="line">            res.push_back(<span class="keyword">new</span> TreeNode(n1));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(n1&gt;n2)&#123;</span><br><span class="line">            res.push_back(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> res;         </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; left, right;</span><br><span class="line">        <span class="keyword">int</span> llen, rlen;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n1<span class="number">-1</span>; i&lt;n2; i++)&#123;</span><br><span class="line">            left = generateTrees_(n1, i); </span><br><span class="line">            right = generateTrees_(i+<span class="number">2</span>, n2);</span><br><span class="line">            llen = left.<span class="built_in">size</span>(); </span><br><span class="line">            rlen = right.<span class="built_in">size</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>; a&lt;llen; a++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>; b&lt;rlen; b++)&#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i+<span class="number">1</span>);</span><br><span class="line">                    root-&gt;left = left[a];</span><br><span class="line">                    root-&gt;right = right[b];</span><br><span class="line">                    res.push_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;();</span><br><span class="line">        <span class="keyword">return</span> generateTrees_(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-06-23</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/23/LeetCode(92.%20Reverse%20Linked%20List%20II)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="高级会所私人订制">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/23/LeetCode(92.%20Reverse%20Linked%20List%20II)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(92. Reverse Linked List II)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-23 14:43:17" itemprop="dateCreated datePublished" datetime="2019-06-23T14:43:17+08:00">2019-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-92-Reverse-Linked-List-II-题解"><a href="#LeetCode-92-Reverse-Linked-List-II-题解" class="headerlink" title="LeetCode(92. Reverse Linked List II)题解"></a>LeetCode(92. Reverse Linked List II)题解</h1><hr>
<p>Reverse a linked list from position m to n. Do it in one-pass.</p>
<p>Note: 1 ≤ m ≤ n ≤ length of list.</p>
<p>Example:</p>
<pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>一次遍历的过程中，将一个链表的从m到n位置之间的链表进行反转。</p>
<p>可以使用一个for循环的办法，用一个数C记录遍历到的位置。在C开始的时候返回的正常的节点下一个指针，在C在m和n之中的时候开始进行反向。</p>
<p>具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == n) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">        ListNode *fore = head, *back = head, *Fore = <span class="literal">NULL</span>, *h;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(c &lt; m)&#123;</span><br><span class="line">            Fore = fore;</span><br><span class="line">            fore = fore-&gt;next;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        back = fore-&gt;next;</span><br><span class="line">        h = fore;</span><br><span class="line">        <span class="keyword">while</span>(c &lt; n)&#123;</span><br><span class="line">            fore-&gt;next = back-&gt;next;</span><br><span class="line">            back-&gt;next = h;</span><br><span class="line">            h = back;</span><br><span class="line">            back = fore-&gt;next;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Fore == <span class="literal">NULL</span>) <span class="keyword">return</span> h;</span><br><span class="line">        </span><br><span class="line">        Fore-&gt;next = h;</span><br><span class="line">        <span class="keyword">return</span> head; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-06-23</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/23/LeetCode(94.%20Binary%20Tree%20Inorder%20Traversal)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="高级会所私人订制">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/23/LeetCode(94.%20Binary%20Tree%20Inorder%20Traversal)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(94. Binary Tree Inorder Traversal)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-23 13:36:14" itemprop="dateCreated datePublished" datetime="2019-06-23T13:36:14+08:00">2019-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-94-Binary-Tree-Inorder-Traversal-题解"><a href="#LeetCode-94-Binary-Tree-Inorder-Traversal-题解" class="headerlink" title="LeetCode(94. Binary Tree Inorder Traversal)题解"></a>LeetCode(94. Binary Tree Inorder Traversal)题解</h1><hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用中序遍历法遍历一棵树。先左子树，再根节点，再右子树。</p>
<p>使用递归的代码如下：</p>
<p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Inorder Traversal.<br>Memory Usage: 9.2 MB, less than 54.89% of C++ online submissions for Binary Tree Inorder Traversal.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal_</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        inorderTraversal_(root-&gt;left, res);</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        inorderTraversal_(root-&gt;right, res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        inorderTraversal_(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归的办法很简单，但是有没有一种不使用递归，而是迭代的方法去得到中序遍历呢。</p>
<p>可以使用栈的方式：</p>
<p>a. 遇到一个节点，访问它，然后把它压栈，并去遍历它的左子树；</p>
<p>b. 当左子树遍历结束后，打印节点值，从栈顶弹出该节点并将其指向右儿子，继续a步骤；</p>
<p>c. 当所有节点访问完即最后访问的树节点为空且栈空时，停止。</p>
<p>非递归代码如下：</p>
<p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Inorder Traversal.<br>Memory Usage: 9.1 MB, less than 67.08% of C++ online submissions for Binary Tree Inorder Traversal.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !S.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                S.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!S.empty())&#123;</span><br><span class="line">                res.push_back(S.top()-&gt;val);</span><br><span class="line">                root = S.top()-&gt;right;</span><br><span class="line">                S.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BitBrave, 2019-06-23</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/22/LeetCode(85.%20Maximal%20Rectangle)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="高级会所私人订制">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/22/LeetCode(85.%20Maximal%20Rectangle)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(85. Maximal Rectangle)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-22 17:42:45" itemprop="dateCreated datePublished" datetime="2019-06-22T17:42:45+08:00">2019-06-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-85-Maximal-Rectangle-题解"><a href="#LeetCode-85-Maximal-Rectangle-题解" class="headerlink" title="LeetCode(85. Maximal Rectangle)题解"></a>LeetCode(85. Maximal Rectangle)题解</h1><hr>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>
<p>Example:</p>
<pre><code>Input:
[
[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],
[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],
[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],
[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]
]
Output: 6</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给出一个矩阵，里面有的为1有的为0，求出全部为1的公共矩阵最大面积。</p>
<p>实在是想不出来。于是网上搜了搜解法，这里给各位大佬跪了。</p>
<p><a href="https://www.cnblogs.com/lupx/archive/2015/10/20/leetcode-85.html" target="_blank" rel="noopener">详细解答</a></p>
<p>上述的帖子内，DP的left和right的解释有些问题，因为会无法处理像漏斗状的1的形状的面积。改进如下：</p>
<h3 id="DP-理论时间复杂度O-n2-，空间复杂度O-n-。"><a href="#DP-理论时间复杂度O-n2-，空间复杂度O-n-。" class="headerlink" title="[DP]理论时间复杂度O(n2)，空间复杂度O(n)。"></a>[DP]理论时间复杂度O(n2)，空间复杂度O(n)。</h3><p>这个并不算是常规普通的DP，他用了三个数组，然后每次按行遍历。height记录遍历到当前行上时，每一列的1的个数（必须到当前行时1连续的数目，比如如果当前行的对应列的值为0，那么height记录为0），left记录遍历到当前行时对应列的值在所有行中从0列到当前位置的最后一个第一次遇到的1的位置。right记录遍历到当前行时对应列的值在所有行中从最后一列到当前位置的最后一个第一次遇到的0的位置。</p>
<p>一行遍历完成后，计算height[j]*(right[j]-left[j])的最大值记录即可。</p>
<p>这里left和right的赋值需要斟酌，在计算时，如果查到对应的height为0，即当前遇到了0，那么之前的左边界右边界就全部作废了。将设置left[j] = 0; right[j] = COL;意味着一切重新开始。(我真是优秀)</p>
<p>代码如下：</p>
<p>Runtime: 20 ms, faster than 95.62% of C++ online submissions for Maximal Rectangle.<br>Memory Usage: 10.4 MB, less than 96.17% of C++ online submissions for Maximal Rectangle.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>(), col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, leftBound, rightBound = <span class="number">0</span>;</span><br><span class="line">        vector&lt;int&gt; height(col, 0), left(col, 0), right(col, col);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">            leftBound = <span class="number">0</span>;</span><br><span class="line">            rightBound = col;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="built_in">height</span>[j]++;</span><br><span class="line">                    left[j] = <span class="built_in">max</span>(left[j], leftBound);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">height</span>[j] = <span class="number">0</span>;</span><br><span class="line">                    left[j] = <span class="number">0</span>; right[j] = col;</span><br><span class="line">                    leftBound = j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=col<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">'1'</span>) right[j] = <span class="built_in">min</span>(right[j], rightBound);</span><br><span class="line">                <span class="keyword">else</span> rightBound = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=col<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) res = <span class="built_in">max</span>(res, <span class="built_in">height</span>[j] * (right[j] - left[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="递增栈法-，时间复杂度O-n2-，空间复杂度O-n-。"><a href="#递增栈法-，时间复杂度O-n2-，空间复杂度O-n-。" class="headerlink" title="[递增栈法]，时间复杂度O(n2)，空间复杂度O(n)。"></a>[递增栈法]，时间复杂度O(n2)，空间复杂度O(n)。</h3><p>这一题跟84题放一块是有道理。如果只看一行的话，这其实就是一个简化版的84题，可以直接使用84题的解法。</p>
<p>因此，还是按行遍历，同样使用height数组记录遍历到当前行时每一列在当前连续的1的个数，然后使用84题的解法即可。</p>
<p>代码如下(速度稍慢，因为有入栈出栈)：</p>
<p>Runtime: 24 ms, faster than 84.22% of C++ online submissions for Maximal Rectangle.<br>Memory Usage: 13 MB, less than 8.15% of C++ online submissions for Maximal Rectangle.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//84</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">height</span>.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, len = <span class="built_in">height</span>.<span class="built_in">size</span>(), tmp;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.empty() || <span class="built_in">height</span>[s.top()]&lt;=<span class="built_in">height</span>[i]) s.push(i);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tmp = s.top(); s.pop();</span><br><span class="line">                res = <span class="built_in">max</span>(res, <span class="built_in">height</span>[tmp]*(s.empty() ? i : i - s.top() - <span class="number">1</span>));</span><br><span class="line">                i--;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//85</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>(), col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">height</span><span class="params">(col, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;row; i++)&#123;            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">'1'</span>) <span class="built_in">height</span>[j]++;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">height</span>[j] = <span class="number">0</span>;       </span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, largestRectangleArea(<span class="built_in">height</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BItBrave，2019-06-22</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/22/LeetCode(93.%20Restore%20IP%20Addresses)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="高级会所私人订制">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/22/LeetCode(93.%20Restore%20IP%20Addresses)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(93. Restore IP Addresses)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-22 15:32:24" itemprop="dateCreated datePublished" datetime="2019-06-22T15:32:24+08:00">2019-06-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-93-Restore-IP-Addresses-题解"><a href="#LeetCode-93-Restore-IP-Addresses-题解" class="headerlink" title="LeetCode(93. Restore IP Addresses)题解"></a>LeetCode(93. Restore IP Addresses)题解</h1><hr>
<p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p>Example:</p>
<pre><code>Input: &quot;25525511135&quot;
Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个字符串，将其转换为对应的IP地址。</p>
<p>思路很简单，IP地址的四个值都不能大于255.四个值不长。直接暴力枚举就可以了。用一个函数，遍历字符串，看看在符合符合情况下能不能选完所有的字符数字。首先选一个数，然后选两个，最多三个，因为四个以上的肯定大于255了。如果选到最后可以遍历完字符串，就直接存储下来，否则放弃。</p>
<p>具体代码如下：</p>
<p>Runtime: 4 ms, faster than 86.40% of C++ online submissions for Restore IP Addresses.<br>Memory Usage: 9 MB, less than 18.74% of C++ online submissions for Restore IP Addresses.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IpAddresses</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> sta, <span class="keyword">int</span> len, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res, <span class="built_in">string</span> tmp1, <span class="keyword">int</span> <span class="built_in">point</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">point</span>&gt;=<span class="number">4</span> &amp;&amp; sta&lt;len) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sta&gt;=len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">point</span>==<span class="number">4</span>) res.push_back(tmp1.substr(<span class="number">0</span>, tmp1.<span class="built_in">size</span>()<span class="number">-1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> tmp = tmp1;</span><br><span class="line">        tmp += s[sta];</span><br><span class="line">        tmp += <span class="string">'.'</span>;</span><br><span class="line">        IpAddresses(s, sta+<span class="number">1</span>, len, res, tmp, <span class="built_in">point</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(s[sta]==<span class="string">'0'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sta+<span class="number">1</span>&lt;len)&#123;</span><br><span class="line">            tmp = tmp1 + s[sta];</span><br><span class="line">            tmp += s[sta+<span class="number">1</span>];</span><br><span class="line">            tmp += <span class="string">'.'</span>;</span><br><span class="line">            IpAddresses(s, sta+<span class="number">2</span>, len, res, tmp, <span class="built_in">point</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sta+<span class="number">2</span>&lt;len &amp;&amp; (((s[sta]-<span class="string">'0'</span>)*<span class="number">100</span>+(s[sta+<span class="number">1</span>]-<span class="string">'0'</span>)*<span class="number">10</span>+s[sta+<span class="number">2</span>]-<span class="string">'0'</span>)&lt;<span class="number">256</span>))&#123;</span><br><span class="line">            tmp = tmp1 + s[sta];</span><br><span class="line">            tmp += s[sta+<span class="number">1</span>];</span><br><span class="line">            tmp += s[sta+<span class="number">2</span>];</span><br><span class="line">            tmp += <span class="string">'.'</span>;</span><br><span class="line">            IpAddresses(s, sta+<span class="number">3</span>, len, res, tmp, <span class="built_in">point</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">restoreIpAddresses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">12</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        IpAddresses(s, <span class="number">0</span>, len, res, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-06-22</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/22/LeetCode(96.%20Unique%20Binary%20Search%20Trees)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="高级会所私人订制">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/22/LeetCode(96.%20Unique%20Binary%20Search%20Trees)/" class="post-title-link" itemprop="url">LeetCode(96. Unique Binary Search Trees)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-06-22 14:49:04 / 修改时间：14:52:13" itemprop="dateCreated datePublished" datetime="2019-06-22T14:49:04+08:00">2019-06-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-96-Unique-Binary-Search-Trees-题解"><a href="#LeetCode-96-Unique-Binary-Search-Trees-题解" class="headerlink" title="LeetCode(96. Unique Binary Search Trees)题解"></a>LeetCode(96. Unique Binary Search Trees)题解</h1><hr>
<pre><code>Given n, how many structurally unique BST&apos;s (binary search trees) that store values 1 ... n?

Example:

Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST&apos;s:

    1         3     3      2      1
    \       /     /      / \      \
    3     2     1      1   3      2
    /     /       \                 \
    2     1         2                 3</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个数n，求出可以存储值1-n的BST的树的数目。</p>
<p>思路很简单，可以也只能使用DP解决。用一个数组D，size为n的其中D[i]表示从1-i+1字符的可以存储的BST树多少。那么可以想象一下，一个BST有i个字符，一开始加入i+1字符，放在之前的一个树的根节点，之前的树的值都比这个数小，因此在左子树上。那么这时候有一共有D[i]种，然后将其左子树中移动一个最大的数过来到根节点上，对应的右节点肯定就是加入的i+1字符。这时候有D[i-1]<em>D[0]种，再次移动剩下的左子树中最大的到根节点上，则有D[i-2]</em>D[1]种。</p>
<p>因此，最优子结构性质为：</p>
<p>D[0] = 1; D[1] = 2</p>
<p>D[i] = D[i-1] + D[i-2]<em>D[0] + D[i-3]*D[1] + D[i-4]</em> D[2] + … + D[0]*D[i-2] + D[i-1]</p>
<p>具体代码如下：</p>
<p>Runtime: 4 ms, faster than 78.43% of C++ online submissions for Unique Binary Search Trees.<br>Memory Usage: 8.4 MB, less than 21.66% of C++ online submissions for Unique Binary Search Trees.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = i<span class="number">-2</span>;</span><br><span class="line">            res[i] = <span class="number">2</span>*res[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(c--&gt;=<span class="number">0</span>) res[i] += res[c+<span class="number">1</span>] * res[i<span class="number">-3</span>-c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-06-22</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/21/LeetCode(90.%20Subsets%20II)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="高级会所私人订制">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/21/LeetCode(90.%20Subsets%20II)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(90. Subsets II)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-21 16:59:09" itemprop="dateCreated datePublished" datetime="2019-06-21T16:59:09+08:00">2019-06-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-90-Subsets-II-题解"><a href="#LeetCode-90-Subsets-II-题解" class="headerlink" title="LeetCode(90. Subsets II)题解"></a>LeetCode(90. Subsets II)题解</h1><hr>
<p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>Example:</p>
<p>Input: [1,2,2]<br>Output:<br>    [<br>        [2],<br>        [1],<br>        [1,2,2],<br>        [2,2],<br>        [1,2],<br>        []<br>    ]</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>给一个有重复数的数组集合，求出其所有的子集，子集不能有重复。</p>
<p>可以将数组先排序。然后使用递归的办法，对于每个数，有加入或者不加入之分。而如果有重复的话，就有加入一次，加入两次，加入多次之分。递归时判断一下即可。</p>
<p>代码如下：</p>
<p>Runtime: 8 ms, faster than 92.10% of C++ online submissions for Subsets II.<br>Memory Usage: 18.2 MB, less than 5.00% of C++ online submissions for Subsets II.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subsetsWithDup_</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> sta, <span class="keyword">int</span> len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sta == len)&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = sta + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&lt;len &amp;&amp; nums[sta] == nums[n]) n++;</span><br><span class="line">        </span><br><span class="line">        subsetsWithDup_(nums, n, len, tmp, res);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=sta; i&lt;n; i++)&#123;</span><br><span class="line">            tmp.push_back(nums[sta]);</span><br><span class="line">            subsetsWithDup_(nums, n, len, tmp, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        subsetsWithDup_(nums, <span class="number">0</span>, len, tmp, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2019-06-21</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="高级会所私人订制"
      src="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
  <p class="site-author-name" itemprop="name">高级会所私人订制</p>
  <div class="site-description" itemprop="description">幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">207</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BitBrave, IIE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
