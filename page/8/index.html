<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:type" content="website">
<meta property="og:title" content="BitBrave">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="BitBrave">
<meta property="og:description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XJ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>BitBrave</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BitBrave</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">IIE</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/LeetCode(757.%20Set%20Intersection%20Size%20At%20Least%20Two)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/LeetCode(757.%20Set%20Intersection%20Size%20At%20Least%20Two)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(757. Set Intersection Size At Least Two)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-20 23:56:24" itemprop="dateCreated datePublished" datetime="2020-03-20T23:56:24+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-23 23:42:52" itemprop="dateModified" datetime="2020-03-23T23:42:52+08:00">2020-03-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-757-Set-Intersection-Size-At-Least-Two-题解"><a href="#LeetCode-757-Set-Intersection-Size-At-Least-Two-题解" class="headerlink" title="LeetCode(\757. Set Intersection Size At Least Two)题解"></a>LeetCode(\757. Set Intersection Size At Least Two)题解</h1><p>An integer interval <code>[a, b]</code> (for integers <code>a &lt; b</code>) is a set of all consecutive integers from <code>a</code> to <code>b</code>, including <code>a</code> and <code>b</code>.</p>
<p>Find the minimum size of a set S such that for every integer interval A in <code>intervals</code>, the intersection of S with A has size at least 2.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1, 3], [1, 4], [2, 5], [3, 5]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Consider the set S &#x3D; &#123;2, 3, 4&#125;.  For each interval, there are at least 2 elements from S in the interval.</span><br><span class="line">Also, there isn&#39;t a smaller size set that fulfills the above condition.</span><br><span class="line">Thus, we output the size of this set, which is 3.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1, 2], [2, 3], [2, 4], [4, 5]]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">An example of a minimum sized set is &#123;1, 2, 3, 4, 5&#125;.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li><code>intervals</code> will have length in range <code>[1, 3000]</code>.</li>
<li><code>intervals[i]</code> will have length <code>2</code>, representing some integer interval.</li>
<li><code>intervals[i][j]</code> will be an integer in <code>[0, 10^8]</code>.</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>给出一系列区间，区间的表示使用[a,b]，表示a~b之间包括ab的所有值，现在寻找一个最小的集合，保证对于每个给定的区间，集合S内至少有两个元素在这个区间内，请问这个最小集合的长度是多少。</p>
<p>本题使用Greedy。有两种方法，不过都是一样的思路，都是对于一个区间，集合S与之相交的两个值尽可能也与其他相交。</p>
<h2 id="第一种，按照右区间排序（相同右区间的左区间更大在前！）"><a href="#第一种，按照右区间排序（相同右区间的左区间更大在前！）" class="headerlink" title="第一种，按照右区间排序（相同右区间的左区间更大在前！）"></a>第一种，按照右区间排序（相同右区间的左区间更大在前！）</h2><p>将所有的区间按照右边界升序排序，然后从第一个区间x开始，可知区间x与S至少有两个元素相交，如何选取这两个元素呢？因为要尽可能兼容其他区间，所以这个值我们选x区间的最后两个，如果x=[x1, x2]，那么就选m=x2-1，n=x2。因为后面的区间右边界都比当前x的右边界大，因此我们尽可能靠后选择。然后遍历到下一个区间y=[y1,y2]，判断y1和n、m的大小，如果y1&lt;=m，表示m、n可以包含在y中，就不需要增加新的数， 如果y1==n，表示只包含了一个，就需要增加一个值=y2，如果都不在就增加两个值y2和y2-1。注意我们每次只需要比较最新的两个值，也就是最大的两个值，m和n。因此要更新m和n，然后继续遍历到下一个区间即可。</p>
<p>注意相同右边区间的时候，一定要左区间更大的在前，否则在判断的时候会出错。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上，排序$O(nlogn)$，空间上，不需要记录集合元素，$O(1)$。</p>
<p><code>Runtime: 340 ms, faster than 5.32% of C++ online submissions for Set Intersection Size At Least Two.</code></p>
<p><code>Memory Usage: 51.9 MB, less than 33.33% of C++ online submissions for Set Intersection Size At Least Two.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">intersectionSizeTwo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = INT_MIN, n = INT_MIN + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123; <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>] <span class="keyword">or</span> (a[<span class="number">1</span>] == b[<span class="number">1</span>] <span class="keyword">and</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]); &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; n) &#123;</span><br><span class="line">                m = interval[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">                n = m + <span class="number">1</span>;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; m) &#123;</span><br><span class="line">                m = n;</span><br><span class="line">                n = interval[<span class="number">1</span>];</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="第二种，按照左区间排序（相同左区间的右区间更小在前！）"><a href="#第二种，按照左区间排序（相同左区间的右区间更小在前！）" class="headerlink" title="第二种，按照左区间排序（相同左区间的右区间更小在前！）"></a>第二种，按照左区间排序（相同左区间的右区间更小在前！）</h2><p>将所有的区间按照左边界升序排序，然后从最后一个区间x开始，可知区间x与S至少有两个元素相交，如何选取这两个元素呢？因为要尽可能兼容其他区间，所以这个值我们选x区间的前两个，如果x=[x1, x2]，那么就选m=x1，n=x1+1。因为前面的区间左边界都比当前x的左边界大，因此我们尽可能靠前选择。然后遍历到下一个区间y=[y1,y2]，判断y2和m、n的大小，如果y2&gt;=n，表示m、n可以包含在y中，就不需要增加新的数， 如果y2==m，表示只包含了一个，就需要增加一个值=y1，如果都不在就增加两个值y1和y1+1。注意我们每次只需要比较最新的两个值，也就是最小的两个值，m和n。因此要更新m和n，然后继续遍历到下一个区间即可。</p>
<h2 id="时空复杂度-1"><a href="#时空复杂度-1" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上，排序$O(nlogn)$，空间上，不需要记录集合元素，$O(1)$。</p>
<p><code>Runtime: 372 ms, faster than 5.32% of C++ online submissions for Set Intersection Size At Least Two.</code></p>
<p><code>Memory Usage: 52 MB, less than 33.33% of C++ online submissions for Set Intersection Size At Least Two.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">intersectionSizeTwo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = INT_MAX - <span class="number">1</span>, n = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b) &#123; <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] <span class="keyword">or</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>] <span class="keyword">and</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]); &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; m) &#123;</span><br><span class="line">                m = interval[<span class="number">0</span>];</span><br><span class="line">                n = m + <span class="number">1</span>;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">1</span>] &lt; n) &#123;</span><br><span class="line">                n = m;</span><br><span class="line">                m = interval[<span class="number">0</span>];</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-20</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/LeetCode(630.%20Course%20Schedule%20III)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/LeetCode(630.%20Course%20Schedule%20III)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(630. Course Schedule III)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-20 00:58:39 / 修改时间：01:04:42" itemprop="dateCreated datePublished" datetime="2020-03-20T00:58:39+08:00">2020-03-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-630-Course-Schedule-III-题解"><a href="#LeetCode-630-Course-Schedule-III-题解" class="headerlink" title="LeetCode(\630. Course Schedule III)题解"></a>LeetCode(\630. Course Schedule III)题解</h1><p>There are <code>n</code> different online courses numbered from <code>1</code> to <code>n</code>. Each course has some duration(course length) <code>t</code> and closed on <code>dth</code> day. A course should be taken <strong>continuously</strong> for <code>t</code> days and must be finished before or on the <code>dth</code> day. You will start at the <code>1st</code> day.</p>
<p>Given <code>n</code> online courses represented by pairs <code>(t,d)</code>, your task is to find the maximal number of courses that can be taken.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">There&#39;re totally 4 courses, but you can take 3 courses at most:</span><br><span class="line">First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.</span><br><span class="line">Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. </span><br><span class="line">Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. </span><br><span class="line">The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The integer 1 &lt;= d, t, n &lt;= 10,000.</li>
<li>You can’t take two courses simultaneously.</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>课程调度的一个变种问题。存在一批课程，每个课程存在包括两个数(t，d)，t为课程持续的时间，d为课程最晚的截止时间，即课程必须在d之前完成。现在在不冲突的情况下，串行地执行课程，可以放弃掉一些课程，请问可以成功执行的课程有最多有多少？</p>
<p>这个题还是使用使用Greedy，蛮难想到的其实。和最小延迟调度一样，我们同样将课程按照截止时间升序排序，因为还是尽可能执行截止时间更早的课程。但是和最小延迟调度每个课程都选用不一样的是，加入一门课程，如果发现这个课程超过了截止时间，那么就从已经加入的课程中删除一个耗时最久即t最大的课程，如果加入的这个课程就是最耗时的，那自然就删除当前这个课程。</p>
<p>按照上述策略，就可以得到最多的可以成功执行的课程，至于最优性证明，假设存在一个最优的选择方案，那么一定可以调整成上述策略选择出来的课程。</p>
<p>这里删除耗时最久的课程，可以使用优先队列，大顶堆。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上，排序加选择，$O(nlogn)$，空间上，$O(n)$。</p>
<p><code>Runtime: 1096 ms, faster than 12.12% of C++ online submissions for Course Schedule III.</code></p>
<p><code>Memory Usage: 248.3 MB, less than 100.00% of C++ online submissions for Course Schedule III.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">scheduleCourse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; courses)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, len = courses.<span class="built_in">size</span>(), courseLen = <span class="number">0</span>;</span><br><span class="line">        sort(courses.<span class="built_in">begin</span>(), courses.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            Q.push(courses[i][<span class="number">0</span>]);</span><br><span class="line">            courseLen += courses[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (courseLen &gt; courses[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                courseLen -= Q.top();</span><br><span class="line">                Q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Q.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-19</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/19/LeetCode(330.%20Patching%20Array)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/19/LeetCode(330.%20Patching%20Array)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(330. Patching Array)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-19 12:12:15 / 修改时间：12:12:18" itemprop="dateCreated datePublished" datetime="2020-03-19T12:12:15+08:00">2020-03-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-330-Patching-Array-题解"><a href="#LeetCode-330-Patching-Array-题解" class="headerlink" title="LeetCode(\330. Patching Array)题解"></a>LeetCode(\330. Patching Array)题解</h1><p>Given a sorted positive integer array <em>nums</em> and an integer <em>n</em>, add/patch elements to the array such that any number in range <code>[1, n]</code> inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3], n &#x3D; 6</span><br><span class="line">Output: 1 </span><br><span class="line">Explanation:</span><br><span class="line">Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.</span><br><span class="line">Now if we add&#x2F;patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].</span><br><span class="line">Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].</span><br><span class="line">So we only need 1 patch.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,5,10], n &#x3D; 20</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The two patches can be [2, 4].</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,2], n &#x3D; 5</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>给一个排序的整数数组nums，和一个n。通过向nums中增加一些元素，使得1~n可以通过nums中的元素进行组合求和得到。返回需要增加的最少元素个数。</p>
<p>这题使用Greedy。总体来说，贪心策略为：我们从1开始，尽可能向着连续增长最快的方向前进，遇到无法增长的时候，尽可能从nums中寻找可以使当前无法覆盖的被覆盖，找不到才增加一个数。比如1，2，走到最远端的是1+2=3，下一个无法达到的数是4，因此直接增加一个4。这种方法可以使用反证法证明是最优的，因为如果增加的数不是最近的无法达到的数，如果增加的比这个数小，最后的总的增加数肯定是小于等于这种方式，如果增加的比这个数大，那这个数就永远也无法满足了。</p>
<p>因此，具体做法如下。</p>
<p>我们维护一个数miss，表示当前构造的序列中，最近一个无法抵达的数。比如当前构造的序列覆盖的范围为1~t，那么miss=t+1。初始化miss=1，因为此时序列中没有元素。</p>
<p>我们假设算法运行到一定程度了，这时候nums从左到右遍历到了i位置，最近的缺失值为miss，那么可以推断出，当前的序列构造到了1~miss-1。</p>
<p>那么这时候判断nums[i]的值，如果大于miss，说明这时候nums中的所有未加入的都大于miss，加入任何值都不能使得miss被覆盖，因此需要我们加入一个为val=miss的值到构造序列中。如果nums[i]&lt;=miss，那么nums[i]与构造序列中的miss-nums[i]或者nums[i]本身就可以组合出miss，因此这时候不需要加入新的数，而是加入val=nums[i]即可，同时i++。通过上述操作之后，构造序列的覆盖范围变成了1~miss-1+val，那么下一个miss值就是miss+val。这样循环下去，直到miss+val&gt;n。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上$O(n)$，空间上$O(1)$。</p>
<p><code>Runtime: 8 ms, faster than 66.49% of C++ online submissions for Patching Array.</code></p>
<p><code>Memory Usage: 8.2 MB, less than 100.00% of C++ online submissions for Patching Array.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> miss = <span class="number">1</span>, i = <span class="number">0</span>, len = nums.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (miss &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len <span class="keyword">and</span> nums[i] &lt;= miss) &#123;</span><br><span class="line">                miss = miss + nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res++;</span><br><span class="line">                miss = miss + miss;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-19</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/LeetCode(321.%20Create%20Maximum%20Number)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/17/LeetCode(321.%20Create%20Maximum%20Number)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(321. Create Maximum Number)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-17 23:42:06" itemprop="dateCreated datePublished" datetime="2020-03-17T23:42:06+08:00">2020-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-18 15:36:37" itemprop="dateModified" datetime="2020-03-18T15:36:37+08:00">2020-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-321-Create-Maximum-Number-题解"><a href="#LeetCode-321-Create-Maximum-Number-题解" class="headerlink" title="LeetCode(\321. Create Maximum Number)题解"></a>LeetCode(\321. Create Maximum Number)题解</h1><p>Given two arrays of length <code>m</code> and <code>n</code> with digits <code>0-9</code> representing two numbers. Create the maximum number of length <code>k &lt;= m + n</code> from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the <code>k</code> digits.</p>
<p><strong>Note:</strong> You should try to optimize your time and space complexity.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [3, 4, 6, 5]</span><br><span class="line">nums2 &#x3D; [9, 1, 2, 5, 8, 3]</span><br><span class="line">k &#x3D; 5</span><br><span class="line">Output:</span><br><span class="line">[9, 8, 6, 5, 3]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [6, 7]</span><br><span class="line">nums2 &#x3D; [6, 0, 4]</span><br><span class="line">k &#x3D; 5</span><br><span class="line">Output:</span><br><span class="line">[6, 7, 6, 0, 4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [3, 9]</span><br><span class="line">nums2 &#x3D; [8, 9]</span><br><span class="line">k &#x3D; 3</span><br><span class="line">Output:</span><br><span class="line">[9, 8, 9]</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>有m和n长的两个整数数组nums1和nums2，整数数组表示一个大的多位整数。从前到后每个元素都是0-9的值。现在从两个数组中选出K(K&lt;m+n)个数组成一个新的整数数组来表示一个大的K位数，选出的元素要保持在原有数组的相对顺序，返回选定的最大的K位数数组。</p>
<p>这个题如何来做呢？我的思路是这样的——</p>
<p>首先不考虑边界问题，我们组成一个K位数，一定是从nums1中选一些数，再从nums2中选一些数组成K个数，再组合成一个K位数。那么我们就遍历从nums1选0个数和nums2选K个数，nums1选1个数和nums2选K-1个数，…，nums1选K个数和nums2选0个数，这样遍历K种情况，每种情况下都得到对应的最大的K位数整数数组，最后比较一下就可以。这个步骤的时间复杂度$O(K)$。</p>
<p>好，现在考虑选定了数之后怎么组合的问题。假定从nums1中选了a个数，从nums2中选了b个数，a+b=K。那么nums1的a个数和nums2的b个数在保持原有相对顺序不变的情况下得到最大的K位数数组的组合方式就很简单了。我们直接按照类似于归并排序内的merge方式就可以。在a个数和b个数的开头分别设置一个指针，每次选择两个指针中较大的那个值放入组合的K位数中的尾部即可，然后对应的指针后移一位。但是这里要注意如果两个指针指向的元素是一样的话，那么就要判断后面的元素大大小才能确定移动哪个指针（移动后面元素更大的那个数组的指针）。这个步骤的时间复杂度为$O(K)$。</p>
<p>那么现在就应该考虑如何从两个数组中选数了。假定我们要从nums1中选出a个数，一共有多少种方式呢，答案是$ C_{m}^{a} $ 种。如果再加上nums2的二者一乘，时间复杂度就太高了。但其实想一想，我们只需要nums1中最大的a个数就可以了，怎么定义最大呢，就是a个数组成的a位数是所有a个数组成的数中最大的。</p>
<p>那么现在，问题就变成了——怎么从一个0-9的整数数组中选出a个数，假设数组为nums1，在保持原有顺序的前提下，使得选出的a个数组成最大的a位数。</p>
<p>在这里我们可以使用贪心策略，即我们尽可能保证选出的a个数，位于前列的数更大，这样最后组成的a位数就尽可能大。比如选第一个数，我们就首先去寻找9的位置，如果存在9且这个9后面的数大于等于a-1个，那么我们就可以选这个，然后在后面的序列中选剩下的a-1个数。如果不满足条件，就依次寻找8、7、6等。</p>
<p>这里我们可以选择使用Stack来帮助我们，维护一个递减栈，从nums1的左边开始向右遍历。当遍历到一个数时，如果栈为空或者当前元素加上栈内的元素个数再加上剩余未遍历的元素等于a，就直接将元素入栈。否则就判断当前元素是否小于栈顶元素，小于等于就直接入栈。如果大于，就在保证当前元素加上栈内的元素个数再加上剩余未遍历的元素等于a，同时栈顶元素小于当前元素的前提下，不断出栈，最后将当前元素入栈。最后遍历结束时，栈中的元素个数一定大于等于a，返回栈底前a个元素，这就是最大的a个符合顺序的元素。这个步骤时间复杂度为$O(m)$。同样对nums2操作，时间复杂度为$O(n)$。</p>
<p>因此，按照上述方法，时间复杂度为$O(K(K+m+n))$。空间复杂度$O(K+m+n)$。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下。</p>
<p><code>Runtime: 48 ms, faster than 70.26% of C++ online submissions for Create Maximum Number.</code></p>
<p><code>Memory Usage: 23.4 MB, less than 80.00% of C++ online submissions for Create Maximum Number.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxNumberOfSingleArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!S.empty() <span class="keyword">and</span> S.back() &lt; nums[i] <span class="keyword">and</span> S.<span class="built_in">size</span>() + len - i &gt; k) S.pop_back();</span><br><span class="line">            S.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            res[i] = S.front();</span><br><span class="line">            S.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k1 = res1.<span class="built_in">size</span>(), k2 = res2.<span class="built_in">size</span>(), i1 = <span class="number">0</span>, i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i1 &lt; k1 <span class="keyword">and</span> i2 &lt; k2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res1[i1] &gt; res2[i2]) res.push_back(res1[i1++]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (res1[i1] &lt; res2[i2]) res.push_back(res2[i2++]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> ti1 = i1 + <span class="number">1</span>, ti2 = i2 + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (ti1 &lt; k1 <span class="keyword">and</span> ti2 &lt; k2 <span class="keyword">and</span> res1[ti1] == res2[ti2]) &#123;</span><br><span class="line">                    ti1++;</span><br><span class="line">                    ti2++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ti1 == k1) res.push_back(res2[i2++]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ti2 == k2) res.push_back(res1[i1++]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (res1[ti1] &gt; res2[ti2]) res.push_back(res1[i1++]);</span><br><span class="line">                <span class="keyword">else</span> res.push_back(res2[i2++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i1 &lt; k1) res.push_back(res1[i1++]);</span><br><span class="line">        <span class="keyword">while</span> (i2 &lt; k2) res.push_back(res2[i2++]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBigger</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res1[i] &gt; res2[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (res1[i] &lt; res2[i]) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; m <span class="keyword">or</span> k-i &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp1 = maxNumberOfSingleArray(nums1, i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp2 = maxNumberOfSingleArray(nums2, k-i);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = merge(tmp1, tmp2);</span><br><span class="line">            <span class="keyword">if</span> (isBigger(tmp, res, k)) &#123;</span><br><span class="line">                res = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-18</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/16/LeetCode(1383.%20Maximum%20Performance%20of%20a%20Team)%E5%91%A8%E8%B5%9B%E9%A2%984%E9%A2%98%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/16/LeetCode(1383.%20Maximum%20Performance%20of%20a%20Team)%E5%91%A8%E8%B5%9B%E9%A2%984%E9%A2%98%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(1383. Maximum Performance of a Team)周赛题4题题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-16 10:36:53 / 修改时间：10:48:04" itemprop="dateCreated datePublished" datetime="2020-03-16T10:36:53+08:00">2020-03-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-1383-Maximum-Performance-of-a-Team-周赛题4题题解"><a href="#LeetCode-1383-Maximum-Performance-of-a-Team-周赛题4题题解" class="headerlink" title="LeetCode(\1383. Maximum Performance of a Team)周赛题4题题解"></a>LeetCode(\1383. Maximum Performance of a Team)周赛题4题题解</h1><p>There are <code>n</code> engineers numbered from 1 to <code>n</code> and two arrays: <code>speed</code> and <code>efficiency</code>, where <code>speed[i]</code> and <code>efficiency[i]</code> represent the speed and efficiency for the i-th engineer respectively. <em>Return the maximum <strong>performance</strong> of a team composed of at most <code>k</code> engineers, since the answer can be a huge number, return this modulo 10^9 + 7.</em></p>
<p>The <strong>performance</strong> of a team is the sum of their engineers’ speeds multiplied by the minimum efficiency among their engineers. </p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 6, speed &#x3D; [2,10,3,1,5,8], efficiency &#x3D; [5,4,3,9,7,2], k &#x3D; 2</span><br><span class="line">Output: 60</span><br><span class="line">Explanation: </span><br><span class="line">We have the maximum performance of the team by selecting engineer 2 (with speed&#x3D;10 and efficiency&#x3D;4) and engineer 5 (with speed&#x3D;5 and efficiency&#x3D;7). That is, performance &#x3D; (10 + 5) * min(4, 7) &#x3D; 60.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 6, speed &#x3D; [2,10,3,1,5,8], efficiency &#x3D; [5,4,3,9,7,2], k &#x3D; 3</span><br><span class="line">Output: 68</span><br><span class="line">Explanation:</span><br><span class="line">This is the same example as the first but k &#x3D; 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance &#x3D; (2 + 10 + 5) * min(5, 4, 7) &#x3D; 68.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 6, speed &#x3D; [2,10,3,1,5,8], efficiency &#x3D; [5,4,3,9,7,2], k &#x3D; 4</span><br><span class="line">Output: 72</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>speed.length == n</code></li>
<li><code>efficiency.length == n</code></li>
<li><code>1 &lt;= speed[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= efficiency[i] &lt;= 10^8</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>这题可以这样想，有N名工人，每个工人有一个勤奋度和做事速度，二者都越大越好。现在最多要招K名员工组成一个团队，团队整体的质量是由团队所有人的做事速度相加再乘上最低的勤奋度得到的，请问如何选择才能得到最高的质量，返回这个值，不过记得取余数。</p>
<p>这个题使用Greedy解决，可以使用优先队列。首先将所有工人按照勤奋度降序排序，从前到后遍历工人，然后维护一个最大为K个元素的最小堆，每次将工人的做事速度放入堆中，堆中的元素就代表了要选的工人，如果超过了K个元素就将速度最小的那个去掉，在这个过程中记录最高的团队质量。</p>
<p>而贪心策略就是，如果必须要要加入一个人同时必须在团队内删除一个人的话，那我就去掉那个速度最慢的，因为勤奋度在排序之后已经入了团队的人的勤奋度是不会成为最低的勤奋度的。</p>
<p>这个题和<a href="https://leetcode.com/problems/minimum-cost-to-hire-k-workers/" target="_blank" rel="noopener">857. Minimum Cost to Hire K Workers</a>是一样的解法，不过857是按单价从低到高排序，每次从最大堆里推掉质量最大的人。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间复杂度主要用在排序上面，$O(nlogn)$，空间上$O(n)$.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPerformance</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; speed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; efficiency, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;int, int&gt;&gt; se(n);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>, m = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">9</span>) + <span class="number">7</span>, speedSum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) se[i] = make_pair(speed[i], efficiency[i]);</span><br><span class="line">        sort(se.<span class="built_in">begin</span>(), se.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; minHeap;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minHeap.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">                minHeap.push(se[i].first);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                speedSum -= minHeap.top();</span><br><span class="line">                minHeap.pop();</span><br><span class="line">                minHeap.push(se[i].first);</span><br><span class="line">            &#125;</span><br><span class="line">            speedSum += se[i].first;</span><br><span class="line"></span><br><span class="line">            res = <span class="built_in">max</span>(res, speedSum * se[i].second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res % m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2020-03-15</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/14/LeetCode(621.%20Task%20Scheduler)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/LeetCode(621.%20Task%20Scheduler)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(621. Task Scheduler)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-14 22:30:17 / 修改时间：22:45:42" itemprop="dateCreated datePublished" datetime="2020-03-14T22:30:17+08:00">2020-03-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-621-Task-Scheduler-题解"><a href="#LeetCode-621-Task-Scheduler-题解" class="headerlink" title="LeetCode(\621. Task Scheduler)题解"></a>LeetCode(\621. Task Scheduler)题解</h1><p>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p>
<p>However, there is a non-negative cooling interval <strong>n</strong> that means between two <strong>same tasks</strong>, there must be at least n intervals that CPU are doing different tasks or just be idle.</p>
<p>You need to return the <strong>least</strong> number of intervals the CPU will take to finish all the given tasks.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: tasks &#x3D; [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n &#x3D; 2</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong></p>
<ol>
<li>The number of tasks is in the range [1, 10000].</li>
<li>The integer n is in the range [0, 100].</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>给定由大写字母标的的任务列表，和一个表示间隔的值n。现在有一个电脑，可以在一个间隔的时间内完成一个任务，但是相同的任务必须隔至少n个间隔才能再次运行，每个间隔内，电脑可以选择运行任务，或者空闲。</p>
<p>请问完成所有任务需要的最小间隔数是多少?</p>
<p>我所能想到的解法是贪心：</p>
<p>统计相同任务的个数，然后将任务按照任务数降序排序。然后从前到后遍历。那么第一个任务的A个数就决定了最少的间隔数是肯定大于等于，（A-1）* n + A的。那么我们可以默认空出来了（A-1）* n的间隔，后续的任务可以在这些间隔内完成，这样就不用增加新的间隔，间隔不够就再挨着慢慢增加。而贪心策略就是，我们，每次在空闲间隔内增加的方式是：以第一个任务A的排布为边界，在每个A之间分别加上当前任务，这样肯定满足条件，同时，每次添加都是沿着上一次任务结束的位置添加，如果没有空格了，还是在A的任务之间插入新的即可，在这个过程中计算增加的间隔。如果加入的任务B的个数等于A，那么除了A之间的空闲全部占掉一个之外，在最后A的外面也要占掉一个，会增加一个新的间隔。</p>
<p>如何证明这种算法是正确的呢？我并没有想出来很形式化的语言，但是算法的过程中，每一步都尽可能不增加新的间隔，直到最后，任何最优的方案最后都可以转化为这种算法得到的答案。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上，统计任务数$O(N)$，排序因为是26个 字母固定的，为$O(1)$。空间上，$O(1)$。</p>
<p><code>Runtime: 48 ms, faster than 98.36% of C++ online submissions for Task Scheduler.</code></p>
<p><code>Memory Usage: 8.9 MB, less than 100.00% of C++ online submissions for Task Scheduler.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Task</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, restSpace = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> t : tasks) &#123;</span><br><span class="line">            <span class="built_in">Task</span>[t - <span class="string">'A'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(<span class="built_in">Task</span>.<span class="built_in">begin</span>(), <span class="built_in">Task</span>.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        restSpace = n * (<span class="built_in">Task</span>[<span class="number">25</span>] - <span class="number">1</span>);</span><br><span class="line">        res = <span class="built_in">Task</span>[<span class="number">25</span>] + (<span class="built_in">Task</span>[<span class="number">25</span>] - <span class="number">1</span>) * n;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">24</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Task</span>[i] == <span class="built_in">Task</span>[<span class="number">25</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (restSpace &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    restSpace -= <span class="built_in">Task</span>[<span class="number">25</span>] - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> res += <span class="built_in">Task</span>[<span class="number">25</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (restSpace &gt;= <span class="built_in">Task</span>[i]) restSpace -= <span class="built_in">Task</span>[i];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += <span class="built_in">Task</span>[i] - restSpace;</span><br><span class="line">                    restSpace = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="其它的解法"><a href="#其它的解法" class="headerlink" title="其它的解法"></a>其它的解法</h2><h3 id="解法1，每一轮执行最多个数的任务"><a href="#解法1，每一轮执行最多个数的任务" class="headerlink" title="解法1，每一轮执行最多个数的任务"></a>解法1，每一轮执行最多个数的任务</h3><p>统计每个任务的任务数，然后降序排序，然后从前到后在两个相同任务允许的最小时间间隔内分别执行任务，将执行了任务的任务数-1.然后再对所有任务排序，最后直到所有的任务完成，这种也是贪心，尽可能先执行任务多的任务同时尽可能占满空闲时间。时间复杂度为所有任务的个数和，空间O(1)。</p>
<h3 id="解法2，优先队列"><a href="#解法2，优先队列" class="headerlink" title="解法2，优先队列"></a>解法2，优先队列</h3><p>将解法1优化一下，使用最大堆，优先队列存储，那么就不用每次都排序了。</p>
<p>BitBrave，2020-03-14</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/06/LeetCode(503.%20Next%20Greater%20Element%20II)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/06/LeetCode(503.%20Next%20Greater%20Element%20II)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(503. Next Greater Element II)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-06 21:54:36 / 修改时间：23:27:12" itemprop="dateCreated datePublished" datetime="2020-03-06T21:54:36+08:00">2020-03-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-503-Next-Greater-Element-II-题解"><a href="#LeetCode-503-Next-Greater-Element-II-题解" class="headerlink" title="LeetCode(\503. Next Greater Element II)题解"></a>LeetCode(\503. Next Greater Element II)题解</h1><p>Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,1]</span><br><span class="line">Output: [2,-1,2]</span><br><span class="line">Explanation: The first 1&#39;s next greater number is 2; </span><br><span class="line">The number 2 can&#39;t find next greater number; </span><br><span class="line">The second 1&#39;s next greater number needs to search circularly, which is also 2.</span><br></pre></td></tr></table></figure>



<p><strong>Note:</strong> The length of given array won’t exceed 10000.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Medium</p>
<p>给出一维数组nums，不过这个数组是环形的，首尾相连。要求找出每个元素右边第一个比自己大的元素，如果不存在就设为-1.比如132，最终返回的答案是3，-1，3，因为2向右走会回到第一个。</p>
<p>这个题的简单的一个版本是数组不是收尾相连的。对于这种题的解法最简单的就是对每一个元素遍历其它元素，找出对应的值，时间复杂度$O(n^2)$。</p>
<p>但是可以用stack在$O(n)$的时间内解决，对于不是首尾相连的数组，我们可以维护一个递减栈，这里有两种方式。</p>
<ul>
<li>从后往前遍历，利用栈顶元素来更新即将入栈的元素。遍历到一个元素a，如果栈空，表示a后边没有比自己大的元素了，将a元素对应的值设为-1然后将a入栈，否则查看a是否小于栈顶元素，如果小于，就说明栈顶元素就是a右边离自己最近的比自己大的元素，直接设为栈顶元素即可，如果大于等于，说明当前栈顶元素不会再在后面的遍历中用到了，直接出栈即可。持续出栈直到栈为空或者栈顶元素大于a，然后按照上面的论述设定a对应的值。最后将a入栈。</li>
<li>从前往后遍历，利用即将入栈的元素来更新栈顶元素，遍历到到一个元素a，如果栈空，表示a前边没有可以更新的元素了，将a入栈，否则查看a是否大于栈顶元素，如果大于，就说明栈顶元素的右边离自己大的最近的就是a，将栈顶元素的对应值更新为a然后将出栈，持续出栈并更新直到栈顶元素的值大于等于a或者栈空，这时候a就不能更新栈顶元素了，将a入栈。最后所有没有更新过的值就是-1。</li>
</ul>
<p>在处理数组为环形的时候，上述两种办法其实也是可以的，只不过要稍稍变换下思路。我们可以将数组double一下，将两个一样的nums拼接成一个，等于遍历数组两次，然后使用上面的方法更新即可。</p>
<ul>
<li>从前往后遍历，第一次遍历数组nums，按照单向数组一样的方式更新，然后再次遍历一遍使用相同的额处理方式遍历数组，第二次遍历的时候，栈中已经存在了之前遍历留下的元素，就等于可以使用数组前边的元素来更新数组后边的值了。</li>
<li>从后往前遍历，第一次遍历数组nums，按照单向数组一样的方式处理，但是不更新每个元素的对应的值，第一次主要是为了在栈中留下数组内前边的值。然后第二次遍历的时候，还是使用同样的方式，只不过这一次开始更新每个元素的对应的值。其实第一次更新不更新每个元素的值都一样的。</li>
</ul>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>时间上，$O(n)$，空间上，$O(n)$。</p>
<h3 id="从后往前遍历"><a href="#从后往前遍历" class="headerlink" title="从后往前遍历"></a>从后往前遍历</h3><p><code>Runtime: 84 ms, faster than 92.25% of C++ online submissions for Next Greater Element II.</code></p>
<p><code>Memory Usage: 11.5 MB, less than 100.00% of C++ online submissions for Next Greater Element II.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!S.empty() <span class="keyword">and</span> nums[i] &gt;= S.top()) S.pop();</span><br><span class="line">            S.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!S.empty() <span class="keyword">and</span> nums[i] &gt;= S.top()) S.pop();</span><br><span class="line">            <span class="keyword">if</span> (S.empty()) res[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> res[i] = S.top();</span><br><span class="line">            S.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="从前往后遍历"><a href="#从前往后遍历" class="headerlink" title="从前往后遍历"></a>从前往后遍历</h3><p><code>Runtime: 84 ms, faster than 92.25% of C++ online submissions for Next Greater Element II.</code></p>
<p><code>Memory Usage: 11.7 MB, less than 100.00% of C++ online submissions for Next Greater Element II.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(len, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!S.empty() <span class="keyword">and</span> nums[i] &gt; nums[S.top()]) &#123;</span><br><span class="line">                res[S.top()] = nums[i];</span><br><span class="line">                S.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            S.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!S.empty() <span class="keyword">and</span> nums[i] &gt; nums[S.top()]) &#123;</span><br><span class="line">                res[S.top()] = nums[i];</span><br><span class="line">                S.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            S.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-06</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/05/LeetCode(456.%20132%20Pattern)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/05/LeetCode(456.%20132%20Pattern)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(456. 132 Pattern)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-05 23:04:42 / 修改时间：23:04:54" itemprop="dateCreated datePublished" datetime="2020-03-05T23:04:42+08:00">2020-03-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-456-132-Pattern-题解"><a href="#LeetCode-456-132-Pattern-题解" class="headerlink" title="LeetCode(\456. 132 Pattern)题解"></a>LeetCode(\456. 132 Pattern)题解</h1><p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence a<strong>i</strong>, a<strong>j</strong>, a<strong>k</strong> such that <strong>i</strong> &lt; <strong>j</strong> &lt; <strong>k</strong> and a<strong>i</strong> &lt; a<strong>k</strong> &lt; a<strong>j</strong>. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>
<p><strong>Note:</strong> n will be less than 15,000.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">Output: False</span><br><span class="line"></span><br><span class="line">Explanation: There is no 132 pattern in the sequence.</span><br></pre></td></tr></table></figure>



<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [3, 1, 4, 2]</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line"></span><br><span class="line">Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</span><br></pre></td></tr></table></figure>



<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [-1, 3, 2, 0]</span><br><span class="line"></span><br><span class="line">Output: True</span><br><span class="line"></span><br><span class="line">Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Medium</p>
<p>给定一个整数数组A，判断其中是否存在这样的模式：有三个位置，i&lt;j&lt;k。每个位置上的元素关系为Ai&lt;Ak&lt;Aj即132模式，如果有这样的模式存在就返回True，否则False。</p>
<p>这个题明确使用Stack，可以在线性时间内解决，但是我只能想到平方的解法，就是以每个元素Aj，分别寻找左边最小的和右边比当前值小的最大值，然后判断。参考网上别人的解法才发现，Stack实在是太美妙了。</p>
<p>我们如何来利用Stack呢？</p>
<p>可以这样想，我们找到一个元素a，只要得到左边的最小元素b和右边的比a小的数中最大的那个c，只要bac满足条件，那么算法就以True结束了，如果不满足，那么以这个元素a作为中间值肯定是不可以的。找元素左边最小的很容易，我们O(n)的时间就可以，主要是如何寻找c？</p>
<p>这里可以用一个Stack来，我们可以维护一个递减栈，一般来说一个递减栈是用来确定一个元素离它最近的比他大的元素值的。但是我们在递减栈出栈的过程中，记录下最后那个出栈的元素，那么那个元素就是比当前元素小的元素中，最大的那个了。</p>
<p>因此，再完善一点，算法的流程就是：</p>
<ul>
<li>我们构建一个Stack（存储一个递减序列），从数组A的后边向前边遍历，设定一个整数s记录最近出栈的元素，初始化s=INT_MIN。</li>
<li>从后向前遍历元素，走到元素a时，判断a是否小于s，如果小于，说明s已经被更新了，栈内肯定插入了更大值，因为从后向前遍历，这个更大值的位置肯定在s和a之间，因此符合132的模式，返回True。否则进行下一步。</li>
<li>如果栈为空，直接将a入栈，否则判断元素是否大于栈顶元素，如果大于，那么就不断出栈直到栈为空或者a小于等于栈顶元素，然后将a入栈，此时s更新为最近一次出栈的元素，因为是个递减栈，所以s一定小于a同时s是数组右边小于a的元素中最大的那个，此时也可以说s元素的左边一定有一个比他的大的元素存在。</li>
<li>重复上述操作，知道遍历完整个数组才退出循环，表示这个数组内不存在132的模式，否则肯定会提前结束循环。因此直接返回False。</li>
</ul>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上，$O(N)$，空间上，$O(N)$。</p>
<p><code>Runtime: 24 ms, faster than 82.89% of C++ online submissions for 132 Pattern.</code></p>
<p><code>Memory Usage: 9.4 MB, less than 100.00% of C++ online submissions for 132 Pattern.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">        <span class="keyword">int</span> c = INT_MIN, len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; c) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">while</span> (!S.empty() <span class="keyword">and</span> nums[i] &gt; S.top()) &#123;</span><br><span class="line">                c = S.top();</span><br><span class="line">                S.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            S.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-05</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/LeetCode(1368.%20Minimum%20Cost%20to%20Make%20at%20Least%20One%20Valid%20Path%20in%20a%20Grid)%E5%91%A8%E8%B5%9B%E7%AC%AC4%E9%A2%98%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/03/LeetCode(1368.%20Minimum%20Cost%20to%20Make%20at%20Least%20One%20Valid%20Path%20in%20a%20Grid)%E5%91%A8%E8%B5%9B%E7%AC%AC4%E9%A2%98%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(1368. Minimum Cost to Make at Least One Valid Path in a Grid)周赛第4题题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-03 23:43:15 / 修改时间：23:43:16" itemprop="dateCreated datePublished" datetime="2020-03-03T23:43:15+08:00">2020-03-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-1368-Minimum-Cost-to-Make-at-Least-One-Valid-Path-in-a-Grid-周赛第4题题解"><a href="#LeetCode-1368-Minimum-Cost-to-Make-at-Least-One-Valid-Path-in-a-Grid-周赛第4题题解" class="headerlink" title="LeetCode(\1368. Minimum Cost to Make at Least One Valid Path in a Grid)周赛第4题题解"></a>LeetCode(\1368. Minimum Cost to Make at Least One Valid Path in a Grid)周赛第4题题解</h1><p>Given a <em>m</em> x <em>n</em> <code>grid</code>. Each cell of the <code>grid</code> has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of <code>grid[i][j]</code> can be:</p>
<ul>
<li><strong>1</strong> which means go to the cell to the right. (i.e go from <code>grid[i][j]</code> to <code>grid[i][j + 1]</code>)</li>
<li><strong>2</strong> which means go to the cell to the left. (i.e go from <code>grid[i][j]</code> to <code>grid[i][j - 1]</code>)</li>
<li><strong>3</strong> which means go to the lower cell. (i.e go from <code>grid[i][j]</code> to <code>grid[i + 1][j]</code>)</li>
<li><strong>4</strong> which means go to the upper cell. (i.e go from <code>grid[i][j]</code> to <code>grid[i - 1][j]</code>)</li>
</ul>
<p>Notice that there could be some <strong>invalid signs</strong> on the cells of the <code>grid</code> which points outside the <code>grid</code>.</p>
<p>You will initially start at the upper left cell <code>(0,0)</code>. A valid path in the grid is a path which starts from the upper left cell <code>(0,0)</code> and ends at the bottom-right cell <code>(m - 1, n - 1)</code> following the signs on the grid. The valid path <strong>doesn’t have to be the shortest</strong>.</p>
<p>You can modify the sign on a cell with <code>cost = 1</code>. You can modify the sign on a cell <strong>one time only</strong>.</p>
<p>Return <em>the minimum cost</em> to make the grid have at least one valid path.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/02/13/grid1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You will start at point (0, 0).</span><br><span class="line">The path to (3, 3) is as follows. (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) change the arrow to down with cost &#x3D; 1 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) change the arrow to down with cost &#x3D; 1 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) change the arrow to down with cost &#x3D; 1 --&gt; (3, 3)</span><br><span class="line">The total cost &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/02/13/grid2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,1,3],[3,2,2],[1,1,4]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: You can follow the path from (0, 0) to (2, 2).</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/02/13/grid3.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,2],[4,3]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[2,2,2],[2,2,2]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[4]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
</ul>
<p><a href="https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/discuss" target="_blank" rel="noopener">Discuss</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>一个M*N大小的矩阵，每个矩阵元素为1234中的一个，分别表示一个方向，左右下上。从左上角开始，到右下角找一条路，我们可以将某个元素改变方向，改一次代价+1。找出代价最小的办法，使得存在至少一条可达的路径。当然，如果不用改就有路径，那就代价为0，是最好的。</p>
<p>这个题一开始可能会想到用DP，但是从左上角到右下角的路径并不是只能向右向下的，而是可以迂回的，所以用DP很难构造出有效的状态转移方程。我是参考了大佬们的解法才发现如下的解法。</p>
<p>将每个元素位置看成一个点，矩阵一共有M*N个点。点与点之间有边相连，一个点有四条边，其原本的方向所指的方向上，边权值为0，其余三条边的边权值为1。那么一个矩阵最终可以转化为一个0-1图。以左上角为源点，右下角为汇点。这个题就可以变为寻找一条由源点到汇点的最短路。可以使用的方法有0-1BFS和Dijkstra。</p>
<h3 id="0-1-BFS"><a href="#0-1-BFS" class="headerlink" title="0-1 BFS"></a>0-1 BFS</h3><p>0-1BFS问题是指最短路问题中，边权只有 0 和 1 的特殊情况。写法类似 SPFA + SLF(Small Label First) 优化。需要一个 deque 。把权值 0 的边扩展到的点放到队首，权值 1 的边扩展到的点放到队尾。时间复杂度 O(V + E) 。</p>
<p>在这个题中，我们准备一个双向队列，和一个二维数组记录左上角到每个点的最短路径长度。首先将左上角的点入队列，然后在队列不空的情况下，弹出队首的点，查看其出边，对于可以松弛的点，就更新长度，同时如果权值为0就将对应的点插入队首，否则插入队尾。直到最后队列为空。</p>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>代码如下，时间上，$O(V+E) = O(MN)$，空间上，$O(MN)$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0-1 BFS</span></span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dis</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, INT_MAX))</span></span>;</span><br><span class="line">        <span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">        </span><br><span class="line">        Q.push_back(make_pair(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        dis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = Q.front(); Q.pop_front();</span><br><span class="line">            <span class="keyword">int</span> w = <span class="number">0</span>, i = p.first, j = p.second;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// right 1</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; n<span class="number">-1</span>) &#123;</span><br><span class="line">                w = grid[i][j] == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dis[i][j] + w &lt; dis[i][j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    dis[i][j+<span class="number">1</span>] = dis[i][j] + w;</span><br><span class="line">                    <span class="keyword">if</span> (w == <span class="number">0</span>) Q.push_front(make_pair(i, j+<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">else</span> Q.push_back(make_pair(i, j+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// left 2</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                w = grid[i][j] == <span class="number">2</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dis[i][j] + w &lt; dis[i][j<span class="number">-1</span>]) &#123;</span><br><span class="line">                    dis[i][j<span class="number">-1</span>] = dis[i][j] + w;</span><br><span class="line">                    <span class="keyword">if</span> (w == <span class="number">0</span>) Q.push_front(make_pair(i, j<span class="number">-1</span>));</span><br><span class="line">                    <span class="keyword">else</span> Q.push_back(make_pair(i, j<span class="number">-1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// down 3</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; m<span class="number">-1</span>) &#123;</span><br><span class="line">                w = grid[i][j] == <span class="number">3</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dis[i][j] + w &lt; dis[i+<span class="number">1</span>][j]) &#123;</span><br><span class="line">                    dis[i+<span class="number">1</span>][j] = dis[i][j] + w;</span><br><span class="line">                    <span class="keyword">if</span> (w == <span class="number">0</span>) Q.push_front(make_pair(i+<span class="number">1</span>, j));</span><br><span class="line">                    <span class="keyword">else</span> Q.push_back(make_pair(i+<span class="number">1</span>, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// up 4</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                w = grid[i][j] == <span class="number">4</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dis[i][j] + w &lt; dis[i<span class="number">-1</span>][j]) &#123;</span><br><span class="line">                    dis[i<span class="number">-1</span>][j] = dis[i][j] + w;</span><br><span class="line">                    <span class="keyword">if</span> (w == <span class="number">0</span>) Q.push_front(make_pair(i<span class="number">-1</span>, j));</span><br><span class="line">                    <span class="keyword">else</span> Q.push_back(make_pair(i<span class="number">-1</span>, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dis[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>Dijkstra是用于寻找正权值图中，源点到其它点的最短路径的办法，若有N个节点，时间复杂度一般为$O(n^2)$。</p>
<p>本题中，构建图之后，我们可以直接应用Dijkstra算法求出最短路径长度。</p>
<h3 id="时空复杂度-1"><a href="#时空复杂度-1" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>代码如下，时间上，$O((MN)^2)$，空间上，$O(MN)$。在实际使用中是超时的。。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visit, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dis, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">        x = <span class="number">-1</span>;</span><br><span class="line">        y = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visit[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">-1</span> <span class="keyword">or</span> dis[i][j] &lt; dis[x][y]) &#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Dijkstra</span></span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>(), len = m * n - <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visit</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dis</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, INT_MAX))</span></span>;</span><br><span class="line">        </span><br><span class="line">        dis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;len; k++) &#123;</span><br><span class="line">            <span class="comment">// find the point with shortest path distance in no-visit set</span></span><br><span class="line">            <span class="keyword">int</span> i, j, w;</span><br><span class="line">            <span class="built_in">find</span>(m, n, visit, dis, i, j);</span><br><span class="line">            visit[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;"shortest "&lt;&lt;i&lt;&lt;j&lt;&lt;" dis: "&lt;&lt;dis[i][j]&lt;&lt;endl;</span></span><br><span class="line">            <span class="comment">// right 1</span></span><br><span class="line">            w = grid[i][j] == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n<span class="number">-1</span> <span class="keyword">and</span> dis[i][j] + w &lt; dis[i][j+<span class="number">1</span>]) dis[i][j+<span class="number">1</span>] = dis[i][j] + w;</span><br><span class="line">            <span class="comment">// left 2</span></span><br><span class="line">            w = grid[i][j] == <span class="number">2</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span> <span class="keyword">and</span> dis[i][j] + w &lt; dis[i][j<span class="number">-1</span>]) dis[i][j<span class="number">-1</span>] = dis[i][j] + w;</span><br><span class="line">            <span class="comment">// down 3</span></span><br><span class="line">            w = grid[i][j] == <span class="number">3</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m<span class="number">-1</span> <span class="keyword">and</span> dis[i][j] + w &lt; dis[i+<span class="number">1</span>][j]) dis[i+<span class="number">1</span>][j] = dis[i][j] + w;</span><br><span class="line">            <span class="comment">// up 4</span></span><br><span class="line">            w = grid[i][j] == <span class="number">4</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> dis[i][j] + w &lt; dis[i<span class="number">-1</span>][j]) dis[i<span class="number">-1</span>][j] = dis[i][j] + w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-03</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/02/LeetCode(316.%20Remove%20Duplicate%20Letters)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/LeetCode(316.%20Remove%20Duplicate%20Letters)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(316. Remove Duplicate Letters)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-02 22:09:14" itemprop="dateCreated datePublished" datetime="2020-03-02T22:09:14+08:00">2020-03-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-316-Remove-Duplicate-Letters-题解"><a href="#LeetCode-316-Remove-Duplicate-Letters-题解" class="headerlink" title="LeetCode(\316. Remove Duplicate Letters)题解"></a>LeetCode(\316. Remove Duplicate Letters)题解</h1><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;bcabc&quot;</span><br><span class="line">Output: &quot;abc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cbacdcbc&quot;</span><br><span class="line">Output: &quot;acdb&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> This question is the same as 1081: <a href="https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>给出一个字符串s，每个字符都是小写字母。现在要求删除s中重复的字符，最后留下的都是不重复的字符，保证留下来的字符组成的字符串是所有符合条件的字符串中按字典序排列是最小的，返回这个字符串。</p>
<h3 id="解法1，Greedy"><a href="#解法1，Greedy" class="headerlink" title="解法1，Greedy"></a>解法1，Greedy</h3><p>假设我们最终的结果字符串为r，而我们从左到右逐步去确定r的每个位置上的字符。在第k步确定第k个字符。</p>
<p>在第k步，我们已经确定了r[0,k-1]，现在确定第k个，如何去确定这个字符呢？假设这个字符为s[i]，那么一定满足如下条件：1、s中i位置之后的元素集一定包含了s中i之前的元素集，因为如果不是的话就向后遍历会丢掉s中i位置后不包含的i位置之前的元素。2、去除s中i位置之后的字符串中所有的s[i]。满足上面的条件之后，我们在每一步确定的i时，因为要保持字典序最小，因此确定一个贪心策略，s[i]是所有满足上述条件的字符中最小的。这个只要比较一下就好了。</p>
<p>将更新的s中i位置之后的字符串当做新的s，重复上面的1，2步骤，直到s为空。</p>
<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>代码如下，空间上，除去递归，一次函数运行花费$O(n)$，时间上，每次构建字典和遍历花费$O(n)$，递归$n$，总共$O(n^2)$。</p>
<p><code>Runtime: 92 ms, faster than 7.25% of Python3 online submissions for Remove Duplicate Letters.</code></p>
<p><code>Memory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Remove Duplicate Letters.</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">""</span>: <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        C = Counter(s)</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] &lt; s[k]: k = i</span><br><span class="line">            C[c] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> C[c] == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s[k] + self.removeDuplicateLetters(s[k+<span class="number">1</span>:].replace(s[k], <span class="string">''</span>))</span><br></pre></td></tr></table></figure>

<h3 id="解法2，Stack"><a href="#解法2，Stack" class="headerlink" title="解法2，Stack"></a>解法2，Stack</h3><p>我们可以使用栈来求解。从左到右遍历字符串s时，我们来决定哪些字符可以删除。用一个字典记录每个字符出现的次数。当遍历到第i个字符时，我们可以看i的前面字符，假设为第j个字符，如果s[i]&lt;s[j]，同时i之后还有s[j]，那么s[j]就可以删除了。</p>
<p>这里需要注意的是，假如字符串为bcab，最好的答案是bca，应该删除最后一个b，看似与上面的论述相矛盾。因此我们需要用一个栈来记录我们保存的字符，每次删除了字符之后，都会生成一个新的s，然后在这个新的字符串s里面，j=i-1。即i和j是相邻的，只有这样才能保证s[j]删除时不会引发错误。比如bcabc，遍历到a的时候，前面相邻的c可以删除，此时形成babc，这时候就是新的字符串a，又可以将b删除。字符串为bcab的时候，遍历到a时，前面的b与a不相邻，因此不能删除。</p>
<h3 id="时空复杂度-1"><a href="#时空复杂度-1" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>代码如下，时间上，$O(n)$，空间上，$O(n)$。</p>
<p><code>Runtime: 4 ms, faster than 82.46% of C++ online submissions for Remove Duplicate Letters.</code></p>
<p><code>Memory Usage: 8.3 MB, less than 100.00% of C++ online submissions for Remove Duplicate Letters.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; M;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; V;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M.<span class="built_in">find</span>(c) == M.<span class="built_in">end</span>()) M[c] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> M[c]++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator iter=M.<span class="built_in">begin</span>(); iter!=M.<span class="built_in">end</span>(); iter++) V[iter-&gt;first] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;M.<span class="built_in">size</span>()&lt;&lt;V.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            M[s[i]]--;</span><br><span class="line">            <span class="keyword">if</span> (V[s[i]] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (!S.empty() <span class="keyword">and</span> s[i] &lt; s[S.top()] <span class="keyword">and</span> M[s[S.top()]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                V[s[S.top()]] = <span class="literal">false</span>;</span><br><span class="line">                S.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            S.push(i);</span><br><span class="line">            V[s[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!S.empty()) &#123;</span><br><span class="line">            res = s[S.top()] + res;</span><br><span class="line">            S.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-03-02</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">XJ</p>
  <div class="site-description" itemprop="description">幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">365</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XJ</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
