<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:type" content="website">
<meta property="og:title" content="BitBrave">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="BitBrave">
<meta property="og:description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="XJ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>BitBrave</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7e6d55cf2fa14e729703953237f65413";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BitBrave</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">IIE</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/LeetCode(331.%20Verify%20Preorder%20Serialization%20of%20a%20Binary%20Tree)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/LeetCode(331.%20Verify%20Preorder%20Serialization%20of%20a%20Binary%20Tree)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(331. Verify Preorder Serialization of a Binary Tree)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 21:09:29 / 修改时间：21:09:32" itemprop="dateCreated datePublished" datetime="2020-05-31T21:09:29+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-331-Verify-Preorder-Serialization-of-a-Binary-Tree-题解"><a href="#LeetCode-331-Verify-Preorder-Serialization-of-a-Binary-Tree-题解" class="headerlink" title="LeetCode(\331. Verify Preorder Serialization of a Binary Tree)题解"></a>LeetCode(\331. Verify Preorder Serialization of a Binary Tree)题解</h1><p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as <code>#</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     2</span><br><span class="line">  &#x2F; \   &#x2F; \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">&#x2F; \ &#x2F; \   &#x2F; \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></table></figure>

<p>For example, the above binary tree can be serialized to the string <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>, where <code>#</code> represents a null node.</p>
<p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p>
<p>Each comma separated value in the string must be either an integer or a character <code>&#39;#&#39;</code> representing <code>null</code> pointer.</p>
<p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as <code>&quot;1,,3&quot;</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1,#&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;9,#,#,1&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Medium</p>
<p>给定一个序列，判断其是否是一颗二叉树的合法前序遍历序列。</p>
<p>这个题想了蛮久，后来发现还是很简单的。就是用栈的思想。凡是遇到数字就将其入栈，如果是“#”，说明走到了根节点，就将栈中的元素弹出一个，这样一个合法的序列最后会剩下一个“#”和一个空的栈。这中间任何一步无法完成，比如栈提前空了等，都说明序列不合法。可以自己随便找个例子走一波。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上O(N)，空间上O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def isValidSerialization(self, preorder: str) -&gt; bool:</span><br><span class="line">        data = preorder.split(<span class="string">","</span>)</span><br><span class="line">        <span class="keyword">if</span> len(data)==<span class="number">1</span> <span class="keyword">and</span> data[<span class="number">0</span>]==<span class="string">"#"</span>: <span class="keyword">return</span> True</span><br><span class="line">        <span class="keyword">if</span> len(data)&lt;<span class="number">3</span> <span class="keyword">or</span> data[<span class="number">-1</span>]!=<span class="string">"#"</span> <span class="keyword">or</span> data[<span class="number">-2</span>]!=<span class="string">"#"</span> <span class="keyword">or</span> data[<span class="number">0</span>]==<span class="string">"#"</span>: <span class="keyword">return</span> False</span><br><span class="line">        </span><br><span class="line">        S = []</span><br><span class="line">        data = data[:<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> d in data:</span><br><span class="line">            <span class="keyword">if</span> d==<span class="string">"#"</span>: </span><br><span class="line">                <span class="keyword">if</span> len(S)==<span class="number">0</span>: <span class="keyword">return</span> False</span><br><span class="line">                S = S[:<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                S += [<span class="keyword">int</span>(d)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> len(S) == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>其实理解了这种思想，完全可以不用Stack，因为只是要判断序列是否合法，所以直接使用一个变量记录当前遇到的数字个数即可。代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def isValidSerialization(self, preorder: str) -&gt; bool:</span><br><span class="line">        data = preorder.split(<span class="string">","</span>)</span><br><span class="line">        <span class="keyword">if</span> len(data)==<span class="number">1</span> <span class="keyword">and</span> data[<span class="number">0</span>]==<span class="string">"#"</span>: <span class="keyword">return</span> True</span><br><span class="line">        <span class="keyword">if</span> len(data)&lt;<span class="number">3</span> <span class="keyword">or</span> data[<span class="number">-1</span>]!=<span class="string">"#"</span> <span class="keyword">or</span> data[<span class="number">-2</span>]!=<span class="string">"#"</span> <span class="keyword">or</span> data[<span class="number">0</span>]==<span class="string">"#"</span>: <span class="keyword">return</span> False</span><br><span class="line">        </span><br><span class="line">        S = <span class="number">0</span></span><br><span class="line">        data = data[:<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> d in data:</span><br><span class="line">            <span class="keyword">if</span> d==<span class="string">"#"</span>: </span><br><span class="line">                <span class="keyword">if</span> S==<span class="number">0</span>: <span class="keyword">return</span> False</span><br><span class="line">                S -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                S += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> S == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-05-31.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/LeetCode(1463.%20Cherry%20Pickup%20II)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/LeetCode(1463.%20Cherry%20Pickup%20II)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(1463. Cherry Pickup II)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 10:03:27 / 修改时间：10:03:30" itemprop="dateCreated datePublished" datetime="2020-05-31T10:03:27+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-1463-Cherry-Pickup-II-题解"><a href="#LeetCode-1463-Cherry-Pickup-II-题解" class="headerlink" title="LeetCode(\1463. Cherry Pickup II)题解"></a>LeetCode(\1463. Cherry Pickup II)题解</h1><p>Given a <code>rows x cols</code> matrix <code>grid</code> representing a field of cherries. Each cell in <code>grid</code> represents the number of cherries that you can collect.</p>
<p>You have two robots that can collect cherries for you, Robot #1 is located at the top-left corner (0,0) , and Robot #2 is located at the top-right corner (0, cols-1) of the grid.</p>
<p>Return the maximum number of cherries collection using both robots by following the rules below:</p>
<ul>
<li>From a cell (i,j), robots can move to cell (i+1, j-1) , (i+1, j) or (i+1, j+1).</li>
<li>When any robot is passing through a cell, It picks it up all cherries, and the cell becomes an empty cell (0).</li>
<li>When both robots stay on the same cell, only one of them takes the cherries.</li>
<li>Both robots cannot move outside of the grid at any moment.</li>
<li>Both robots should reach the bottom row in the <code>grid</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2020/04/29/sample_1_1802.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]</span><br><span class="line">Output: 24</span><br><span class="line">Explanation: Path of robot #1 and #2 are described in color green and blue respectively.</span><br><span class="line">Cherries taken by Robot #1, (3 + 2 + 5 + 2) &#x3D; 12.</span><br><span class="line">Cherries taken by Robot #2, (1 + 5 + 5 + 1) &#x3D; 12.</span><br><span class="line">Total of cherries: 12 + 12 &#x3D; 24.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2020/04/23/sample_2_1802.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]</span><br><span class="line">Output: 28</span><br><span class="line">Explanation: Path of robot #1 and #2 are described in color green and blue respectively.</span><br><span class="line">Cherries taken by Robot #1, (1 + 9 + 5 + 2) &#x3D; 17.</span><br><span class="line">Cherries taken by Robot #2, (1 + 3 + 4 + 3) &#x3D; 11.</span><br><span class="line">Total of cherries: 17 + 11 &#x3D; 28.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]</span><br><span class="line">Output: 22</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,1],[1,1]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>



<p><strong>Constraints:</strong></p>
<ul>
<li><code>rows == grid.length</code></li>
<li><code>cols == grid[i].length</code></li>
<li><code>2 &lt;= rows, cols &lt;= 70</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>给你一个 rows x cols 的矩阵 grid 来表示一块樱桃地。 grid 中每个格子的数字表示你能获得的樱桃数目。</p>
<p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 (0,0) 出发，机器人 2 从右上角格子 (0, cols-1) 出发。</p>
<p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p>
<p>从格子 (i,j) 出发，机器人可以移动到格子 (i+1, j-1)，(i+1, j) 或者 (i+1, j+1) 。<br>当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。<br>当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。<br>两个机器人在任意时刻都不能移动到 grid 外面。<br>两个机器人最后都要到达 grid 最底下一行。</p>
<p>这个题比简单的单个机器人要难一些，但是也可以做，还是使用DP。</p>
<p>这里我们明确一个概念，两个机器人最多相逢，搜寻路径不会交叉。因为如果交叉，我们可以把交叉之后的机器人身份互换，从而变得不交叉。</p>
<p>观察row和col的限制都不大，所以我们直接构建DP[i][l][r]表示到达地i行时，两个机器人分别在第l列和第j列时所得到的最多的樱桃。那么状态转移方程就很好写了，就是上一行的每个机器人的3个位置，共9种选择。</p>
<p>但是这里要注意，两个机器人一个从左上角，一个从右上角，那么在前几行注定有一些位置是左边机器人到不了的，一些是右边机器人到不了的，还存在两个都到不了的，还存在都在的情况。这时候就不能简单的组合选择了。</p>
<p>如果都能到，就简单判断，如果到达的是同一个位置（l==r），就只加一个值，表示只有一个机器人摘樱桃。</p>
<p>如果只有一个能到，那么就只加一个值，l或者r。</p>
<p>如果都不能到，为0.</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，设行为N，列为M。那么时间上，O(NMM)，空间上，O(NMM)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cherryPickup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.<span class="built_in">size</span>(), col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">DP</span><span class="params">(row, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(col, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0</span>)))</span></span>;</span><br><span class="line">        DP[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++) DP[<span class="number">0</span>][<span class="number">0</span>][j] = <span class="built_in">max</span>(DP[<span class="number">0</span>][<span class="number">0</span>][j], grid[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++) DP[<span class="number">0</span>][j][col<span class="number">-1</span>] = <span class="built_in">max</span>(DP[<span class="number">0</span>][j][col<span class="number">-1</span>], grid[<span class="number">0</span>][col<span class="number">-1</span>]);</span><br><span class="line">        </span><br><span class="line">        DP[<span class="number">0</span>][<span class="number">0</span>][col<span class="number">-1</span>] = grid[<span class="number">0</span>][<span class="number">0</span>] + grid[<span class="number">0</span>][col<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;col; l++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r=l; r&lt;col; r++) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> s = (l==r) ? grid[i][l] : (grid[i][l] + grid[i][r]);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">-1</span>; k&lt;=<span class="number">1</span>; k++) &#123;</span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> h=<span class="number">-1</span>; h&lt;=<span class="number">1</span>; h++) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (l+k&gt;=<span class="number">0</span> <span class="keyword">and</span> l+k&lt;col <span class="keyword">and</span> r+h&gt;=<span class="number">0</span> <span class="keyword">and</span> r+h&lt;col) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (l+k&lt;=i<span class="number">-1</span> <span class="keyword">and</span> r+h&gt;=col-i)</span><br><span class="line">                                    DP[i][l][r] = <span class="built_in">max</span>(DP[i][l][r], DP[i<span class="number">-1</span>][l+k][r+h] + s);</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (l+k&lt;=i<span class="number">-1</span>)</span><br><span class="line">                                    DP[i][l][r] = <span class="built_in">max</span>(DP[i][l][r], DP[i<span class="number">-1</span>][l+k][r+h] + grid[i][l]);</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (r+h&gt;=col-i)</span><br><span class="line">                                    DP[i][l][r] = <span class="built_in">max</span>(DP[i][l][r], DP[i<span class="number">-1</span>][l+k][r+h] + grid[i][r]);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;col; l++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r=l; r&lt;col; r++) res = <span class="built_in">max</span>(res, DP[row<span class="number">-1</span>][l][r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Bitbrave，2020-05-31</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/LeetCode(778.%20Swim%20in%20Rising%20Water)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/29/LeetCode(778.%20Swim%20in%20Rising%20Water)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(778. Swim in Rising Water)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-29 23:49:46" itemprop="dateCreated datePublished" datetime="2020-05-29T23:49:46+08:00">2020-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-30 10:14:44" itemprop="dateModified" datetime="2020-05-30T10:14:44+08:00">2020-05-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-778-Swim-in-Rising-Water-题解"><a href="#LeetCode-778-Swim-in-Rising-Water-题解" class="headerlink" title="LeetCode(\778. Swim in Rising Water)题解"></a>LeetCode(\778. Swim in Rising Water)题解</h1><p>On an N x N <code>grid</code>, each square <code>grid[i][j]</code> represents the elevation at that point <code>(i,j)</code>.</p>
<p>Now rain starts to fall. At time <code>t</code>, the depth of the water everywhere is <code>t</code>. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most <code>t</code>. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p>
<p>You start at the top left square <code>(0, 0)</code>. What is the least time until you can reach the bottom right square <code>(N-1, N-1)</code>?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,2],[1,3]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">At time 0, you are in grid location (0, 0).</span><br><span class="line">You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t &#x3D; 0.</span><br><span class="line"></span><br><span class="line">You cannot reach point (1, 1) until time 3.</span><br><span class="line">When the depth of water is 3, we can swim anywhere inside the grid.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]</span><br><span class="line">Output: 16</span><br><span class="line">Explanation:</span><br><span class="line"> 0  1  2  3  4</span><br><span class="line">24 23 22 21  5</span><br><span class="line">12 13 14 15 16</span><br><span class="line">11 17 18 19 20</span><br><span class="line">10  9  8  7  6</span><br><span class="line"></span><br><span class="line">The final route is marked in bold.</span><br><span class="line">We need to wait until time 16 so that (0, 0) and (4, 4) are connected.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><code>2 &lt;= N &lt;= 50</code>.</li>
<li>grid[i][j] is a permutation of [0, …, N*N - 1].</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。</p>
<p>现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p>
<p>你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？</p>
<p>这个题其实就是从左上角找一条路径到右下角，路径中的经过节点的最大值在所有路径中最小。</p>
<p>我们可以使用二分法做这个题，可以知道解的上限和下限，上限就是数组最高的值，所有路径中最大花费肯定就是这个上限值，就是我通过最高的平台，最低的下限就是最低的平台，但是这个不一定能达到，因此答案一定在二者之间。</p>
<p>我们每次二分取中间值，然后查看是否存在可以不高于这个中间值的平台路径，如果存在，说明中间值可达，那答案一定在中间值和下限之间，那就把中间值作为新的上限，继续上面的操作，反之答案一定在中间值+1和上限之间。那就吧中间值+1作为新的下限进行求解。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上，O(N2logN2)，空间上O(N2)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; G, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> <span class="keyword">or</span> r &gt;= n <span class="keyword">or</span> c &lt; <span class="number">0</span> <span class="keyword">or</span> c &gt;= n <span class="keyword">or</span> visit[r][c]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visit[r][c] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (G[r][c] &gt; m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r == n<span class="number">-1</span> <span class="keyword">and</span> c == n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(r<span class="number">-1</span>, c, m, n, G, visit) <span class="keyword">or</span> dfs(r+<span class="number">1</span>, c, m, n, G, visit) <span class="keyword">or</span> dfs(r, c<span class="number">-1</span>, m, n, G, visit) <span class="keyword">or</span> dfs(r, c+<span class="number">1</span>, m, n, G, visit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; G)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visit</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, m, n, G, visit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = N * N - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (helper(mid, N, grid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-05-30</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/LeetCode(%E9%9D%A2%E8%AF%95%E9%A2%98%2008.02.%20%E8%BF%B7%E8%B7%AF%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/29/LeetCode(%E9%9D%A2%E8%AF%95%E9%A2%98%2008.02.%20%E8%BF%B7%E8%B7%AF%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(面试题 08.02. 迷路的机器人)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-29 14:28:12 / 修改时间：14:28:13" itemprop="dateCreated datePublished" datetime="2020-05-29T14:28:12+08:00">2020-05-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-面试题-08-02-迷路的机器人-题解"><a href="#LeetCode-面试题-08-02-迷路的机器人-题解" class="headerlink" title="LeetCode(面试题 08.02. 迷路的机器人)题解"></a>LeetCode(<a href="https://leetcode-cn.com/problems/robot-in-a-grid-lcci/" target="_blank" rel="noopener">面试题 08.02. 迷路的机器人</a>)题解</h1><p>设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt="img"></p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。</p>
<p>示例 1:</p>
<p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: [[0,0],[0,1],[0,2],[1,2],[2,2]]<br>解释:<br>输入中标粗的位置即为输出表示的路径，即<br>0行0列（左上角） -&gt; 0行1列 -&gt; 0行2列 -&gt; 1行2列 -&gt; 2行2列（右下角）<br>说明：r 和 c 的值均不超过 100。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/robot-in-a-grid-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/robot-in-a-grid-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Medium</p>
<p>这个题第一时间想到的就是DFS。直接深度遍历即可，为了避免重复遍历，可以使用一个visit数组，记录已经走过的地方。</p>
<p>代码如如下，时间上O(N*M)，空间上，O(N*M)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G, res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit;</span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hlepr</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"enter"&lt;&lt;r&lt;&lt;c&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span> (visit[r][c]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visit[r][c] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= row <span class="keyword">or</span> c &gt;= col <span class="keyword">or</span> G[r][c]==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r == row<span class="number">-1</span> <span class="keyword">and</span> c == col<span class="number">-1</span>) &#123;</span><br><span class="line">            res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;r, c&#125;));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;r, c&#125;));</span><br><span class="line">        <span class="keyword">if</span> (c &lt; col<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hlepr(r, c+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; row<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hlepr(r+<span class="number">1</span>, c)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        G = obstacleGrid;</span><br><span class="line">        row = G.<span class="built_in">size</span>(); col = G[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        visit = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;(row, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col, <span class="literal">false</span>));</span><br><span class="line">        hlepr(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实还可以用DP，直接使用一个DP数组，其中DP[i][j]表示ij位置是否存在到左上角的路径，如果有标明路径上一个节点的位置，因为这里只能向下向右，因此用1表示上，2表示左，0表示不可达。</p>
<p>那么状态转移方程就很好写了。<br>$$<br>DP[i][j] = DP[i-1][j] \ \ \ \ if DP[i-1][j]!=0 \ \ \ else \ \ \ DP[i][j-1];<br>$$<br>代码如下，时间上O(N*M)，空间上O(N*M).这个比DFS还是快很多的，因此省去了很多不必要的判断。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = obstacleGrid.<span class="built_in">size</span>(), col = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; DP(row, vector&lt;int&gt;(col, 0)), res;</span><br><span class="line">        </span><br><span class="line">        DP[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> - obstacleGrid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> DP[i<span class="number">-1</span>][j]) DP[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span> <span class="keyword">and</span> DP[i][j<span class="number">-1</span>]) DP[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DP[row<span class="number">-1</span>][col<span class="number">-1</span>] == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res.push_back(<span class="built_in">vector</span>(&#123;row<span class="number">-1</span>, col<span class="number">-1</span>&#125;));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (res[<span class="number">0</span>][<span class="number">0</span>] + res[<span class="number">0</span>][<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DP[res[<span class="number">0</span>][<span class="number">0</span>]][res[<span class="number">0</span>][<span class="number">1</span>]] == <span class="number">1</span>) res.insert(res.<span class="built_in">begin</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;res[<span class="number">0</span>][<span class="number">0</span>]<span class="number">-1</span>, res[<span class="number">0</span>][<span class="number">1</span>]&#125;));</span><br><span class="line">            <span class="keyword">if</span> (DP[res[<span class="number">0</span>][<span class="number">0</span>]][res[<span class="number">0</span>][<span class="number">1</span>]] == <span class="number">2</span>) res.insert(res.<span class="built_in">begin</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;res[<span class="number">0</span>][<span class="number">0</span>], res[<span class="number">0</span>][<span class="number">1</span>]<span class="number">-1</span>&#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-05-29.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/28/LeetCode(935.%20%E9%AA%91%E5%A3%AB%E6%8B%A8%E5%8F%B7%E5%99%A8)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/28/LeetCode(935.%20%E9%AA%91%E5%A3%AB%E6%8B%A8%E5%8F%B7%E5%99%A8)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(935. 骑士拨号器)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-28 21:23:06 / 修改时间：21:25:24" itemprop="dateCreated datePublished" datetime="2020-05-28T21:23:06+08:00">2020-05-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-935-骑士拨号器-题解"><a href="#LeetCode-935-骑士拨号器-题解" class="headerlink" title="LeetCode(935. 骑士拨号器)题解"></a>LeetCode(<a href="https://leetcode-cn.com/problems/knight-dialer/" target="_blank" rel="noopener">935. 骑士拨号器</a>)题解</h1><p>国际象棋中的骑士可以按下图所示进行移动：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/11/03/knight.png" alt="img">)<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/11/03/keypad.png" alt="img"></p>
<p>这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。</p>
<p>每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 N 位数字。</p>
<p>你能用这种方式拨出多少个不同的号码？</p>
<p>因为答案可能很大，所以输出答案模 10^9 + 7。</p>
<p>示例 1：</p>
<p>输入：1<br>输出：10<br>示例 2：</p>
<p>输入：2<br>输出：20<br>示例 3：</p>
<p>输入：3<br>输出：46</p>
<p>提示：</p>
<p>1 &lt;= N &lt;= 5000</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Medium</p>
<p>这个题明显可以使用DFS+记忆化递归，当然也就可以转为DP。只需要设f(i,N)，假设当前骑士的位置时i，要跳N步时的总的方案数即可。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上O(10*N)，空间上O(10*N).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; M;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; V;</span><br><span class="line">    <span class="keyword">long</span> mod;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (M[N][p] != <span class="number">-1</span>) <span class="keyword">return</span> M[N][p];</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">5</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : V[p]) res = (res + dfs(v, N<span class="number">-1</span>)) % mod;</span><br><span class="line"></span><br><span class="line">        M[N][p] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">knightDialer</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        mod = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">9</span>) + <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        V = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        M = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt;(N+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;(<span class="number">10</span>, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        V[<span class="number">0</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">4</span>,<span class="number">6</span>&#125;); V[<span class="number">1</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">8</span>,<span class="number">6</span>&#125;);</span><br><span class="line">        V[<span class="number">2</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">7</span>,<span class="number">9</span>&#125;); V[<span class="number">3</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">4</span>,<span class="number">8</span>&#125;);</span><br><span class="line">        V[<span class="number">4</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        V[<span class="number">5</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(); V[<span class="number">6</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        V[<span class="number">7</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">2</span>,<span class="number">6</span>&#125;); V[<span class="number">8</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">1</span>,<span class="number">3</span>&#125;);</span><br><span class="line">        V[<span class="number">9</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">4</span>,<span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> t = dfs(i, N);</span><br><span class="line">            <span class="comment">//cout&lt;&lt;i&lt;&lt;" -&gt;" &lt;&lt;t&lt;&lt;endl;</span></span><br><span class="line">            res = (res + t) % mod; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2020-05-28.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/27/LeetCode(930.%20%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/27/LeetCode(930.%20%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(930. 和相同的二元子数组)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-27 18:51:12 / 修改时间：18:57:41" itemprop="dateCreated datePublished" datetime="2020-05-27T18:51:12+08:00">2020-05-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-930-和相同的二元子数组-题解"><a href="#LeetCode-930-和相同的二元子数组-题解" class="headerlink" title="LeetCode(930. 和相同的二元子数组)题解"></a>LeetCode(<a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/" target="_blank" rel="noopener">930. 和相同的二元子数组</a>)题解</h1><p>在由若干 0 和 1  组成的数组 A 中，有多少个和为 S 的非空子数组。</p>
<p>示例：</p>
<p>输入：A = [1,0,1,0,1], S = 2<br>输出：4<br>解释：<br>如下面黑体所示，有 4 个满足题目要求的子数组：<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]</p>
<p>提示：</p>
<p>A.length &lt;= 30000<br>0 &lt;= S &lt;= A.length<br>A[i] 为 0 或 1</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Medium</p>
<p>使用前缀和求出数组的区间和<br>DP方程，DP[i]表示和为i的前缀和个数。<br>枚举每一个区间的终点，如果prefix_sum &gt;= S，那么就观察DP[prefix_sum - S]的个数，因为对于prefix_sum来说，前面有多少个prefix_sum - S, 就有几个S。</p>
<p>注意这里要设置DP[0]=1。表示如果当前整个前缀和就是S的话，那一共至少有1个子数组满足条件。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间和空间均为O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">DP</span><span class="params">(len + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        DP[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i ++) &#123;</span><br><span class="line">            sum += A[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= S) res += DP[sum - S];</span><br><span class="line">            DP[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-05-27。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/27/LeetCode(1458.%20Max%20Dot%20Product%20of%20Two%20Subsequences)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/27/LeetCode(1458.%20Max%20Dot%20Product%20of%20Two%20Subsequences)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(1458. Max Dot Product of Two Subsequences)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-27 09:29:05 / 修改时间：18:57:50" itemprop="dateCreated datePublished" datetime="2020-05-27T09:29:05+08:00">2020-05-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-1458-Max-Dot-Product-of-Two-Subsequences-题解"><a href="#LeetCode-1458-Max-Dot-Product-of-Two-Subsequences-题解" class="headerlink" title="LeetCode(1458. Max Dot Product of Two Subsequences)题解"></a>LeetCode(<a href="https://leetcode-cn.com/problems/max-dot-product-of-two-subsequences/" target="_blank" rel="noopener">1458. Max Dot Product of Two Subsequences</a>)题解</h1><p>给你两个数组 nums1 和 nums2 。</p>
<p>请你返回 nums1 和 nums2 中两个长度相同的 非空 子序列的最大点积。</p>
<p>数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，[2,3,5] 是 [1,2,3,4,5] 的一个子序列而 [1,5,3] 不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [2,1,-2,5], nums2 &#x3D; [3,0,-6]</span><br><span class="line">输出：18</span><br><span class="line">解释：从 nums1 中得到子序列 [2,-2] ，从 nums2 中得到子序列 [3,-6] 。</span><br><span class="line">它们的点积为 (2*3 + (-2)*(-6)) &#x3D; 18 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [3,-2], nums2 &#x3D; [2,-6,7]</span><br><span class="line">输出：21</span><br><span class="line">解释：从 nums1 中得到子序列 [3] ，从 nums2 中得到子序列 [7] 。</span><br><span class="line">它们的点积为 (3*7) &#x3D; 21 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [-1,-1], nums2 &#x3D; [1,1]</span><br><span class="line">输出：-1</span><br><span class="line">解释：从 nums1 中得到子序列 [-1] ，从 nums2 中得到子序列 [1] 。</span><br><span class="line">它们的点积为 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums1.length, nums2.length &lt;= 500</li>
<li>-1000 &lt;= nums1[i], nums2[i] &lt;= 100</li>
</ul>
<p><strong>点积：</strong></p>
<p>定义 a = [a1, a2,…, an] 和 b = [b1, b2,…, bn] 的点积为：</p>
<p><img src="http://upload.wikimedia.org/math/c/3/2/c329bf86e747d74f55ed2e17c36fd83f.png" alt="\mathbf{a}\cdot \mathbf{b} = \sum_{i=1}^n a_ib_i = a_1b_1 + a_2b_2 + \cdots + a_nb_n"></p>
<p>这里的 Σ 指示总和符号。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>这个题其实就是从两个数组中选出等长的一个子数组，在保证相对顺序的前提下将所有元素两两相乘再相加得到最后的结果。求最大的。</p>
<p>明显可以使用DP做。</p>
<p>设定f(i,j)表示第下标从1开始，nums1中的前i个和nums2中的前j个中满足题目要求的最大点积。显然，f(0,0)=0.</p>
<p>那么如何来填充f(i,j)呢？</p>
<p>可以分析，在计算f(i,j)时，f(i-1,j)和f(i,j-1)肯定已经计算完毕。因此仅需要考虑nums1[i-1]和nums2[j-1]配对的情况即可。</p>
<p>因此，状态转移方程如下。<br>$$<br>f(i,j) = max(f(i-1,j), f(i,j-1), nums1[i-1] * nums2[j-1] + f(i-1,j-1)) (i&gt;1, j&gt;1)<br>$$<br>当i=1orj=1时，说明nums1或者nums2只有一个数，此时可以直接计算出来。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，时间上O(N)，空间上O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDotProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.<span class="built_in">size</span>(), len2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">V</span><span class="params">(len1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2+<span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=len2; j++) &#123;</span><br><span class="line">                V[i][j] = nums1[i<span class="number">-1</span>] * nums2[j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">1</span>) V[i][j] = <span class="built_in">max</span>(V[i][j], V[i<span class="number">-1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span> (j&gt;<span class="number">1</span>) V[i][j] = <span class="built_in">max</span>(V[i][j], V[i][j<span class="number">-1</span>]);</span><br><span class="line">                V[i][j] = <span class="built_in">max</span>(V[i][j], nums1[i<span class="number">-1</span>] * nums2[j<span class="number">-1</span>] + V[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> V[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-05-27.（LeetCode账号被封真的好烦啊！）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/12/LeetCode(287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/12/LeetCode(287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(287. 寻找重复数)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-12 23:19:09 / 修改时间：23:19:11" itemprop="dateCreated datePublished" datetime="2020-05-12T23:19:09+08:00">2020-05-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-287-寻找重复数-题解"><a href="#LeetCode-287-寻找重复数-题解" class="headerlink" title="LeetCode(287. 寻找重复数)题解"></a>LeetCode(<a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a>)题解</h1><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Medium</p>
<p>这个可以最简答的方式就是使用Set，或者排序之后寻找，但是时间复杂度要么比较大，要么就是空间复杂度O(n)。下面介绍几种各方面都比较精妙的办法。</p>
<h3 id="解法1（二分法）"><a href="#解法1（二分法）" class="headerlink" title="解法1（二分法）"></a>解法1（二分法）</h3><p>从1到n中取中间数，然后从数组中寻找小于等于mid的数有多少个，如果大于一半的话，说明数据肯定多了，那么重复的肯定就在里面，否则就在右边部分。时间复杂度O(nlogn)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = len - <span class="number">1</span>, sum, mid;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n &gt;= l <span class="keyword">and</span> n &lt;= mid) sum++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// cout&lt;&lt;mid&lt;&lt;" -&gt; "&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span> (mid - l + <span class="number">1</span> &lt; sum) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法2（二进制）"><a href="#解法2（二进制）" class="headerlink" title="解法2（二进制）"></a>解法2（二进制）</h3><p>主要就是我们要把数字放眼到二进制。</p>
<p>然后依次统计数组中每一位 1 的个数，记为 a[i]。再依次统计 1 到 n 中每一位 1 的个数，记为 b[i]。i 代表的是哪一位，因为是 int，所以范围是 0 到 32。</p>
<p>记重复的数字是 res。</p>
<p>如果 a[i] &gt; b[i] 也就意味着 res 当前位是 1。</p>
<p>否则的话，res 当前位就是 0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; Num1(32, 0), Num2(32, 0);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">32</span>; p++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">                Num1[p] += (i &gt;&gt; p) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">                Num2[p] += (nums[i] &gt;&gt; p) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt; Num1[p]&lt;&lt;" "&lt;&lt;Num2[p]&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;<span class="number">32</span>; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Num2[p] &gt; Num1[p]) res += <span class="number">1</span> &lt;&lt; p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法3（快慢指针）"><a href="#解法3（快慢指针）" class="headerlink" title="解法3（快慢指针）"></a>解法3（快慢指针）</h3><p>把数组的值看成 <code>next</code> 指针，数组的下标看成节点的索引。因为数组中至少有两个值一样，也说明有两个节点指向同一个位置，所以一定会出现环。</p>
<p>我们需要快慢指针，同时从起点出发，慢指针一次走一步，快指针一次走两步，然后记录快慢指针相遇的点。</p>
<p>之后再用两个指针，一个指针从起点出发，一个指针从相遇点出发，当他们再次相遇的时候就是入口点了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave，2020-05-12</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/09/LeetCode(295.%20Find%20Median%20from%20Data%20Stream)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/09/LeetCode(295.%20Find%20Median%20from%20Data%20Stream)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(295. Find Median from Data Stream)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-09 20:22:15 / 修改时间：20:45:48" itemprop="dateCreated datePublished" datetime="2020-05-09T20:22:15+08:00">2020-05-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-295-Find-Median-from-Data-Stream-题解"><a href="#LeetCode-295-Find-Median-from-Data-Stream-题解" class="headerlink" title="LeetCode(\295. Find Median from Data Stream)题解"></a>LeetCode(\295. Find Median from Data Stream)题解</h1><p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2,3,4]&#96;, the median is &#96;3</span><br><span class="line">[2,3]&#96;, the median is &#96;(2 + 3) &#x2F; 2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>

<p>Design a data structure that supports the following two operations:</p>
<ul>
<li>void addNum(int num) - Add a integer number from the data stream to the data structure.</li>
<li>double findMedian() - Return the median of all elements so far.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addNum(1)</span><br><span class="line">addNum(2)</span><br><span class="line">findMedian() -&gt; 1.5</span><br><span class="line">addNum(3) </span><br><span class="line">findMedian() -&gt; 2</span><br></pre></td></tr></table></figure>



<p><strong>Follow up:</strong></p>
<ol>
<li>If all integer numbers from the stream are between 0 and 100, how would you optimize it?</li>
<li>If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p>
<p>这个题说实话不难，最简单的就是排序，每次寻找中位数都排序（当然也可以使用插入排序，使用其它排序方法会超时），但这样太耗时了。</p>
<p>还有就是实现BST，如果要追求平衡的话，还需要进行旋转实现AVL，不过这里我只是实现了BST。</p>
<p>（还有更好的方式就是使用一个最大堆和一个最小堆实现，两个堆各占一半的元素。或者使用multiset实现AVL性质，这里是具体的解法<a href="https://leetcode-cn.com/problems/find-median-from-data-stream/solution/shu-ju-liu-de-zhong-wei-shu-by-leetcode/）" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-median-from-data-stream/solution/shu-ju-liu-de-zhong-wei-shu-by-leetcode/）</a></p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，每次插入和寻找的平均时间复杂度为O(logn)，但是如果数目本身就是有序的话，那复杂度就是O(n)。空间上就是O(n).</p>
<p><code>Runtime: 216 ms, faster than 77.32% of C++ online submissions for Find Median from Data Stream.</code></p>
<p><code>Memory Usage: 48.1 MB, less than 8.70% of C++ online submissions for Find Median from Data Stream.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode_xj</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, ls, rs;</span><br><span class="line">    TreeNode_xj* left, *right;</span><br><span class="line">    TreeNode_xj (<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c): val(a), ls(b), rs(c), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    TreeNode_xj* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        root = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum_help</span><span class="params">(<span class="keyword">int</span> num, TreeNode_xj* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt;= num) &#123;</span><br><span class="line">            root-&gt;rs += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) root-&gt;right = <span class="keyword">new</span> TreeNode_xj(num, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> addNum_help(num, root-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root-&gt;ls += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) root-&gt;left = <span class="keyword">new</span> TreeNode_xj(num, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> addNum_help(num, root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) root = <span class="keyword">new</span> TreeNode_xj(num, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> addNum_help(num, root);</span><br><span class="line"></span><br><span class="line">        len += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findK</span><span class="params">(TreeNode_xj* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;ls + <span class="number">1</span> &gt; k) <span class="keyword">return</span> findK(root-&gt;left, k);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;ls + <span class="number">1</span> == k) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> findK(root-&gt;right, k - root-&gt;ls - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len &amp; <span class="number">1</span> == <span class="number">1</span>) <span class="keyword">return</span> findK(root, len / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (findK(root, len / <span class="number">2</span>) + findK(root, len / <span class="number">2</span> + <span class="number">1</span>)) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>PS：有时候自己辛辛苦苦写出来的算法，以为很好了，可是一看题解，发现还是别人的更简洁和有效。有点受打击。</p>
<p>BitBrave, 2020-05-09</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/08/LeetCode(315.%20Count%20of%20Smaller%20Numbers%20After%20Self)%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
      <meta itemprop="name" content="XJ">
      <meta itemprop="description" content="幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BitBrave">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/08/LeetCode(315.%20Count%20of%20Smaller%20Numbers%20After%20Self)%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">LeetCode(315. Count of Smaller Numbers After Self)题解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-08 00:04:54" itemprop="dateCreated datePublished" datetime="2020-05-08T00:04:54+08:00">2020-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-09 00:12:43" itemprop="dateModified" datetime="2020-05-09T00:12:43+08:00">2020-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="LeetCode-315-Count-of-Smaller-Numbers-After-Self-题解"><a href="#LeetCode-315-Count-of-Smaller-Numbers-After-Self-题解" class="headerlink" title="LeetCode(\315. Count of Smaller Numbers After Self)题解"></a>LeetCode(\315. Count of Smaller Numbers After Self)题解</h1><p>You are given an integer array <em>nums</em> and you have to return a new <em>counts</em> array. The <em>counts</em> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,2,6,1]</span><br><span class="line">Output: [2,1,1,0] </span><br><span class="line">Explanation:</span><br><span class="line">To the right of 5 there are 2 smaller elements (2 and 1).</span><br><span class="line">To the right of 2 there is only 1 smaller element (1).</span><br><span class="line">To the right of 6 there is 1 smaller element (1).</span><br><span class="line">To the right of 1 there is 0 smaller element.</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>Hard</p>
<p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<p>这个最暴力的就是n2时间，每一个数都遍历一下右边有几个小于该数。</p>
<p>但是这里可以利用归并分治的思想，就跟求逆序数一样。我们对这个数组进行排序，不过是根据元素值对对应的位置进行排序。</p>
<p>对于一个数组，我们进行二分，假设左边和右边子数组内的每个元素之间的关系已经定了，那么现在就只考虑左边的和右边的关系了。两个子数组都是升序。那么从两个子数组的开始向后每次选择最小的进入最终的，对于左边某个数，如果大于右边这个数，那么就肯定大于这个数前面的所有数，所以我们用一个count记录右边数组已经走过的长度，如果右边大于等于左边这个数，说明左边这个数必须被选走了，因为右边后面不会再有小于左边的这个数的元素了。所有左边这个元素的对应结果就加上count。</p>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>代码如下，这就是一个完全的归并排序，只不过在中间记录了一下数而已。时间上，O(nlogn)，空间上，O(n)。</p>
<p><code>Runtime: 28 ms, faster than 85.00% of C++ online submissions for Count of Smaller Numbers After Self.</code></p>
<p><code>Memory Usage: 28.6 MB, less than 50.00% of C++ online submissions for Count of Smaller Numbers After Self.</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Count;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos, Nums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> sta, <span class="keyword">int</span> mid, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(pos.<span class="built_in">begin</span>()+sta, pos.<span class="built_in">begin</span>()+<span class="built_in">end</span>+<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = sta, r = mid + <span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=sta; k&lt;=<span class="built_in">end</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; mid) pos[k] = tmp[r++-sta];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (r &gt; <span class="built_in">end</span>) &#123;</span><br><span class="line">                Count[tmp[l-sta]] += count;</span><br><span class="line">                pos[k] = tmp[l++-sta];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Nums[tmp[l-sta]] &gt; Nums[tmp[r-sta]]) &#123;</span><br><span class="line">                pos[k] = tmp[r++-sta];</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Count[tmp[l-sta]] += count;</span><br><span class="line">                pos[k] = tmp[l++-sta];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> sta, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sta &gt;= <span class="built_in">end</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (sta + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(sta, mid);</span><br><span class="line">        MergeSort(mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">        Merge(sta, mid, <span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        Count = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len, <span class="number">0</span>);</span><br><span class="line">        pos = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len);</span><br><span class="line">        Nums = nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) pos[i] = i;</span><br><span class="line"></span><br><span class="line">        MergeSort(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BitBrave, 2020-05-07</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XJ"
      src="http://img.duoziwang.com/2017/05/20/B28913465.jpg">
  <p class="site-author-name" itemprop="name">XJ</p>
  <div class="site-description" itemprop="description">幸福总是相通的，不幸则各有各的不幸。寂寞好像是世人的共性，众生都是我，也都不是我。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">337</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BitBrave, IIE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
